<script>
  let state = {};
  let players = [];
  let playerTraits = {};
  let rollThresholds = [];
  let breakawaySettings = [];
  let drainSettings = {};  // Populated from backend on load
  let tackleSettings = [];
  let sackLossTable = [];
  let frontendStats = [];
  let defensiveStats = [];
  let passingStats = [];
  let receivingStats = [];
  let gameId = 1;
  let playHistory = [];
  let savedFormations = [];
  let currentFormation = [];
  let defensiveFormation = [];
  let autoStuff = false;
  let autoRelease = false;
  let offStarPower = false;
  let defStarPower = false;
  let defStarPowerTackler = '';
  let pendingFGTeam = null;
  let isTwoPtAttempt = false;
  let twoPtTeam = null;
  let postPATState = null;
  const RUN_POSITIONS = ['WR1','RB1','RB2','QB'];
  const ROUTE_OPTIONS = ['No Route','Screen','Short','Medium','Med-Long','Long','Deep'];
  const QB_READ_OPTIONS = ['Primary','2nd','3rd','4th','Checkdown'];
  let receiverRoutes = {};
  let playerReadSelection = {};
  let qbReadAssignments = {};
  let currentDetailEl = null;
  let selectedPlayer = null;
  let runSelectedPlayer = null;
  let runningClock = false;
  let chewClock = false;
  let hurryUp = false;
  let completionTable = [];
  let routeTypeAirYards = [];
  let timeNeededToOpen = [];
  let completionSeparationAdjustment = [];
  let yacBySeparation = {};
  let gamesListLoaded = false;
  let spectateMode = false;
  let spectateInterval = null;
  let lastSpectateKey = null;
  const SPECTATE_REFRESH_MS = 15000;

  function showLoadingScreen(homeLogo, awayLogo) {
    const screen = document.getElementById('loadingScreen');
    if (!screen) return;
    const home = document.getElementById('loadingHomeLogo');
    const away = document.getElementById('loadingAwayLogo');
    if (home) {
      home.src = homeLogo || '';
      home.classList.remove('animate-left', 'unclash-left');
      void home.offsetWidth;
      home.classList.add('animate-left');
    }
    if (away) {
      away.src = awayLogo || '';
      away.classList.remove('animate-right', 'unclash-right');
      void away.offsetWidth;
      away.classList.add('animate-right');
    }
    screen.classList.remove('hidden', 'exit-zoom');
  }

  function hideLoadingScreen() {
    const screen = document.getElementById('loadingScreen');
    if (!screen) return;
    const home = document.getElementById('loadingHomeLogo');
    const away = document.getElementById('loadingAwayLogo');

    if (home) {
      home.classList.remove('animate-left');
      void home.offsetWidth;
      home.classList.add('unclash-left');
    }
    if (away) {
      away.classList.remove('animate-right');
      void away.offsetWidth;
      away.classList.add('unclash-right');
    }

    screen.classList.add('exit-zoom');
    screen.addEventListener('animationend', function handler(e) {
      if (e.target === screen && e.animationName === 'zoom-in') {
        screen.classList.add('hidden');
        screen.classList.remove('exit-zoom');
        if (home) home.classList.remove('unclash-left');
        if (away) away.classList.remove('unclash-right');
        screen.removeEventListener('animationend', handler);
      }
    });
  }

  function showAppLoading() {
    const screen = document.getElementById('appLoading');
    if (screen) screen.classList.remove('hidden');
  }

  function hideAppLoading() {
    const screen = document.getElementById('appLoading');
    if (screen) screen.classList.add('hidden');
  }

  function updateStickyOffsets() {
    const scoreboard = document.getElementById('scoreboard');
    if (!scoreboard) return;
    const root = document.documentElement;
    root.style.setProperty('--scoreboardHeight', scoreboard.offsetHeight + 'px');
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.league-tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        const targetId = tab.getAttribute('data-tab');
        const target = document.getElementById(targetId);
        if (target) target.classList.add('active');
        if (targetId === 'scores' && !gamesListLoaded) {
          loadGamesList();
        }
      });
    });
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const tabId = (btn.getAttribute('data-tab') || '').trim();
        const target = document.getElementById(tabId);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.stats-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.stats-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.stats-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        const targetId = tab.getAttribute('data-tab');
        const target = document.getElementById(targetId);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.boxscore-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.boxscore-pill').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.boxscore-subtab').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const subId = (btn.getAttribute('data-subtab') || '').trim();
        const target = document.getElementById(subId);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.playbyplay-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.playbyplay-pill').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const subTab = btn.getAttribute('data-subtab');
        const showSummary = subTab === 'summary';
        document.getElementById('playTimeline').style.display = showSummary ? 'none' : '';
        const summaryDiv = document.getElementById('scoringSummary');
        if (showSummary) renderScoringSummary();
        summaryDiv.style.display = showSummary ? '' : 'none';
      });
    });
      updateStickyOffsets();
      window.addEventListener('resize', updateStickyOffsets);
      loadGamesList();
      const backBtn = document.getElementById('backButton');
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          stopSpectateMode();
          document.getElementById('gameUI').style.display = 'none';
          document.getElementById('gameList').style.display = 'block';
          const header = document.getElementById('leagueHeader');
          const tabs = document.getElementById('tabContents');
          if (header) header.style.display = '';
          if (tabs) tabs.style.display = '';
          backBtn.style.display = 'none';
          loadGamesList();
        });
      }
      const spectateToggle = document.getElementById('spectateToggle');
      if (spectateToggle) {
        spectateToggle.addEventListener('change', () => {
          if (spectateToggle.checked) {
            startSpectateMode();
          } else {
            stopSpectateMode(false);
          }
        });
      }
      updateSpectateStatus(false);
      document.querySelectorAll('.formation-slot').forEach(slot => {
        slot.addEventListener('dragover', allowDrop);
        slot.addEventListener('drop', handleDrop);
        slot.addEventListener('click', () => moveSelectedTo(slot));
        slot.addEventListener('touchstart', e => { e.preventDefault(); moveSelectedTo(slot); });
      });
      const bench = document.getElementById('bench');
      if (bench) {
        bench.addEventListener('dragover', allowDrop);
        bench.addEventListener('drop', handleDrop);
        bench.addEventListener('click', e => { if (e.target === bench) moveSelectedTo(bench); });
        bench.addEventListener('touchstart', e => { if (e.target === bench) { e.preventDefault(); moveSelectedTo(bench); } });
      }
      const clearBtn = document.getElementById('clearFormation');
      if (clearBtn) clearBtn.addEventListener('click', clearFormation);
      const saveBtn = document.getElementById('saveFormation');
      if (saveBtn) saveBtn.addEventListener('click', saveFormation);
      const openBtn = document.getElementById('openFormation');
      if (openBtn) openBtn.addEventListener('click', () => {
        document.getElementById('formationModal').classList.add('open');
      });
      const closeBtn = document.getElementById('closeFormation');
      if (closeBtn) closeBtn.addEventListener('click', () => {
        document.getElementById('formationModal').classList.remove('open');
      });
      const losBtn = document.getElementById('viewLOS');
      if (losBtn) losBtn.addEventListener('click', () => {
        renderLOS();
        document.getElementById('losModal').classList.add('open');
      });
      const closeLOS = document.getElementById('closeLOS');
      if (closeLOS) closeLOS.addEventListener('click', () => {
        document.getElementById('losModal').classList.remove('open');
      });
      const routeBtn = document.getElementById('openRoutes');
      if (routeBtn) routeBtn.addEventListener('click', () => {
        const modal = document.getElementById('routesModal');
        if (modal) modal.classList.add('open');
        renderRoutesModal();
      });
      const closeRoutes = document.getElementById('closeRoutes');
      if (closeRoutes) closeRoutes.addEventListener('click', () => {
        document.getElementById('routesModal').classList.remove('open');
      });
      const clearRoutesBtn = document.getElementById('clearRoutes');
      if (clearRoutesBtn) clearRoutesBtn.addEventListener('click', clearRoutes);
        const saveRoutesBtn = document.getElementById('saveRoutes');
        if (saveRoutesBtn) saveRoutesBtn.addEventListener('click', () => {
          document.getElementById('routesModal').classList.remove('open');
        });
      const runBtn = document.getElementById('openRun');
      if (runBtn) runBtn.addEventListener('click', openRunModal);
      const closeRun = document.getElementById('closeRun');
      if (closeRun) closeRun.addEventListener('click', closeRunModal);
      const executeRun = document.getElementById('executeRun');
      if (executeRun) executeRun.addEventListener('click', runPlay);
        const togglePanelBtn = document.getElementById('toggleControlPanel');
        if (togglePanelBtn) togglePanelBtn.addEventListener('click', () => {
          const panel = document.getElementById('controlPanel');
          const collapsed = panel.classList.toggle('collapsed');
          togglePanelBtn.textContent = collapsed ? 'Show Control Panel' : 'Hide Control Panel';
        });
      const homeTO = document.getElementById('homeTimeouts');
      if (homeTO) homeTO.addEventListener('click', () => handleTimeout('Home'));
      const awayTO = document.getElementById('awayTimeouts');
      if (awayTO) awayTO.addEventListener('click', () => handleTimeout('Away'));
      updatePassButtonState();
      });

  function loadGamesList() {
    showAppLoading();
    google.script.run
      .withSuccessHandler(games => {
        renderGameCards(games);
        hideAppLoading();
        gamesListLoaded = true;
      })
      .withFailureHandler(err => {
        console.error(err);
        hideAppLoading();
      })
      .getGamesList();
  }

  function renderGameCards(games) {
    const container = document.getElementById('gameList');
    if (!container) return;
    container.innerHTML = '';
    games.forEach(g => {
      const card = document.createElement('div');
      const id = Number(g.GameId);
      const isFinal = g.Qtr === 'FINAL';
      const homeRowClass = g.HomeScore > g.AwayScore ? 'team-row winner' : g.HomeScore < g.AwayScore ? 'team-row loser' : 'team-row';
      const awayRowClass = g.AwayScore > g.HomeScore ? 'team-row winner' : g.AwayScore < g.HomeScore ? 'team-row loser' : 'team-row';
      card.className = 'game-card' + (isFinal ? ' final' : '');

      if (isFinal) {
        card.innerHTML = `
        <div class="${homeRowClass}">
          <img class="team-logo" src="${g.HomeLogo || ''}" alt="Home Logo" />
          <span class="team-name">${g.Home}</span>
          <span class="team-score">${g.HomeScore}</span>
        </div>
        <div class="${awayRowClass}">
          <img class="team-logo" src="${g.AwayLogo || ''}" alt="Away Logo" />
          <span class="team-name">${g.Away}</span>
          <span class="team-score">${g.AwayScore}</span>
        </div>
        `;
      } else {
        const redZone = (g.Possession === 'Home' && g.BallOn >= 80) || (g.Possession === 'Away' && g.BallOn <= 20);
        const downDisplay = formatDownDistance(g.Down, g.Distance, g.BallOn, g.Possession);
        card.innerHTML = `
        <div class="${homeRowClass}">
          <img class="team-logo" src="${g.HomeLogo || ''}" alt="Home Logo" />
          <div class="team-name-wrap">
            <span class="team-name">${g.Home}</span>
              <span class="poss-indicator">${g.Possession === 'Home' ? '\uD83C\uDFC8' : ''}</span>
          </div>
          <span class="team-score">${g.HomeScore}</span>
          <span class="team-time">${formatClock(parseTimeToSeconds(g.Time))}</span>
          <span class="team-down${redZone ? ' red-zone' : ''}">${downDisplay}</span>
        </div>
        <div class="${awayRowClass}">
          <img class="team-logo" src="${g.AwayLogo || ''}" alt="Away Logo" />
          <div class="team-name-wrap">
            <span class="team-name">${g.Away}</span>
              <span class="poss-indicator">${g.Possession === 'Away' ? '\uD83C\uDFC8' : ''}</span>
          </div>
          <span class="team-score">${g.AwayScore}</span>
          <span class="team-qtr">${formatQuarter(g.Qtr)}</span>
          <span class="team-ball">${formatBallOnForPoss(g.BallOn, g.Possession)}</span>
        </div>
        `;
      }
      card.addEventListener('click', () => {
        gameId = id;
        document.getElementById('gameList').style.display = 'none';
        const header = document.getElementById('leagueHeader');
        const tabs = document.getElementById('tabContents');
        if (header) header.style.display = 'none';
        if (tabs) tabs.style.display = 'none';
        showLoadingScreen(g.HomeLogo, g.AwayLogo);
        refreshUI(id).then(() => {
          hideLoadingScreen();
          document.getElementById('gameUI').style.display = 'block';
          const backBtn = document.getElementById('backButton');
          if (backBtn) backBtn.style.display = 'block';
          updateStickyOffsets();
        }).catch(err => {
          console.error(err);
          hideLoadingScreen();
        });
      });
    container.appendChild(card);
  });
  }

  function updateSpectateStatus(active) {
    const statusEl = document.getElementById('spectateStatus');
    if (!statusEl) return;
    statusEl.textContent = active ? 'LIVE REFRESH' : 'OFF';
    statusEl.classList.toggle('live', !!active);
  }

  function applySpectateRestrictions() {
    document.body.classList.add('spectate-mode');
    disablePlayControls();
    const panel = document.getElementById('controlPanel');
    if (panel && !panel.classList.contains('collapsed')) {
      panel.classList.add('collapsed');
    }
    const togglePanelBtn = document.getElementById('toggleControlPanel');
    if (togglePanelBtn) {
      togglePanelBtn.textContent = 'Show Control Panel';
    }
  }

  function removeSpectateRestrictions() {
    document.body.classList.remove('spectate-mode');
  }

  function restartSpectatePolling(immediate = false) {
    if (spectateInterval) {
      clearInterval(spectateInterval);
    }
    if (!spectateMode) return;
    spectateInterval = setInterval(() => fetchSpectateUpdate(true), SPECTATE_REFRESH_MS);
    if (immediate) {
      fetchSpectateUpdate(true);
    }
  }

  function startSpectateMode() {
    const toggle = document.getElementById('spectateToggle');
    if (toggle && !toggle.checked) {
      toggle.checked = true;
    }
    spectateMode = true;
    applySpectateRestrictions();
    lastSpectateKey = getLatestPlayKey(playHistory);
    updateSpectateStatus(true);
    restartSpectatePolling(true);
  }

  function stopSpectateMode(updateToggle = true) {
    if (spectateInterval) {
      clearInterval(spectateInterval);
      spectateInterval = null;
    }
    spectateMode = false;
    removeSpectateRestrictions();
    enablePlayControls();
    if (updateToggle) {
      const toggle = document.getElementById('spectateToggle');
      if (toggle) toggle.checked = false;
    }
    updateSpectateStatus(false);
    lastSpectateKey = getLatestPlayKey(playHistory);
  }

  function fetchSpectateUpdate(animateIfChanged = false) {
    if (!spectateMode) return;
    const currentGameId = gameId;
    google.script.run
      .withSuccessHandler(gameState => {
        if (!spectateMode) return;
        google.script.run
          .withSuccessHandler(history => {
            if (!spectateMode) return;
            Promise.resolve(handleSpectateData(gameState, history, animateIfChanged))
              .catch(err => console.error('❌ Spectate sync failed:', err));
          })
          .withFailureHandler(err => {
            console.error('❌ Failed to refresh play history:', err);
          })
          .getPlayHistory(currentGameId);
      })
      .withFailureHandler(err => {
        console.error('❌ Failed to refresh game state:', err);
      })
      .getGameState(currentGameId);
  }

  async function handleSpectateData(gameState, history, animateIfChanged) {
    if (!spectateMode) return;
    const remoteHistory = Array.isArray(history) ? history : [];
    const newKey = getLatestPlayKey(remoteHistory);
    const shouldAnimate = animateIfChanged && newKey && newKey !== lastSpectateKey;
    const lastPlay = remoteHistory.length ? remoteHistory[remoteHistory.length - 1] : null;
    const mergedState = { ...state, ...gameState };
    mergedState.Time = parseTimeToSeconds(mergedState.Time);
    if (lastPlay) {
      if (lastPlay.BallOn !== undefined && lastPlay.BallOn !== null) {
        mergedState.Previous = Number(lastPlay.BallOn);
      }
      if (lastPlay.DriveStart !== undefined && lastPlay.DriveStart !== null) {
        mergedState.DriveStart = Number(lastPlay.DriveStart);
      }
    }
    state = mergedState;
    updateStateUI();
    const latestKey = await processLoadedPlayHistory(remoteHistory, { animateLatest: shouldAnimate });
    lastSpectateKey = latestKey;
  }

  function getLatestPlayKey(history) {
    if (!Array.isArray(history) || history.length === 0) return null;
    const last = history[history.length - 1];
    const quarter = last.Qtr ?? last.QTR ?? '';
    const time = last.Time ?? last.time ?? '';
    const result = last.Result ?? last.Description ?? '';
    const poss = last.Possession ?? '';
    const playType = last.PlayType ?? '';
    const score = `${last.HomeScore ?? ''}-${last.AwayScore ?? ''}`;
    return `${quarter}|${time}|${poss}|${playType}|${result}|${score}`;
  }

  function toggleMenu() {
    document.getElementById('playerMenu').classList.toggle('open');
  }

  function renderPlayerCards() {
    const menu = document.getElementById('playerMenu');
    if (!menu) return;
    menu.innerHTML = '';
    Object.values(playerTraits).forEach(p => {
      const card = document.createElement('div');
        card.className = 'player-card';
        card.innerHTML = `
              <h4>${p.name}</h4>
              <div>Size: ${p.size}</div>
              <div>Strength: ${p.strength}</div>
              <div>Speed: ${p.speed}</div>
              <div>Stamina: ${p.stamina}</div>
              <div>Run Blocking: ${p.runBlocking}</div>
              <div>Pass Protect: ${p.passProtect}</div>
              <div>Run Stop: ${p.runStop}</div>
              <div>Tackling: ${p.tackling}</div>
            `;
        menu.appendChild(card);
      });
    }

  // === GAME SETUP ===
  function refreshUI(selectedGameId) {
    return new Promise((resolve, reject) => {
    state = {};
    players = [];
    playerTraits = {};
    rollThresholds = [];
    breakawaySettings = [];
    drainSettings = {};  // Populated from backend on load
    frontendStats = [];
    defensiveStats = [];
    passingStats = [];
    receivingStats = [];
    playHistory = [];
    if (typeof selectedGameId !== 'undefined') {
      gameId = selectedGameId;
    }
    google.script.run.withSuccessHandler(function (gameState) {
      console.log("✅ Loaded game state");
      if (!gameState) {
        console.error(`❌ No game state returned for game ${gameId}`);
        reject(new Error('No game state'));
        return;
      }
      state = gameState;
      state.Time = parseTimeToSeconds(state.Time);
      runningClock = false;
      updateStateUI();

      loadPlayersTraits(function () {
        loadSettings(function () {
          google.script.run
            .withSuccessHandler(async function (data) {
              console.log("✅ Loaded play history", data);
              try {
                const latestKey = await processLoadedPlayHistory(data, { animateLatest: true });
                lastSpectateKey = latestKey;
                if (spectateMode) {
                  applySpectateRestrictions();
                  restartSpectatePolling(false);
                  updateSpectateStatus(true);
                } else {
                  updateSpectateStatus(false);
                }
                resolve();
              } catch (err) {
                console.error('❌ Failed to process play history:', err);
                reject(err);
              }
            })
            .getPlayHistory(gameId);
        });
      });
    }).withFailureHandler(function (error) {
      console.error("❌ Failed to load game state:", error.message);
      reject(error);
    }).getGameState(gameId);
  });

  }


  async function processLoadedPlayHistory(data, options = {}) {
    const { animateLatest = false } = options;
    playHistory = Array.isArray(data) ? data : [];
    if (playHistory.length) {
      const last = playHistory[playHistory.length - 1];
      updateRunningClock(last.Result);
    }
    if (!state.StartingPossession && playHistory.length) {
      const first = playHistory[0];
      state.StartingPossession = first ? first.Possession : state.Possession;
    }
    normalizeBallOn(playHistory);
    recalculateStatsFromHistory();
    renderPlayTimeline();
    applyFatigueFromPlayHistory();
    renderBoxScore();
    renderTeamStats();
    computeDriveInfo();
    updateLastPlayDesc();
    renderScoringSummary();
    renderQuarterScoreChart();
    const latestPlay = playHistory.length ? playHistory[playHistory.length - 1] : null;
    if (animateLatest && latestPlay) {
      if (latestPlay.BallOn !== undefined && latestPlay.BallOn !== null) {
        state.Previous = Number(latestPlay.BallOn);
      }
      if (latestPlay.DriveStart !== undefined && latestPlay.DriveStart !== null) {
        state.DriveStart = Number(latestPlay.DriveStart);
      }
      await animateLatestPlay(latestPlay);
    }
    return getLatestPlayKey(playHistory);
  }

  function recalculateStatsFromHistory() {
    frontendStats = [];
    defensiveStats = [];
    passingStats = [];
    receivingStats = [];

    playHistory.forEach(play => {
      const team = play.Possession || '';
      const defTeam = team === 'Home' ? 'Away' : 'Home';
      const yards = parseFloat(play.Yards) || 0;
      const result = (play.Result || '').trim();
      const defenseResult = (play.DefenseResult || '').trim();
      const tackler = play.Tackler && play.Tackler !== 'NA' ? play.Tackler : '';
      const recoveredBy = play.RecoveredBy || play.recoveredby;

      const getDefenderStats = (playername, playerTeam) => {
        if (!playername) return null;
        let entry = defensiveStats.find(s => s.playername === playername && s.team === playerTeam);
        if (!entry) {
          entry = { playername, team: playerTeam, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0, sacks: 0 };
          defensiveStats.push(entry);
        }
        return entry;
      };

      if (result === 'Sack') {
        const qb = play.Passer || play.Player || '';
        if (qb) {
          let ps = passingStats.find(s => s.playername === qb && s.team === team);
          if (!ps) {
            ps = { playername: qb, team, attempts: 0, completions: 0, yards: 0, tds: 0, ints: 0, sacks: 0, sackYds: 0};
            passingStats.push(ps);
          }
          ps.sacks = (ps.sacks || 0) + 1;
          ps.sackYds = (ps.sackYds || 0) + yards;
        }
        if (recoveredBy && qb) {
          let p = frontendStats.find(s => s.playername === qb && s.team === team);
          if (!p) {
            p = { playername: qb, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
            frontendStats.push(p);
          }
          p.fumbles = (p.fumbles || 0) + 1;
        }
      }

      if (!play.PlayType && result !== 'Sack') return;

      if (play.PlayType === 'Run') {
        if (!play.Player) return;
        const player = play.Player;
        const td = result === 'Touchdown';
        const fumble = result === 'Fumble';

        let p = frontendStats.find(s => s.playername === player && s.team === team);
        if (!p) {
          p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
          frontendStats.push(p);
        }
        p.carries++;
        p.yards += yards;
        if (td) p.tds++;
        if (fumble) p.fumbles++;
        if (yards > p.long) p.long = yards;
      } else if (play.PlayType === 'Pass') {
        const qb = play.Passer || play.Player || '';
        const receiver = play.Target || play.Receiver || '';
        const completed = result !== 'Incomplete' && result !== 'Interception';
        const intercepted = result === 'Interception';
        const td = result === 'Touchdown';
        const fumble = result === 'Fumble';
        if (qb) {
          let ps = passingStats.find(s => s.playername === qb && s.team === team);
          if (!ps) {
            ps = { playername: qb, team, attempts: 0, completions: 0, yards: 0, tds: 0, ints: 0, sacks: 0, sackYds: 0};
            passingStats.push(ps);
          }
          ps.attempts++;
          if (completed) {
            ps.completions++;
            ps.yards += yards;
            if (td) ps.tds++;
          }
          if (intercepted) ps.ints++;
        }
        if (receiver) {
          let rs = receivingStats.find(s => s.playername === receiver && s.team === team);
          if (!rs) {
            rs = { playername: receiver, team, targets: 0, receptions: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
            receivingStats.push(rs);
          }
          rs.targets++;
          if (completed) {
            rs.receptions++;
            rs.yards += yards;
            if (td) rs.tds++;
            if (yards > rs.long) rs.long = yards;
          }
          if (fumble) rs.fumbles++;
        }
        if (intercepted) {
          const defender = play.RecoveredBy || play.recoveredby || play.Interceptor || play.Tackler;
          if (defender) {
            const defenderStats = getDefenderStats(defender, defTeam);
            if (defenderStats) {
              defenderStats.ints = (defenderStats.ints || 0) + 1;
            }
          }
        }
      }
      if (tackler) {
        const defenderStats = getDefenderStats(tackler, defTeam);
        if (defenderStats) {
          if (['TKL', 'TFL', 'Sack'].includes(defenseResult)) {
            defenderStats.tackles = (defenderStats.tackles || 0) + 1;
          }
          if (['TFL', 'Sack'].includes(defenseResult)) {
            defenderStats.tfl = (defenderStats.tfl || 0) + 1;
          }
          if (defenseResult === 'Sack') {
            defenderStats.sacks = (defenderStats.sacks || 0) + 1;
          }
          if (defenseResult === 'Deflected') {
            defenderStats.deflections = (defenderStats.deflections || 0) + 1;
          }
          if (result === 'Fumble') {
            defenderStats.ff = (defenderStats.ff || 0) + 1;
          }
        }
      }

      if (result === 'Fumble' && recoveredBy) {
        const turnoverValue = typeof play.Turnover === 'string'
          ? play.Turnover.trim().toLowerCase()
          : play.Turnover;
        const isTurnover = turnoverValue === true || turnoverValue === 'yes' || turnoverValue === 'true';
        if (isTurnover) {
          const recTeam = playerTraits[recoveredBy]?.team || defTeam;
          const defenderStats = getDefenderStats(recoveredBy, recTeam);
          if (defenderStats) {
            defenderStats.fr = (defenderStats.fr || 0) + 1;
          }
        }
      }
    });
  }

  async function animateLatestPlay(play) {
    if (!play) return;
    let playType = play.PlayType || '';
    if (!playType) {
      playType = play.Receiver || play.Target ? 'Pass' : 'Run';
    }
    playType = playType === 'Pass' ? 'Pass' : playType === 'Run' ? 'Run' : playType;
    if (playType !== 'Pass' && playType !== 'Run') return;
    const resultText = (play.Result || '').toLowerCase();
    const passResult = {
      completed: playType === 'Pass' && !['incomplete', 'interception', 'sack'].includes(resultText),
      intercepted: resultText === 'interception',
      touchdown: resultText === 'touchdown',
      sack: resultText === 'sack'
    };
    await animatePlay(playType, passResult);
  }

  function applyFatigueFromPlayHistory() {
    if (!playerTraits || !drainSettings) return;

    Object.values(playerTraits).forEach(pt => {
      pt.fatigue = pt.stamina;
    });

    playHistory.forEach(play => {
      if (play.PlayType === 'Run') {
        const runner = play.Player;
        if (runner && playerTraits[runner]) {
          applyFatigue(runner, 'Run');
        }
      } else if (play.PlayType === 'Pass') {
        const qb = play.Passer || play.Player;
        if (qb && playerTraits[qb]) {
          if (play.Result === 'Sack') {
            applyFatigue(qb, 'Sacked');
          } else {
            applyFatigue(qb, 'Throw');
          }
        }

        const receiver = play.Receiver || play.Target;
        const completed = receiver && play.Result && play.Result !== 'Incomplete' && play.Result !== 'Interception';
        if (completed && playerTraits[receiver]) {
          applyFatigue(receiver, 'Rec');
          applyFatigue(receiver, 'Route');
        }
      }
    });
  }
  async function animatePlay(playType, passResult = {}) { 
    // use current game state to drive the animation in the proper direction
    await show3DDrive(state.DriveStart, state.Previous, state.BallOn, playType = playType, passResult); //CHANGE - dont hardcode run and pass
  }

  function formatBallOn(yard) {
    yard = parseInt(yard, 10);
    // Convert field position to the perspective of the team with the ball
    const perspectiveYard = state.Possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatBallOnForPoss(yard, possession) {
    yard = parseInt(yard, 10);
    const perspectiveYard = possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatDownDistance(down, distance, ballOn = state.BallOn, possession = state.Possession) {
    const ord = ["1st", "2nd", "3rd", "4th"];
    const d = ord[down - 1] || down + "th";
    const yardsToGoal = possession === "Home" ? 100 - Number(ballOn) : Number(ballOn);
    const dist = Number(distance);
    const distText = dist >= yardsToGoal ? "Goal" : dist;
    return `${d} & ${distText}`;
  }

  function formatQuarter(qtr) {
    if (qtr === 'FINAL') return 'FINAL';
    const ord = ["1st", "2nd", "3rd", "4th", "OT"];
    return ord[qtr - 1] || qtr + "th";
  }

  function parseTimeToSeconds(t) {
    if (typeof t === 'number') return t;
    if (typeof t === 'string') {
      if (t.includes(':')) {
        const [m, s] = t.split(':').map(Number);
        return m * 60 + s;
      }
      const num = Number(t);
      if (!isNaN(num)) return num;
    }
    return 0;
  }

  function formatClock(seconds) {
    const sec = Math.max(0, Math.floor(Number(seconds)));
    const m = Math.floor(sec / 60);
    const s = String(sec % 60).padStart(2, '0');
    return `${m}:${s}`;
  }

  function computeDriveInfo() {
    let plays = 0;
    for (let i = playHistory.length - 1; i >= 0; i--) {
      const play = playHistory[i];
      if (play.Possession !== state.Possession) break;
      plays++;
    }
    const yards = state.Possession === "Home"
      ? state.BallOn - state.DriveStart
      : state.DriveStart - state.BallOn;
    //return { plays, yards: Math.max(0, yards) };
    document.getElementById("driveInfo").innerText = `${plays} plays, ${yards} yards`;
  }

  function updateTimeoutDots(id, count) {
    const container = document.getElementById(id);
    if (!container) return;
    const dots = Array.from(container.children);
    dots.forEach((dot, idx) => {
      dot.classList.toggle('used', idx >= count);
    });
  }

  const PLAY_BUTTON_IDS = ['passPlayButton','openRun','executeRun','kickButton','puntButton','twoPtButton'];
  const TIMEOUT_IDS = ['homeTimeouts','awayTimeouts'];

  function disablePlayControls() {
    PLAY_BUTTON_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.disabled = true;
        el.classList.add('disabled-play-control');
      }
    });
    TIMEOUT_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.pointerEvents = 'none';
        el.classList.add('disabled-play-control');
      }
    });
  }

  function enablePlayControls() {
    PLAY_BUTTON_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.disabled = false;
        el.classList.remove('disabled-play-control');
      }
    });
    TIMEOUT_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.pointerEvents = '';
        el.classList.remove('disabled-play-control');
      }
    });
  }

  function savePlayAndGameWithRetry(data) {
    disablePlayControls();
    return new Promise(resolve => {
      let settled = false;
      const timer = setTimeout(() => {
        if (!settled) {
          settled = true;
          setTimeout(() => {
            savePlayAndGameWithRetry(data).then(resolve);
          }, 1000);
        }
      }, 5000);

      google.script.run
        .withSuccessHandler(() => {
          if (!settled) {
            settled = true;
            clearTimeout(timer);
            enablePlayControls();
            resolve();
          }
        })
        .withFailureHandler(() => {
          if (!settled) {
            settled = true;
            clearTimeout(timer);
            setTimeout(() => {
              savePlayAndGameWithRetry(data).then(resolve);
            }, 1000);
          }
        })
        .savePlayAndGame(data);
    });
  }

  function handleTimeout(team) {
    const key = team === 'Home' ? 'HomeTimeouts' : 'AwayTimeouts';
    if (!state[key] || state[key] <= 0) return;
    disablePlayControls();
    state[key]--;
    updateStateUI();
    updateRunningClock('Timeout');

    const play = {
      gameid: gameId,
      time: state.Time,
      qtr: state.Qtr,
      possession: state.Possession,
      down: state.Down,
      distance: state.Distance,
      ballon: state.BallOn,
      playtype: 'Timeout',
      player: team,
      yards: 0,
      result: 'Timeout',
      newdown: state.Down,
      newdist: state.Distance,
      newballon: state.BallOn,
      drivestart: state.DriveStart,
      homescore: state.HomeScore,
      awayscore: state.AwayScore
    };

    const gameData = {
      gameId: gameId,
      quarter: state.Qtr,
      time: state.Time,
      down: state.Down,
      distance: state.Distance,
      ballOn: state.BallOn,
      homeScore: state.HomeScore,
      awayScore: state.AwayScore,
      driveStart: state.DriveStart,
      previous: state.Previous,
      possession: state.Possession,
      homeTimeouts: state.HomeTimeouts,
      awayTimeouts: state.AwayTimeouts
    };

    playHistory.push({
      GameId: gameId,
      Time: state.Time,
      QTR: state.Qtr,
      Possession: state.Possession,
      Down: state.Down,
      Distance: state.Distance,
      BallOn: state.BallOn,
      PlayType: 'Timeout',
      Player: team,
      Yards: 0,
      Result: 'Timeout',
      NewDown: state.Down,
      NewDist: state.Distance,
      NewBallOn: state.BallOn,
      DriveStart: state.DriveStart,
      HomeScore: state.HomeScore,
      AwayScore: state.AwayScore
    });
    renderPlayTimeline();
    savePlayAndGameWithRetry({ play, game: gameData });
  }

  function buildPlayText(play) {
    if (play.Result === 'Timeout') {
      return `${play.Player} Timeout`;
    }
    if (play.PlayType === 'Kick FG') {
      return 'Field Goal is Good!';
    }
    if (play.PlayType === 'Kick XP') {
      return 'Extra Point is Good!';
    }
    if (play.PlayType === '2PT') {
      const success = (play.Result || '').toLowerCase().includes('successful');
      if (play.Receiver && play.Receiver !== '') {
        if (success) {
          return `${play.Player} ${play.Yards} yard pass to ${play.Receiver}. 2-point conversion is SUCCESSFUL!`;
        }
        return `${play.Player} pass incomplete intended for ${play.Receiver}. 2-point conversion FAILS!`;
      } else {
        if (success) {
          return `${play.Player} runs for ${play.Yards} yards. 2-point conversion is SUCCESSFUL!`;
        }
        return `${play.Player} run fails. 2-point conversion FAILS!`;
      }
    }
      if (play.Result === 'Sack') {
        const qb = play.Player || '';
        const spot = formatBallOnForPoss(play.NewBallOn, play.Possession);
        const loss = Math.abs(play.Yards);
        let text = `${qb} sacked at the ${spot} for a loss of ${loss}`;
        if (play.Tackler && play.Tackler !== 'NA') {
          text += ` (${play.Tackler})`;
        }
        text += '.';
        if (play.RecoveredBy) {
          const recoveryPoss = play.RecoveredBy === qb ? play.Possession : (play.Possession === 'Home' ? 'Away' : 'Home');
          text += ` FUMBLE! Recovered by ${play.RecoveredBy} at the ${formatBallOnForPoss(play.NewBallOn, recoveryPoss)}.`;
        }
        return text;
      }
      if (play.Result === 'Safety' && play.PlayType === 'Pass' && (!play.Receiver || play.Receiver === '')) {
        const qb = play.Player || '';
        let text = `${qb} sacked in the end zone for a safety`;
        if (play.Tackler && play.Tackler !== 'NA') {
          text += ` (${play.Tackler})`;
        }
        text += '.';
        return text;
      }
    if (play.PlayType === 'Pass') {
      const qb = play.Player || '';
      const receiver = play.Receiver || '';
      const yards = play.Yards;
      const tackler = play.Tackler;
      const resultLower = (play.Result || '').toLowerCase();
      const isTouchdown = resultLower.includes('touchdown');
      let text = '';
      if (play.Result === 'Interception') {
        const poss = play.Possession === 'Home' ? 'Away' : 'Home';
        const spot = formatBallOnForPoss(play.NewBallOn, poss);
        const interceptor = play.RecoveredBy || play.recoveredby || tackler || '';
        text = `${qb} pass intended for ${receiver}. Intercepted at the ${spot} by ${interceptor}.`;
      } else if (play.Result === 'Incomplete') {
        text = `${qb} pass intended for ${receiver}. Incomplete.`;
      } else {
        text = `${qb} pass to ${receiver}`;
        if (!isTouchdown) {
          const spot = formatBallOnForPoss(play.NewBallOn, play.Possession);
          text += ` to ${spot}`;
        }
        text += ` for ${yards} yards`;
        if (!isTouchdown && tackler && tackler !== 'NA') {
          text += ` (${tackler})`;
        }
        text += '.';
      }
      if (play.Result && !['Normal','Fumble','Interception','Incomplete'].includes(play.Result)) {
        if (isTouchdown) {
          text += ` <span style="color:green; font-weight:bold;">Touchdown!</span>`;
        } else if (play.Result === 'TO on Downs') {
          text += ` <span style="color:red; font-weight:bold;">${play.Result}!</span>`;
        } else {
          text += ` <strong>${play.Result}!</strong>`;
        }
      }
      if (play.Result === 'Fumble' && play.RecoveredBy) {
        const recoveryPoss = play.RecoveredBy === receiver ? play.Possession : (play.Possession === 'Home' ? 'Away' : 'Home');
        text += ` FUMBLE! Recovered by ${play.RecoveredBy} at the ${formatBallOnForPoss(play.NewBallOn, recoveryPoss)}.`;
      }
      if (play.afterTdPlay) {
        const after = play.afterTdPlay;
        if (after.PlayType === 'Kick XP') {
          text += ' XP is GOOD!';
        } else if (after.PlayType === '2PT') {
          text += ' ' + buildPlayText(after);
        }
      }
      return text;
    } else {
      let text = `<strong>${play.Player}</strong> runs for ${play.Yards} Yards.`;

      if (play.Result && play.Result !== "Normal" && play.Result !== "Fumble") {
        if (play.Result === "Touchdown") {
          text += ` <span style="color:green; font-weight:bold;">${play.Result}!</span>`;
        } else if (play.Result === "TO on Downs") {
          text += ` <span style="color:red; font-weight:bold;">${play.Result}!</span>`;
        } else {
          text += ` <strong>${play.Result}!</strong>`;
        }
      }

      if (play.Result !== "Touchdown" && play.Tackler && play.Tackler !== "NA") {
          text += ` Tackle made at the ${formatBallOnForPoss(play.NewBallOn, play.Possession)} by ${play.Tackler}.`;
      }

      if (play.Result === "Fumble" && play.RecoveredBy) {
        const recoveryPoss = play.RecoveredBy === play.Player ? play.Possession : (play.Possession === "Home" ? "Away" : "Home");
        text += ` FUMBLE! Recovered by ${play.RecoveredBy} at the ${formatBallOnForPoss(play.NewBallOn, recoveryPoss)}.`;
      }

      if (play.afterTdPlay) {
        const after = play.afterTdPlay;
        if (after.PlayType === 'Kick XP') {
          text += ' XP is GOOD!';
        } else if (after.PlayType === '2PT') {
          text += ' ' + buildPlayText(after);
        }
      }

      return text;
    }
  }

  function normalizeBallOn(history) {
    let prevBall = null;
    let prevDrive = null;
    let prevPoss = null;
    history.forEach(play => {
      if (prevDrive === null || play.DriveStart !== prevDrive || play.Possession !== prevPoss) {
        prevBall = Number(play.DriveStart);
        prevDrive = play.DriveStart;
        prevPoss = play.Possession;
      }
      play.BallOn = Number(prevBall);
      if (play.NewBallOn !== undefined && play.NewBallOn !== "") {
        prevBall = Number(play.NewBallOn);
      }
    });
  }

  function groupPlaysByDrive(plays) {
    const drives = [];
    let current = null;
    plays.forEach(play => {
      // Only include offensive plays (runs or passes) in the drive breakdown
      if (!play.Player || (play.PlayType && !['Run', 'Pass'].includes(play.PlayType))) return;
      const key = play.Possession + '-' + play.DriveStart;
      if (!current || current.key !== key) {
        current = { key, possession: play.Possession, driveStart: Number(play.DriveStart), plays: [] };
        drives.push(current);
      }
      current.plays.push(play);
    });
    drives.forEach(drive => {
      const last = drive.plays[drive.plays.length - 1];
      drive.result = (last.Result === 'Sack' && last.RecoveredBy) ? 'Fumble' : (last.Result || '');
      drive.homeScore = last.HomeScore !== undefined ? last.HomeScore : state.HomeScore;
      drive.awayScore = last.AwayScore !== undefined ? last.AwayScore : state.AwayScore;
      const end = Number(last.NewBallOn);
      drive.yards = drive.possession === 'Home' ? end - drive.driveStart : drive.driveStart - end;
      drive.playsCount = drive.plays.length;
    });
    return drives;
  }

  function updateLastPlayDesc() {
    const el = document.getElementById('lastPlayDesc');
    if (!el) return;
    if (playHistory.length === 0) {
      el.innerHTML = '';
      return;
    }
    let lastPlay = playHistory[playHistory.length - 1];
    if (lastPlay && (lastPlay.PlayType === 'Kick XP' || lastPlay.PlayType === '2PT')) {
      lastPlay = playHistory[playHistory.length - 2];
    }
    const text = buildPlayText(lastPlay);
    el.innerHTML = `<strong>Last Play:</strong> ${text}`;
  }

  function renderPlayTimeline() {
    const container = document.getElementById("playTimeline");
    if (!container) return;
    container.innerHTML = "";
    const drives = groupPlaysByDrive(playHistory);
    drives.forEach(drive => {
      const section = document.createElement('div');
      section.className = 'drive-section';

      const header = document.createElement('div');
      header.className = 'drive-header';

      const toggle = document.createElement('div');
      toggle.className = 'drive-toggle';
      toggle.textContent = '^';

      const logo = document.createElement('img');
      logo.className = 'drive-logo';
      logo.src = drive.possession === 'Home' ? (state.HomeLogo || '') : (state.AwayLogo || '');

      /**const info = document.createElement('div');
      const resultDiv = document.createElement('span');
      resultDiv.className = 'drive-result';
      resultDiv.textContent = drive.result;
      const summaryDiv = document.createElement('span');
      summaryDiv.className = 'drive-summary';
      summaryDiv.textContent = `${drive.playsCount} Plays, ${drive.yards} Yards`;
      info.appendChild(resultDiv);
      info.appendChild(summaryDiv);**/
      
      const info = document.createElement('div');
      info.className = 'drive-overview';
      const resultDiv = document.createElement('span');
      resultDiv.className = 'drive-result';
      resultDiv.textContent = drive.result;
      const summaryDiv = document.createElement('span');
      summaryDiv.className = 'drive-summary';
      summaryDiv.textContent = `${drive.playsCount} Plays, ${drive.yards} Yards`;
      info.appendChild(resultDiv);
      info.appendChild(summaryDiv);

      const scoreDiv = document.createElement('div');
      scoreDiv.className = 'drive-score';
      scoreDiv.innerHTML = `<div><span class="team-name">${state.Home}</span> <span class="score-value">${drive.homeScore}</span></div><div><span class="team-name">${state.Away}</span> <span class="score-value">${drive.awayScore}</span></div>`;

      header.appendChild(toggle);
      header.appendChild(logo);
      header.appendChild(info);
      header.appendChild(scoreDiv);
      section.appendChild(header);

      const playsDiv = document.createElement('div');
      playsDiv.className = 'drive-plays';
      drive.plays.forEach(play => {
        const playRow = document.createElement('div');
        playRow.className = 'play-row';
        const sitDiv = document.createElement('div');
        sitDiv.className = 'play-situation';
        const downDist = formatDownDistance(play.Down, play.Distance, play.BallOn, play.Possession);
        const spot = formatBallOnForPoss(play.BallOn, play.Possession);
        sitDiv.innerHTML = `${downDist} at ${spot}`;
        const descDiv = document.createElement('div');
        descDiv.className = 'play-desc';
        const time = formatClock(play.Time);
        const playQuarter = play.QTR ?? play.Qtr ?? state.Qtr;
        const qtr = formatQuarter(playQuarter);
        const text = buildPlayText(play);
        descDiv.innerHTML = `(${time} - ${qtr}) ${text}`;
        playRow.appendChild(sitDiv);
        playRow.appendChild(descDiv);
        playsDiv.appendChild(playRow);
      });
      section.appendChild(playsDiv);

      function toggleSection() {
        const collapsed = playsDiv.classList.toggle('collapsed');
        toggle.textContent = collapsed ? 'v' : '^';
      }
      header.addEventListener('click', toggleSection);
      toggle.addEventListener('click', function(e) { e.stopPropagation(); toggleSection(); });

      container.appendChild(section);
    });
    computeDriveInfo();
    updateLastPlayDesc();
    renderScoringSummary();
    renderQuarterScoreChart();
  }

  function renderScoringSummary() {
    const container = document.getElementById('scoringSummary');
    if (!container) return;
    container.innerHTML = '';
    const scoringPlays = playHistory.filter(p => ['Touchdown', 'Field Goal', 'Safety'].includes(p.Result));
    const byQuarter = {};
    scoringPlays.forEach(p => {
      const q = p.QTR ?? p.Qtr ?? state.Qtr;
      if (!byQuarter[q]) byQuarter[q] = [];
      byQuarter[q].push(p);
    });
    Object.keys(byQuarter).sort((a,b) => a - b).forEach(q => {
      const qLabel = formatQuarter(q).toUpperCase();
      const qText = qLabel === 'OT' ? 'OVERTIME' : `${qLabel} QUARTER`;
      const header = document.createElement('div');
      header.className = 'summary-quarter';
      header.innerHTML = `<div class="quarter-label">${qText}</div><div class="summary-home-scorehead">${state.Home}</div><div class="summary-away-scorehead">${state.Away}</div>`;
      container.appendChild(header);
      const line = document.createElement('div');
      line.className = 'summary-line';
      container.appendChild(line);
      let idx = 0;
      byQuarter[q].forEach(play => {
        const row = document.createElement('div');
        row.className = 'summary-play' + (idx % 2 ? ' alt' : '');
        const logo = document.createElement('img');
        logo.className = 'summary-logo';
        logo.src = play.Possession === 'Home' ? (state.HomeLogo || '') : (state.AwayLogo || '');
        const resultDiv = document.createElement('div');
        resultDiv.className = 'summary-result-time';
        const map = { 'Touchdown':'TD', 'Field Goal':'FG', 'Safety':'Safety' };
        const time = formatClock(play.Time);
        resultDiv.textContent = `${map[play.Result] || play.Result} ${time}`;
        const homeScore = document.createElement('div');
        homeScore.className = 'summary-home-score';
        homeScore.textContent = play.HomeScore;
        const awayScore = document.createElement('div');
        awayScore.className = 'summary-away-score';
        awayScore.textContent = play.AwayScore;
        const desc = document.createElement('div');
        desc.className = 'summary-description';
        desc.innerHTML = buildPlayText(play);
        row.appendChild(logo);
        row.appendChild(resultDiv);
        row.appendChild(homeScore);
        row.appendChild(awayScore);
        row.appendChild(desc);
        container.appendChild(row);
        idx++;
      });
    });
  }

  function getQuarterScores() {
    const home = [0, 0, 0, 0];
    const away = [0, 0, 0, 0];
    let prevHome = 0;
    let prevAway = 0;
    playHistory.forEach(play => {
      const q = parseInt(play.QTR ?? play.Qtr, 10);
      let h = play.HomeScore !== undefined ? parseInt(play.HomeScore, 10) : prevHome;
      let a = play.AwayScore !== undefined ? parseInt(play.AwayScore, 10) : prevAway;
      if (isNaN(h)) h = prevHome;
      if (isNaN(a)) a = prevAway;
      if (q >= 1 && q <= 4) {
        home[q - 1] += h - prevHome;
        away[q - 1] += a - prevAway;
      }
      prevHome = h;
      prevAway = a;
    });
    return { home, away };
  }

  function renderQuarterScoreChart() {
    const container = document.getElementById('scoreChart');
    if (!container) return;
    const { home, away } = getQuarterScores();
    container.innerHTML = `
      <table>
        <thead>
          <tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>T</th></tr>
        </thead>
        <tbody>
          <tr>
            <td class="team-cell"><img src="${state.HomeLogo || ''}" alt="Home Logo" class="team-logo-small"><span>${state.Home}</span></td>
            <td>${home[0]}</td><td>${home[1]}</td><td>${home[2]}</td><td>${home[3]}</td>
            <td class="total-cell">${state.HomeScore}</td>
          </tr>
          <tr>
            <td class="team-cell"><img src="${state.AwayLogo || ''}" alt="Away Logo" class="team-logo-small"><span>${state.Away}</span></td>
            <td>${away[0]}</td><td>${away[1]}</td><td>${away[2]}</td><td>${away[3]}</td>
            <td class="total-cell">${state.AwayScore}</td>
          </tr>
        </tbody>
      </table>`;
  }

  function renderGameLeaders() {
    const container = document.getElementById('leadersCard');
    if (!container) return;

    const homeTeam = state.Home || '';
    const awayTeam = state.Away || '';
    const emptyPfp = '<div class="player-placeholder"><span>👤</span></div>';

    function playerImage(player){
      const name = player ? player.playername : '';
      const trait = name && playerTraits[name];
      const img = trait && trait.image;
      if (!img) return emptyPfp;
      return `<div class="player-placeholder"><img src="${img}" class="player-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"><span style="display:none;">👤</span></div>`;
    }

    function leader(arr, team, stat, hasStatsFn) {
      const players = arr.filter(p => p.team === team && (hasStatsFn ? hasStatsFn(p) : (p[stat] || 0) > 0));
      if (!players.length) return null;
      return players.reduce((max, p) => (p[stat] > (max[stat] || 0) ? p : max));
    }

    const passHome = leader(passingStats, 'Home', 'yards', p => (p.attempts || p.completions || p.yards));
    const passAway = leader(passingStats, 'Away', 'yards', p => (p.attempts || p.completions || p.yards));
    const rushHome = leader(frontendStats, 'Home', 'yards', p => (p.carries || p.yards));
    const rushAway = leader(frontendStats, 'Away', 'yards', p => (p.carries || p.yards));
    const recHome = leader(receivingStats, 'Home', 'yards', p => (p.receptions || p.yards));
    const recAway = leader(receivingStats, 'Away', 'yards', p => (p.receptions || p.yards));
    const sackHome = leader(defensiveStats, 'Home', 'sacks', p => (p.sacks));
    const sackAway = leader(defensiveStats, 'Away', 'sacks', p => (p.sacks));
    const tklHome = leader(defensiveStats, 'Home', 'tackles', p => (p.tackles));
    const tklAway = leader(defensiveStats, 'Away', 'tackles', p => (p.tackles));

    function statLinePassing(p){
      return `${p.completions}/${p.attempts}, ${p.yards} YDS, ${p.tds} TD, ${p.ints} INT`;
    }
    function statLineRushing(p){
      return `${p.carries} CAR, ${p.yards} YDS, ${p.tds} TD`;
    }
    function statLineReceiving(p){
      return `${p.receptions} REC, ${p.yards} YDS, ${p.tds} TD`;
    }

    function buildSection(label, homePlayer, awayPlayer, statField, lineFn){
      const homeName = homePlayer ? homePlayer.playername : '';
      const awayName = awayPlayer ? awayPlayer.playername : '';
      const homePos = homePlayer && playerTraits[homeName] ? playerTraits[homeName].position : '';
      const awayPos = awayPlayer && playerTraits[awayName] ? playerTraits[awayName].position : '';
      const homeVal = homePlayer ? homePlayer[statField] : '--';
      const awayVal = awayPlayer ? awayPlayer[statField] : '--';
      const homeImg = playerImage(homePlayer);
      const awayImg = playerImage(awayPlayer);
      let html = `
        <div class="leader-row values">
          <div class="leader-left">${homeImg}<span class="leader-value">${homeVal}</span></div>
          <div class="leader-center"></div>
          <div class="leader-right"><span class="leader-value">${awayVal}</span>${awayImg}</div>
        </div>
        <div class="leader-row names">
          <div class="leader-left">${homePlayer ? `<span class="leader-name">${homeName}</span><span class="leader-pos">${homePos}</span>` : ''}</div>
          <div class="leader-center leader-label">${label}</div>
          <div class="leader-right">${awayPlayer ? `<span class="leader-name">${awayName}</span><span class="leader-pos">${awayPos}</span>` : ''}</div>
        </div>`;
      if (lineFn && (homePlayer || awayPlayer)) {
        html += `<div class="leader-row statlines">
          <div class="leader-left">${homePlayer ? `<span class="leader-statline">${lineFn(homePlayer)}</span>` : ''}</div>
          <div class="leader-center"></div>
          <div class="leader-right">${awayPlayer ? `<span class="leader-statline">${lineFn(awayPlayer)}</span>` : ''}</div>
        </div>`;
      }
      html += '<div class="leader-divider"></div>';
      return html;
    }

    container.innerHTML = `
      <div class="leaders-header">GAME LEADERS</div>
      <div class="leaders-team-row">
        <div class="team home"><img src="${state.HomeLogo || ''}" class="team-logo-small" style="height:10vw;"><span class="team-name">${homeTeam}</span></div>
        <div class="team away"><span class="team-name" style="order:1;">${awayTeam}</span><img src="${state.AwayLogo || ''}" class="team-logo-small" style="height:10vw; order:2;"></div>
      </div>
      <div class="leader-divider"></div>
      ${buildSection('Passing Yards', passHome, passAway, 'yards', statLinePassing)}
      ${buildSection('Rushing Yards', rushHome, rushAway, 'yards', statLineRushing)}
      ${buildSection('Receiving Yards', recHome, recAway, 'yards', statLineReceiving)}
      ${buildSection('Sacks', sackHome, sackAway, 'sacks')}
      ${buildSection('Tackles', tklHome, tklAway, 'tackles')}
      <div id="boxscoreLink" class="boxscore-link">Full Box Score</div>
    `;

    const link = document.getElementById('boxscoreLink');
    if (link) link.addEventListener('click', () => {
      const tab = document.querySelector('.tab-button[data-tab="boxscore"]');
      if (tab) tab.click();
    });
  }

  function computeTeamStats() {
    const init = () => ({ firstDowns: 0, thirdAtt: 0, thirdConv: 0, fourthAtt: 0, fourthConv: 0,
      passYds: 0, rushYds: 0, passAtt: 0, passComp: 0, ints: 0, sacks: 0, sackYds: 0,
      rushAtt: 0, fumLost: 0, possTime: 0 });
    const teams = { Home: init(), Away: init() };
    const quarterLen = 15 * 60;
    let prev = { Possession: state.StartingPossession || 'Home', Time: quarterLen, Qtr: 1 };
    playHistory.forEach(play => {
      const team = play.Possession;
      if (!team) return;
      const yards = Number(play.Yards) || 0;
      const down = Number(play.Down);
      const distance = Number(play.Distance);
      const result = play.Result || '';
      const playType = play.PlayType;
      const currTime = parseTimeToSeconds(play.Time);
      const currQtr = Number(play.Qtr || play.QTR || prev.Qtr);
      let diff = 0;
      if (currQtr === prev.Qtr) diff = prev.Time - currTime;
      else diff = prev.Time + (quarterLen * (currQtr - prev.Qtr - 1)) + (quarterLen - currTime);
      if (teams[prev.Possession]) teams[prev.Possession].possTime += diff;
      prev = { Possession: team, Time: currTime, Qtr: currQtr };

      if (playType === 'Pass') {
        if (result === 'Sack') {
          teams[team].sacks++;
          teams[team].sackYds += yards;
          teams[team].passYds += yards;
        } else {
          teams[team].passAtt++;
          if (result !== 'Incomplete' && result !== 'Interception') {
            teams[team].passComp++;
            teams[team].passYds += yards;
          }
          if (result === 'Interception') teams[team].ints++;
          if (result === 'Fumble' && play.RecoveredBy && play.RecoveredBy !== (play.Receiver || play.Player)) {
            teams[team].fumLost++;
          }
        }
      } else if (playType === 'Run') {
        teams[team].rushAtt++;
        teams[team].rushYds += yards;
        if (result === 'Fumble' && play.RecoveredBy && play.RecoveredBy !== play.Player) {
          teams[team].fumLost++;
        }
      }

      if (playType === 'Run' || playType === 'Pass') {
        const converted = yards >= distance || result === 'Touchdown';
        if (down === 3) {
          teams[team].thirdAtt++;
          if (converted) teams[team].thirdConv++;
        } else if (down === 4) {
          teams[team].fourthAtt++;
          if (converted) teams[team].fourthConv++;
        }
        if (converted) teams[team].firstDowns++;
      }
    });
    ['Home','Away'].forEach(t => {
      teams[t].totalYds = teams[t].passYds + teams[t].rushYds;
      teams[t].passYPP = teams[t].passAtt ? teams[t].passYds / teams[t].passAtt : 0;
      teams[t].rushYPR = teams[t].rushAtt ? teams[t].rushYds / teams[t].rushAtt : 0;
      teams[t].turnovers = teams[t].fumLost + teams[t].ints;
    });
    return teams;
  }

  function renderTeamStats() {
    const body = document.getElementById('teamStatsBody');
    if (!body) return;
    const stats = computeTeamStats();
    const rows = [
      { label: '1st Downs', key: 'firstDowns', cls: 'header-row' },
      { label: '3rd down efficiency', fmt: t => `${t.thirdConv}-${t.thirdAtt}`, cls: 'stat-row', indent: 'indent-1' },
      { label: '4th down efficiency', fmt: t => `${t.fourthConv}-${t.fourthAtt}`, cls: 'stat-row', indent: 'indent-1' },
      { label: 'Total Yards', key: 'totalYds', cls: 'header-row' },
      { label: 'Passing', key: 'passYds', cls: 'header2-row', indent: 'indent-1' },
      { label: 'Comp/Att', fmt: t => `${t.passComp}/${t.passAtt}`, cls: 'stat-row', indent: 'indent-2' },
      { label: 'Yards per pass', fmt: t => t.passAtt ? (t.passYds / t.passAtt).toFixed(1) : '0.0', cls: 'stat-row', indent: 'indent-2' },
      { label: 'Interceptions thrown', key: 'ints', cls: 'stat-row', indent: 'indent-2' },
      { label: 'Rushing', key: 'rushYds', cls: 'header2-row', indent: 'indent-1' },
      { label: 'Rushing Attempts', key: 'rushAtt', cls: 'stat-row', indent: 'indent-2' },
      { label: 'Yards per rush', fmt: t => t.rushAtt ? (t.rushYds / t.rushAtt).toFixed(1) : '0.0', cls: 'stat-row', indent: 'indent-2' },
      { label: 'Sacks', fmt: t => `${t.sacks}-${Math.abs(t.sackYds)}`, cls: 'header2-row', indent: 'indent-1' },
      { label: 'Turnovers', key: 'turnovers', cls: 'header-row' },
      { label: 'Fumbles lost', key: 'fumLost', cls: 'stat-row', indent: 'indent-1' },
      { label: 'Interceptions thrown', key: 'ints', cls: 'stat-row', indent: 'indent-1' },
      { label: 'Possession', fmt: t => formatClock(t.possTime), cls: 'header-row' }
    ];
    body.innerHTML = '';
    rows.forEach(r => {
      const tr = document.createElement('tr');
      tr.className = r.cls + (r.indent ? ' ' + r.indent : '');
      const labelTd = document.createElement('td');
      labelTd.textContent = r.label;
      const homeTd = document.createElement('td');
      const awayTd = document.createElement('td');
      const getVal = team => r.key !== undefined ? stats[team][r.key] : r.fmt(stats[team]);
      homeTd.textContent = getVal('Home');
      awayTd.textContent = getVal('Away');
      tr.appendChild(labelTd);
      tr.appendChild(homeTd);
      tr.appendChild(awayTd);
      body.appendChild(tr);
    });
    const hLogo = document.getElementById('teamStatsHomeLogo');
    const aLogo = document.getElementById('teamStatsAwayLogo');
    if (hLogo) hLogo.src = state.HomeLogo || '';
    if (aLogo) aLogo.src = state.AwayLogo || '';
  }

  function loadPlayers() {
      populateBench();
      updateRunnerDropdown();
      receiverRoutes = {};
      playerReadSelection = {};
      qbReadAssignments = {};
      updatePassButtonState();
    }

    function populateBench() {
      const bench = document.getElementById('bench');
      if (!bench) return;
      // Clear existing assignments
      document.querySelectorAll('.formation-slot').forEach(slot => {
        if (slot.firstChild) {
          bench.appendChild(slot.firstChild);
        }
        slot.classList.remove('filled');
        slot.dataset.player = '';
      });
      bench.innerHTML = '';
      const teamName = state[state.Possession];
      Object.entries(playerTraits).forEach(([name, traits]) => {
        if (traits.team === teamName) {
          const item = document.createElement('div');
          let posClass = traits.position.toLowerCase();
          if (posClass === 'te' || posClass === 'ol') posClass = 'teol';
          item.className = `player-item ${posClass}`;
          item.draggable = true;
          item.dataset.player = name;
          item.title = `${name} (${traits.position})`;
          const offStars = '★'.repeat(Number(traits.offStars) || 0);
          const defStars = '★'.repeat(Number(traits.defStars) || 0);
          item.innerHTML = `
            <div class="player-name">${name}</div>
            <div class="star-row"><span>Off:</span><span class="stars off">${offStars}</span></div>
            <div class="star-row"><span>Def:</span><span class="stars def">${defStars}</span></div>
            <div class="player-attributes"><span>Size: ${traits.size}</span><span>Speed: ${traits.speed}</span></div>
          `;
          item.addEventListener('dragstart', dragStart);
          item.addEventListener('touchstart', selectPlayer);
          item.addEventListener('click', selectPlayer);
          bench.appendChild(item);
        }
      });
    }

    function selectRunner(name, el) {
      runSelectedPlayer = name;
      document.querySelectorAll('.rusher-option').forEach(opt => opt.classList.remove('selected'));
      el.classList.add('selected');
    }

    function updateRunnerDropdown() {
      const container = document.getElementById('runPlayerOptions');
      if (!container) return;
      container.innerHTML = '';
      const teamName = state[state.Possession];
      let runners = [];
      if (currentFormation.length > 0) {
        runners = currentFormation
          .filter(f => RUN_POSITIONS.includes(f.position) && f.player)
          .map(f => f.player)
          .filter(name => playerTraits[name] && playerTraits[name].team === teamName);
      }
      if (!runSelectedPlayer || !runners.includes(runSelectedPlayer)) {
        runSelectedPlayer = runners[0] || null;
      }
      runners.forEach(name => {
        const option = document.createElement('div');
        option.className = 'rusher-option' + (name === runSelectedPlayer ? ' selected' : '');
        option.dataset.player = name;
        const trait = playerTraits[name];
        const img = trait && trait.image;
        const placeholder = document.createElement('div');
        placeholder.className = 'player-placeholder';
        if (img) {
          placeholder.innerHTML = `<img src="${img}" class="player-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"><span style="display:none;">👤</span>`;
        } else {
          placeholder.innerHTML = '<span>👤</span>';
        }
        option.appendChild(placeholder);
        const label = document.createElement('div');
        label.textContent = name;
        option.appendChild(label);
        option.addEventListener('click', () => selectRunner(name, option));
        option.addEventListener('touchstart', e => { e.preventDefault(); selectRunner(name, option); });
        container.appendChild(option);
      });
      updatePassButtonState();
    }

    function updatePassButtonState() {
      const btn = document.getElementById('passPlayButton');
      if (!btn) return;
      const teamName = state[state.Possession];
      const hasRoutes = Object.keys(receiverRoutes).some(p => {
        const trait = playerTraits[p];
        return trait && trait.team === teamName && receiverRoutes[p] && receiverRoutes[p] !== 'No Route';
      });
      btn.disabled = !hasRoutes;
    }

    function openRunModal() {
      updateRunnerDropdown();
      const modal = document.getElementById('runModal');
      if (modal) modal.classList.add('open');
    }

    function closeRunModal() {
      const modal = document.getElementById('runModal');
      if (modal) modal.classList.remove('open');
    }

    function dragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.player);
    }

    function allowDrop(e) {
      e.preventDefault();
    }

    function handleDrop(e) {
      e.preventDefault();
      const name = e.dataTransfer.getData('text/plain');
      const item = document.querySelector(`.player-item[data-player="${name}"]`);
      if (!item) return;
      const source = item.parentElement;
      const target = e.currentTarget;
      if (target.classList.contains('formation-slot')) {
        if (target.firstChild) {
          document.getElementById('bench').appendChild(target.firstChild);
        }
        target.appendChild(item);
        target.classList.add('filled');
        target.dataset.player = name;
      } else {
        target.appendChild(item);
      }
      if (source.classList && source.classList.contains('formation-slot')) {
        source.classList.remove('filled');
        source.dataset.player = '';
      }
    }

    function selectPlayer(e) {
      e.preventDefault();
      e.stopPropagation();
      const item = e.currentTarget;
      if (selectedPlayer === item) {
        item.classList.remove('selected');
        selectedPlayer = null;
        return;
      }
      if (selectedPlayer) selectedPlayer.classList.remove('selected');
      selectedPlayer = item;
      item.classList.add('selected');
    }

    function moveSelectedTo(target) {
      if (!selectedPlayer) return;
      const bench = document.getElementById('bench');
      const item = selectedPlayer;
      const source = item.parentElement;
      if (target.classList.contains('formation-slot')) {
        if (target.firstChild) {
          bench.appendChild(target.firstChild);
          target.classList.remove('filled');
        }
        target.appendChild(item);
        target.classList.add('filled');
        target.dataset.player = item.dataset.player;
      } else {
        target.appendChild(item);
      }
      if (source.classList && source.classList.contains('formation-slot')) {
        source.classList.remove('filled');
        source.dataset.player = '';
      }
      item.classList.remove('selected');
      selectedPlayer = null;
    }

    function clearFormation() {
      const bench = document.getElementById('bench');
      if (!bench) return;
      document.querySelectorAll('.formation-slot').forEach(slot => {
        if (slot.firstChild) {
          bench.appendChild(slot.firstChild);
        }
        slot.classList.remove('filled');
        slot.dataset.player = '';
      });
      currentFormation = [];
      selectedPlayer = null;
      document.querySelectorAll('.player-item.selected').forEach(p => p.classList.remove('selected'));
      updateRunnerDropdown();
    }

    function saveFormation() {
      const required = ['QB','TEOL2','TEOL3','TEOL4'];
      const formation = [];
      let valid = true;
      document.querySelectorAll('.formation-slot').forEach(slot => {
        const pos = slot.dataset.position;
        const playerEl = slot.querySelector('.player-item');
        if (playerEl) {
          formation.push({ position: pos, player: playerEl.dataset.player });
        } else if (required.includes(pos)) {
          valid = false;
        }
      });
      if (!valid) {
        alert('Please fill all required positions');
        return;
      }
      currentFormation = formation;
      updateRunnerDropdown();
      savedFormations.push(formation);
      console.log('Saved formation', formation);
      setDefensiveFormation();
      document.getElementById('formationModal').classList.remove('open');
    }

    function getEligibleReceivers() {
      const wrs = currentFormation.filter(f => f.position.startsWith('WR') && f.player);
      const rbs = currentFormation.filter(f => f.position.startsWith('RB') && f.player);
      const teols = currentFormation
        .filter(f => f.position.startsWith('TEOL') && f.player)
        .sort((a,b) => parseInt(a.position.replace('TEOL','')) - parseInt(b.position.replace('TEOL','')));
      const eligibleTeols = [];
      if (teols.length > 0) {
        eligibleTeols.push(teols[0]);
        if (teols.length > 1) eligibleTeols.push(teols[teols.length - 1]);
      }
      return [...wrs, ...rbs, ...eligibleTeols];
    }

    function renderRoutesModal() {
      const list = document.getElementById('routesList');
      if (!list) return;
      list.innerHTML = '';
      const summary = document.getElementById('readSummary');
      if (summary) summary.innerHTML = '';

      const field = list;
      const fieldHeight = field.clientHeight;
      const zoneHeight = fieldHeight / ROUTE_OPTIONS.length;

      ROUTE_OPTIONS.forEach((r, i) => {
        const line = document.createElement('div');
        line.className = 'route-line';
        line.style.bottom = `${(i * 100) / ROUTE_OPTIONS.length}%`;
        field.appendChild(line);

        const label = document.createElement('div');
        label.className = 'zone-label';
        label.style.bottom = `${(i * 100) / ROUTE_OPTIONS.length}%`;
        label.style.height = `${100 / ROUTE_OPTIONS.length}%`;
        label.textContent = r;
        field.appendChild(label);
      });

      const players = getEligibleReceivers();
      players.forEach((p, idx) => {
        const card = document.createElement('div');
        card.className = 'player-circle';
        card.setAttribute('data-player', p.player);
        card.dataset.dragged = 'false';
        card.innerHTML = `<div class="read-badge"></div>`;
        const imgSrc = playerTraits[p.player]?.image || '';
        if (imgSrc) {
          const img = document.createElement('img');
          img.src = imgSrc;
          img.alt = p.player;
          card.appendChild(img);
        } else {
          const span = document.createElement('span');
          span.textContent = '👤';
          card.appendChild(span);
        }
        card.title = p.player;
        field.appendChild(card);

        const cardWidth = card.offsetWidth;
        const savedIdx = QB_READ_OPTIONS.indexOf(playerReadSelection[p.player]);
        const readIdx = savedIdx >= 0 ? savedIdx : idx;
        card.style.left = `${readIdx * (cardWidth + 10)}px`;

        const route = receiverRoutes[p.player] || 'Short';
        const rIdx = ROUTE_OPTIONS.indexOf(route);
        const top = fieldHeight - (rIdx + 0.5) * zoneHeight - card.offsetHeight / 2;
        card.style.top = `${top}px`;

        if (route === 'No Route') {
          handleReadChange(p.player, { value: '' });
        }

        card.addEventListener('click', () => {
          if (card.dataset.dragged === 'true') {
            card.dataset.dragged = 'false';
            return;
          }
          showPlayerDetails(p.player);
        });

        initCardDrag(card, field);
      });

      updateReads(field);
    }

    function initCardDrag(card, field) {
      card.addEventListener('mousedown', e => startDrag(e, false));
      card.addEventListener('touchstart', e => startDrag(e, true), { passive: false });

      function startDrag(e, isTouch) {
        e.preventDefault();
        const rect = field.getBoundingClientRect();
        const cardRect = card.getBoundingClientRect();
        const startX = (isTouch ? e.touches[0].clientX : e.clientX) - cardRect.left;
        const startY = (isTouch ? e.touches[0].clientY : e.clientY) - cardRect.top;

        function move(ev) {
          const clientX = isTouch ? ev.touches[0].clientX : ev.clientX;
          const clientY = isTouch ? ev.touches[0].clientY : ev.clientY;
          let x = clientX - rect.left - startX;
          let y = clientY - rect.top - startY;
          x = Math.max(0, Math.min(x, rect.width - card.offsetWidth));
          y = Math.max(0, Math.min(y, rect.height - card.offsetHeight));
          card.style.left = `${x}px`;
          card.style.top = `${y}px`;
          card.dataset.dragged = 'true';
        }

        function up() {
          document.removeEventListener(isTouch ? 'touchmove' : 'mousemove', move);
          document.removeEventListener(isTouch ? 'touchend' : 'mouseup', up);
          updateRoute(card, field);
          updateReads(field);
        }

        document.addEventListener(isTouch ? 'touchmove' : 'mousemove', move, { passive: false });
        document.addEventListener(isTouch ? 'touchend' : 'mouseup', up);
      }
    }

    function updateRoute(card, field) {
      const top = parseFloat(card.style.top) || 0;
      const cardHeight = card.offsetHeight;
      const fieldHeight = field.clientHeight;
      const distanceFromBottom = fieldHeight - (top + cardHeight / 2);
      let pct = distanceFromBottom / fieldHeight;
      pct = Math.max(0, Math.min(0.9999, pct));
      let idx = Math.floor(pct * ROUTE_OPTIONS.length);
      const route = ROUTE_OPTIONS[idx];
      const player = card.dataset.player;
      receiverRoutes[player] = route;
      if (route === 'No Route') {
        handleReadChange(player, { value: '' });
      }
      updatePassButtonState();
      const zoneHeight = fieldHeight / ROUTE_OPTIONS.length;
      const newTop = fieldHeight - (idx + 0.5) * zoneHeight - cardHeight / 2;
      card.style.top = `${newTop}px`;
    }

    function updateReads(field) {
      const allCards = Array.from(field.querySelectorAll('.player-circle'));
      allCards.forEach(card => {
        if (receiverRoutes[card.dataset.player] === 'No Route') {
          const badge = card.querySelector('.read-badge');
          if (badge) badge.textContent = '';
          handleReadChange(card.dataset.player, { value: '' });
        }
      });
      const cards = allCards.filter(card => receiverRoutes[card.dataset.player] !== 'No Route');
      cards.sort((a, b) => parseFloat(a.style.left) - parseFloat(b.style.left));
      const cardWidth = cards[0]?.offsetWidth || 0;
      const gap = 10;
      const step = cardWidth + gap;
      cards.forEach((card, i) => {
        const read = QB_READ_OPTIONS[i] || '';
        const badge = card.querySelector('.read-badge');
        if (badge) badge.textContent = read;
        card.style.left = `${i * step}px`;
        handleReadChange(card.dataset.player, { value: read });
      });
      updateReadSummary();
    }

    function handleReadChange(player, select) {
      const val = select.value;
      const prev = playerReadSelection[player];
      if (prev) {
        delete qbReadAssignments[prev];
      }
      if (val && qbReadAssignments[val]) {
        const otherPlayer = qbReadAssignments[val];
        playerReadSelection[otherPlayer] = '';
        const otherSelect = document.querySelector(`.qb-read-select[data-player="${otherPlayer}"]`);
        if (otherSelect) otherSelect.value = '';
      }
      if (val) {
        qbReadAssignments[val] = player;
        playerReadSelection[player] = val;
      } else {
        playerReadSelection[player] = '';
      }
    }

    function clearRoutes() {
      receiverRoutes = {};
      playerReadSelection = {};
      qbReadAssignments = {};
      renderRoutesModal();
      updatePassButtonState();
    }

    function updateReadSummary() {
      const summary = document.getElementById('readSummary');
      if (!summary) return;
      let html = '<div class="summary-title">Read Summary:</div>';
      QB_READ_OPTIONS.forEach(r => {
        const player = qbReadAssignments[r] || '';
        const route = player ? (receiverRoutes[player] || '') : '';
        html += `<div class="summary-row"><span class="summary-label">${r}:</span><span>${player ? player + ' - ' + route : ''}</span></div>`;
      });
      summary.innerHTML = html;
    }

    function showPlayerDetails(name) {
      if (currentDetailEl && currentDetailEl.dataset.player === name) {
        currentDetailEl.remove();
        currentDetailEl = null;
        return;
      }
      if (currentDetailEl) {
        currentDetailEl.remove();
        currentDetailEl = null;
      }
      const t = playerTraits[name] || {};
      const detail = document.createElement('div');
      detail.className = 'player-detail';
      detail.dataset.player = name;
      detail.innerHTML = `
        <h4>${name}</h4>
        <div>Size: ${t.size || 0}</div>
        <div>Speed: ${t.speed || 0}</div>
        <div>RR: ${t.routeRunning || 0}</div>
        <div>JMP: ${t.jump || 0}</div>
        <div>HND: ${t.hands || 0}</div>
        <div>Stam: ${t.fatigue || 0}</div>
      `;
      document.body.appendChild(detail);
      detail.addEventListener('click', () => {
        detail.remove();
        if (currentDetailEl === detail) currentDetailEl = null;
      });
      currentDetailEl = detail;
    }

  function setDefensiveFormation() {
    const offenseTeam = state[state.Possession];
    const defenseTeam = state[state.Possession === 'Home' ? 'Away' : 'Home'];
    const defenders = Object.values(playerTraits).filter(p => p.team === defenseTeam);

    const dbs = defenders.filter(p => p.defPos === 'DB').sort((a,b) => b.defStars - a.defStars);
    const dls = defenders.filter(p => p.defPos === 'DL').sort((a,b) => b.defStars - a.defStars);
    const lbs = defenders.filter(p => p.defPos === 'LB').sort((a,b) => b.defStars - a.defStars);
    const safeties = defenders.filter(p => p.defPos === 'S').sort((a,b) => b.defStars - a.defStars);

    const wrs = currentFormation
      .filter(f => f.position.startsWith('WR'))
      .map(f => ({ pos: f.position, player: f.player, stars: playerTraits[f.player]?.offStars || 0 }))
      .sort((a,b) => b.stars - a.stars);

    const olPositions = ['TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].filter(pos =>
      currentFormation.some(f => f.position === pos)
    );

    // DB assignments – fill from DBs, then LBs if needed
    const dbAssignments = [];
    for (let i = 0; i < wrs.length; i++) {
      let player = null;
      if (dbs.length > 0) {
        player = dbs.shift();
      } else if (lbs.length > 0) {
        player = lbs.shift();
      }
      dbAssignments.push({
        position: `DB${i+1}`,
        player: player ? player.name : '',
        align: wrs[i].pos
      });
    }

    // DL assignments – prioritize edge coverage matchups
    const teolPlayers = olPositions.map(pos => {
      const match = currentFormation.find(f => f.position === pos);
      const playerName = match ? match.player : '';
      const routeRunning = playerName ? Number(playerTraits[playerName]?.routeRunning || 0) : 0;
      return { pos, player: playerName, routeRunning };
    });

    const edgePositions = [...new Set([
      olPositions[0],
      olPositions.length > 1 ? olPositions[olPositions.length - 1] : undefined
    ].filter(Boolean))];

    const assignmentsByPos = {};

    const takeBestCoverageDefender = () => {
      let bestSource = '';
      let bestIndex = -1;
      let bestCoverage = -Infinity;

      [
        { name: 'lbs', arr: lbs },
        { name: 'dls', arr: dls }
      ].forEach(({ name, arr }) => {
        arr.forEach((player, idx) => {
          const coverage = Number(player.coverage || 0);
          if (coverage > bestCoverage) {
            bestCoverage = coverage;
            bestSource = name;
            bestIndex = idx;
          }
        });
      });

      if (bestIndex < 0) return null;
      if (bestSource === 'lbs') {
        return lbs.splice(bestIndex, 1)[0];
      }
      if (bestSource === 'dls') {
        return dls.splice(bestIndex, 1)[0];
      }
      return null;
    };

    const edgeDetails = edgePositions
      .map(pos => teolPlayers.find(t => t.pos === pos) || { pos, player: '', routeRunning: 0 })
      .sort((a, b) => b.routeRunning - a.routeRunning);

    edgeDetails.forEach(edge => {
      const defender = takeBestCoverageDefender();
      assignmentsByPos[edge.pos] = { player: defender ? defender.name : '' };
    });

    const interiorPositions = olPositions.filter(pos => !assignmentsByPos[pos]);
    interiorPositions.forEach(pos => {
      let player = null;
      if (dls.length > 0) {
        player = dls.shift();
      } else if (lbs.length > 0) {
        player = lbs.shift();
      }
      assignmentsByPos[pos] = { player: player ? player.name : '' };
    });

    const dlAssignments = olPositions.map((ol, i) => ({
      position: `DL${i+1}`,
      player: assignmentsByPos[ol] ? assignmentsByPos[ol].player : '',
      align: ol
    }));

    let assigned = dbAssignments.length + dlAssignments.length;
    let remaining = Math.max(0, 7 - assigned);

    const predicted = predictPlayType(state.Down, state.Distance).toLowerCase();
    const lbAssignments = [];
    const backs = ['QB','RB1','RB2'];
    let lbNeeded = (predicted === 'run' || predicted === 'screen') ? backs.length : 2;
    lbNeeded = Math.min(lbNeeded, remaining);
    for (let i = 0; i < lbNeeded; i++) {
      let player = null;
      if (lbs.length > 0) {
        player = lbs.shift();
      } else if (dls.length > 0) {
        player = dls.shift();
      } else if (dbs.length > 0) {
        player = dbs.shift();
      }
      if (player) {
        const assignment = { position: `LB${i+1}`, player: player.name };
        if (predicted === 'run' || predicted === 'screen') {
          assignment.align = backs[i];
        }
        lbAssignments.push(assignment);
      }
    }

    assigned += lbAssignments.length;
    remaining = Math.max(0, 7 - assigned);

    // Safety – pick from safeties, then remaining LBs, DBs, DLs
    let safetyAssignment = null;
    if (remaining > 0) {
      if (safeties.length > 0) {
        const s = safeties.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (lbs.length > 0) {
        const s = lbs.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (dbs.length > 0) {
        const s = dbs.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (dls.length > 0) {
        const s = dls.shift();
        safetyAssignment = { position: 'S', player: s.name };
      }
    }

    defensiveFormation = [...dbAssignments, ...dlAssignments, ...lbAssignments];
    if (safetyAssignment) defensiveFormation.push(safetyAssignment);
    console.log('Defensive formation', defensiveFormation);
  }

  function renderLOS() {
    const field = document.getElementById('losField');
    if (!field) return;
    field.innerHTML = '';
    const line = document.createElement('div');
    line.className = 'los-line';
    field.appendChild(line);

    const safetyRow = document.createElement('div');
    safetyRow.className = 'los-row';
    defensiveFormation.filter(d => d.position.startsWith('S')).forEach(s => {
      safetyRow.appendChild(createLosPlayer(s.player));
    });
    if (safetyRow.childElementCount > 0) field.appendChild(safetyRow);

    const lbRow = document.createElement('div');
    lbRow.className = 'los-row';
    defensiveFormation.filter(d => d.position.startsWith('LB')).forEach(lb => {
      lbRow.appendChild(createLosPlayer(lb.player));
    });
    if (lbRow.childElementCount > 0) field.appendChild(lbRow);

    const grid = document.createElement('div');
    grid.className = 'los-grid';
    const losSlots = ['WR1','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5','WR2','WR3'];
    losSlots.forEach(pos => {
      const col = document.createElement('div');
      col.className = 'los-col';
      const def = defensiveFormation.find(d => d.align === pos);
      col.appendChild(createLosPlayer(def ? def.player : ''));
      const off = currentFormation.find(f => f.position === pos);
      col.appendChild(createLosPlayer(off ? off.player : ''));
      grid.appendChild(col);
    });
    field.appendChild(grid);

    const qbRow = document.createElement('div');
    qbRow.className = 'los-row';
    const qb = currentFormation.find(f => f.position === 'QB');
    qbRow.appendChild(createLosPlayer(qb ? qb.player : ''));
    field.appendChild(qbRow);

    const rbRow = document.createElement('div');
    rbRow.className = 'los-row';
    ['RB1','RB2'].forEach(pos => {
      const p = currentFormation.find(f => f.position === pos);
      rbRow.appendChild(createLosPlayer(p ? p.player : ''));
    });
    field.appendChild(rbRow);
  }

  function createLosPlayer(name) {
    const div = document.createElement('div');
    div.className = name ? 'los-player' : 'los-player empty';
    if (name) {
      const imgSrc = playerTraits[name]?.image || '';
      if (imgSrc) {
        const img = document.createElement('img');
        img.src = imgSrc;
        img.alt = name;
        div.appendChild(img);
      } else {
        const span = document.createElement('span');
        span.textContent = '👤';
        div.appendChild(span);
      }
    }
    return div;
  }

  function loadPlayersTraits(callback) {
    google.script.run.withSuccessHandler(function (playerData) {
      console.log("✅ Loaded player traits");
      const playerMap = {};
      playerData.forEach(player => {
        playerTraits[player.name] = player;
      });
      loadPlayers();
      renderPlayerCards();
      if (callback) callback();
    }).getPlayerTraits();
  }

  function loadSettings(callback) {
    console.log("🔄 Loading game settings...");
    google.script.run
      .withSuccessHandler(function (data) {
        if (!data || !data.thresholds) {
          console.error("⚠️ Invalid settings object received:", data);
          alert("Settings could not be loaded. Please check the sheet and try again.");
          return;
        }

        rollThresholds = data.thresholds;
        breakawaySettings = data.breakaways;
        drainSettings = data.staminaDrains;
        tackleSettings = data.tackleTable || [];
        sackLossTable = data.sackLossTable || [];
        completionTable = data.completionTable || [];
        routeTypeAirYards = data.routeTypeAirYards || [];
        timeNeededToOpen = data.timeNeededToThrow || [];
        completionSeparationAdjustment = data.completionSeparationAdjustment || [];
        yacBySeparation = data.yacBySeparation || {};

        console.log("✅ Game settings fully initialized.");
        if (callback) callback();
      })
      .withFailureHandler(err => {
        console.error("❌ Server error:", err.message);
        alert("There was a problem loading game settings.");
      })
      .getFrontendSettings();
  }

  function runBlockVsRunDef(ballCarrier) {
    let dlTotal = 0;
    let olTotal = 0;

    defensiveFormation.forEach(f => {
      if (f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))) {
        dlTotal += Number(playerTraits[f.player]?.runDef || 0);
      }
    });

    currentFormation.forEach(f => {
      if (!f.player) return;
      const pos = f.position;
      const isOffensive = ['QB','RB1','RB2','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].includes(pos);
      if (isOffensive && f.player !== ballCarrier) {
        olTotal += Number(playerTraits[f.player]?.runDef || 0);
      }
    });

    const total = dlTotal + olTotal;
    console.log(dlTotal + " -- " + olTotal);
    if (total <= 0) return { defenseWins: false };
    const roll = Math.floor(Math.random() * total) + 1;
    console.log(" -- " + roll);
    return { defenseWins: roll <= dlTotal };
  }

  function determineTackler(yards) {
    if (!tackleSettings || tackleSettings.length === 0) return "NA";
    const gain = Math.max(0, Math.floor(yards));
    let range = tackleSettings.find(r => gain <= r.yardageCap);
    if (!range) range = tackleSettings[tackleSettings.length - 1];

    const hasDL = defensiveFormation.some(f => f.player && f.position.startsWith("DL"));
    const hasLB = defensiveFormation.some(f => f.player && f.position.startsWith("LB"));
    const hasDBS = defensiveFormation.some(
      f => f.player && (f.position.startsWith("DB") || f.position.startsWith("S"))
    );

    const groups = [];
    if (hasDL && range.DL > 0) groups.push({ name: "DL", chance: range.DL });
    if (hasLB && range.LB > 0) groups.push({ name: "LB", chance: range.LB });
    if (hasDBS && range.DBS > 0) groups.push({ name: "DBS", chance: range.DBS });

    const totalChance = groups.reduce((sum, g) => sum + g.chance, 0);
    if (totalChance <= 0) return "NA";

    let roll = Math.random() * totalChance;
    console.log(roll);
    let group = groups[groups.length - 1].name;
    for (const g of groups) {
      if (roll < g.chance) {
        group = g.name;
        break;
      }
      roll -= g.chance;
    }
    console.log(group);

    const inGroup = defensiveFormation.filter(f => {
      if (!f.player) return false;
      if (group === "DL") return f.position.startsWith("DL");
      if (group === "LB") return f.position.startsWith("LB");
      return f.position.startsWith("DB") || f.position.startsWith("S");
    });
    if (inGroup.length === 0) return "NA";

    const total = inGroup.reduce((sum, f) => sum + Number(playerTraits[f.player]?.tackleChance || 0), 0);
    if (total <= 0) return inGroup[Math.floor(Math.random() * inGroup.length)].player;

    let r = Math.random() * total;
    console.log(r);
    for (const f of inGroup) {
      console.log(f.player + " - " + playerTraits[f.player]?.tackleChance);

      r -= Number(playerTraits[f.player]?.tackleChance || 0);
      if (r <= 0) return f.player;
    }
    return inGroup[inGroup.length - 1].player;
  }

  function checkForFumble(runner, tackler, sack = false) {
    if (!runner || !tackler || tackler === "NA") return { fumble: false };
    const rb = playerTraits[runner];
    const def = playerTraits[tackler];
    if (!rb || !def) return { fumble: false };
    const strip = Number(def.strip || 0);
    const ballSec = Number(rb.ballsecurity ?? rb.hands ?? 50);
    let fumbleChance = (strip / 10) * ((100 - ballSec) / 100);
    if(sack){
      const defStars =  Number(def.defStars || 0);
      fumbleChance = (25 + (strip / 10)  + defStars)* ((100 - ballSec) / 100);
    }
    const roll = Math.random() * 100;
    if (roll <= fumbleChance) {
      const defStars = Number(def.defStars || 0);
      const offStars = Number(rb.offStars || 0);
      const starsSum = defStars + offStars;
      const recoveryRoll = Math.random() * starsSum;
      const recoveredBy = recoveryRoll <= defStars ? tackler : runner;
      return { fumble: true, recoveredBy };
    }
    return { fumble: false };
  }

  function tryAutoStuff() {
    console.log("autoStuffing");
    let starPower = 0;
    defensiveFormation.forEach(f => {
      if (f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))) {
        console.log(Number(playerTraits[f.player]?.defStars || 0));
        console.log((Number(playerTraits[f.player]?.defStars || 0))**2);

        starPower += ((Number(playerTraits[f.player]?.defStars || 0))**2)/2.5;
      }
    });
    console.log("Star Power" + starPower);
    const roll = Math.floor(Math.random() * 100) + 1;
    return roll <= starPower;
  }

  function tryAutoRelease(ballCarrier) {
    let starPower = 0;
    currentFormation.forEach(f => {
      if (!f.player) return;
      const pos = f.position;
      const isOffensive = ['QB','RB1','RB2','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].includes(pos);
      if (isOffensive && f.player !== ballCarrier) {
        starPower += ((Number(playerTraits[f.player]?.offStars || 0))**2)/2.5;
      }
    });
    const roll = Math.floor(Math.random() * 100) + 1;
    return roll <= starPower;
  }

  function rollOffStarPower(ballCarrier) {
    const stars = Number(playerTraits[ballCarrier]?.offStars || 0);
    const threshold = Math.pow(stars, 2);
    const roll = Math.random() * 100;
    return roll <= threshold;
  }

  function rollDefStarPower() {
    const candidates = defensiveFormation
      .filter(f => f.player && (f.position.startsWith('DL') || f.position.startsWith('LB')))
      .map(f => {
        const stars = Number(playerTraits[f.player]?.defStars || 0);
        return { name: f.player, stars, weight: Math.pow(stars, 2) };
      });

    const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
    if (totalWeight <= 0) return false;

    let roll = Math.random() * totalWeight;
    let chosen = candidates[0];
    for (const c of candidates) {
      if (roll < c.weight) {
        chosen = c;
        defStarPowerTackler = chosen.name;
        break;
      }
      roll -= c.weight;
    }

    const threshold = Math.pow(chosen.stars, 2);
    const activationRoll = Math.random() * 100;
    return activationRoll <= threshold;
  }

  function afterPlayComplete() {
    autoStuff = false;
    autoRelease = false;
    offStarPower = false;
    defStarPower = false;
  }

  function determineTimeToThrow() {
    let predictionEffect = 0;
    //if predicted, pass:  
    predictionEffect = 20;
    //else: 
    //let rollTest = randomInt(0, 100);
    //if(rollTest <= 50){
    //    predictionEffect = -10;
    //}
    //

    let passRushSum = defensiveFormation
      .filter(f => f.position.startsWith('DL') || f.position.startsWith('LB'))
      .reduce((sum, f) => sum + Number(playerTraits[f.player]?.passRush || 0), 0);
    passRushSum += predictionEffect*2;

    let passProtectSum = currentFormation
      .filter(f => f.position.startsWith('RB') || f.position.startsWith('TEOL'))
      .reduce((sum, f) => sum + Number(playerTraits[f.player]?.passProtect || 0), 0);
    passProtectSum -= predictionEffect*2;

    let passProtection = true;
    const maxRoll = Math.round(passRushSum + passProtectSum);
    const roll = randomInt(0, maxRoll);
    if (roll <= passRushSum) passProtection = false;

    return handleRush(passProtection, predictionEffect);
  }

  function handleRush(passProtection, predictionEffect) {
    if (passProtection) {
      let protectionStrength = currentFormation
        .filter(f => f.position.startsWith('RB') || f.position.startsWith('TEOL'))
        .reduce((sum, f) => {
          const offStars = Number(playerTraits[f.player]?.offStars || 0);
          return sum + (Math.pow(offStars, 2) / 2);
        }, 0);

      protectionStrength *= 1.25;

      let roll = Math.random() * 100;
      if (roll <= protectionStrength + 25) {
        roll = Math.random() * 100;
        if (roll <= protectionStrength + 15) {
          roll = Math.random() * 100;
          return roll <= protectionStrength ? 5 : 4;
        }
        return 3;
      }
      return 2;
    }

    let rushStrength = defensiveFormation
      .filter(f => f.position.startsWith('DL') || f.position.startsWith('LB'))
      .reduce((sum, f) => {
        const defStars = Number(playerTraits[f.player]?.defStars || 0);
        return sum + (Math.pow(defStars, 2) / 2);
      }, 0);
    rushStrength += predictionEffect/3;  

    let sackChance = defensiveFormation
      .filter(f => f.position.startsWith('DL') || f.position.startsWith('LB'))
      .reduce((sum, f) => {
        const defStars = Number(playerTraits[f.player]?.defStars || 0);
        return sum + (Math.pow(defStars, 2) / 2);
      }, 0);
    sackChance = sackChance + Math.max(0, predictionEffect);  

    let roll = Math.random() * 100;
    if (roll <= rushStrength) {
      roll = Math.random() * 100;
      return roll <= sackChance ? -1 : 0;
    }
    return 1;
  }

  // === PASS PLAY ===
  async function passPlay() {
    const qbSlot = currentFormation.find(f => f.position === 'QB');
    const qbName = qbSlot ? qbSlot.player : null;
    if (!qbName) return;
    disablePlayControls();
    pendingFGTeam = null;
    let resultArray;
    let completionPct;
    let routes;
    let target;
    let targetData;
    let completionData;
    const origPossession = state.Possession;
    let timeToThrow = determineTimeToThrow();

    routes = assignRoutes();

    if(timeToThrow < 0){
      resultArray = handleSack(qbName);
    } else{
      targetData = choosePassTarget(qbName, routes, timeToThrow);
      target = {target: targetData.target, routeInfo: targetData.routeInfo};
      completionData = determineCompletionPct(qbName, target, routes);
      completionPct = completionData.pct;
      console.log(routes, target, completionPct);
      resultArray = determinePassOutcome(qbName, target, routes, completionPct);
    }

    //postPlayStuff
    const scoringTeam = state.Possession;
    const oldScore = scoringTeam === "Home"
      ? parseInt(state.HomeScore, 10) || 0
      : parseInt(state.AwayScore, 10) || 0;
      let yards = resultArray.yards || 0;
      let touchdown = false;
      let tackler = null;
      let fumble = false;
      let recoveredBy = null;
      let newBall = state.BallOn;
      let newDown = state.Down;
      let newDist = state.Distance;
      let safety = false;

      //HandleSack
        if (resultArray.sack){
          newBall = state.Possession === 'Home' ? newBall + yards : newBall - yards;
          const fum = checkForFumble(qbName, resultArray.sackBy, resultArray.sack);
          if (fum.fumble) {
            fumble = true;
            recoveredBy = fum.recoveredBy;
          }
          tackler = resultArray.sackBy;
          updateDefensiveStatsPass(tackler, { tackle: true, yards: yards, sack: true, fumble: fumble, recoveredBy: recoveredBy});
        } else if (resultArray.intercepted) {
          const airYards = Number(target?.routeInfo?.airYards) || 0;
          newBall = state.Possession === 'Home' ? newBall + airYards : newBall - airYards;
        }
        //Handle Completed Pass
        if (resultArray.completed){
        newBall = state.Possession === 'Home' ? newBall + yards : newBall - yards;
        touchdown = state.Possession === 'Home' ? newBall >= 100 : newBall <= 0;
        if(touchdown){
          yards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;
          newBall = state.Possession === "Home" ? 100 : 0;
          resultArray.touchdown = true;
        }
        if (!touchdown) {
          tackler = determineTackler(yards); //NEEDS UPDATING
          const fum = checkForFumble(target.target, tackler);
          if (fum.fumble) {
            fumble = true;
            recoveredBy = fum.recoveredBy;
          }
        }
      }
      if (!touchdown && !resultArray.intercepted) {
        safety = state.Possession === 'Home' ? newBall <= 0 : newBall >= 100;
        if (safety) {
          yards = state.Possession === 'Home' ? -state.BallOn : -(100 - state.BallOn);
          newBall = state.Possession === 'Home' ? 0 : 100;
        }
      }
      if (!isTwoPtAttempt) {
        updatePassingStats(qbName, yards, resultArray.completed, resultArray.intercepted, touchdown, resultArray.sack);
        if (target) {
          updateReceivingStats(target.target, yards, resultArray.completed, touchdown, fumble);
        }
        if (resultArray.intercepted) {
          updateDefensiveStatsPass(resultArray.caughtBy, { interception: true });
        } else {
          const defenderName = target && target.routeInfo ? target.routeInfo.defender : null;
          if (defenderName && !resultArray.completed) {
            if (target.routeInfo.defStarsPctBoost) {
              updateDefensiveStatsPass(defenderName, { deflection: true });
            }
          }
          if (tackler) {
            updateDefensiveStatsPass(tackler, { tackle: true, yards, fumble, recoveredBy });
          }
        }
      }
    //Handle Interception
    if(resultArray.intercepted){

    }

    let timeTaken = 5;  //NEEDS UPDATING
    let predicted = "PASS";  //NEEDS UPDATING
    let result = "Normal";

    if (isTwoPtAttempt) {
      const success = touchdown && !resultArray.intercepted;
      state.Previous = state.BallOn;
      state.BallOn = newBall;
      if (success) {
        if (twoPtTeam === 'Home') {
          state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 2;
        } else {
          state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 2;
        }
      }
      const playLog = logTwoPointPlay(twoPtTeam, qbName, target ? target.target : '', yards, success);
      if (playHistory.length >= 2) {
        playHistory[playHistory.length - 2].afterTdPlay = playLog;
      }
      renderPlayTimeline();
      const gameData = {
        gameId: gameId,
        quarter: state.Qtr,
        time: state.Time,
        down: postPATState.down,
        distance: postPATState.distance,
        ballOn: postPATState.ballOn,
        homeScore: state.HomeScore,
        awayScore: state.AwayScore,
        driveStart: postPATState.driveStart,
        previous: postPATState.previous,
        possession: postPATState.possession,
        homeTimeouts: state.HomeTimeouts,
        awayTimeouts: state.AwayTimeouts
      };
      savePlayAndGameWithRetry({ play: playLog, game: gameData });
      state.Down = postPATState.down;
      state.Distance = postPATState.distance;
      state.Possession = postPATState.possession;
      state.BallOn = postPATState.ballOn;
      state.Previous = postPATState.previous;
      state.DriveStart = postPATState.driveStart;
      isTwoPtAttempt = false;
      twoPtTeam = null;
      postPATState = null;
      updateStateUI();
      document.getElementById('result').innerHTML = success ? '<strong>2-point conversion is SUCCESSFUL!</strong>' : '<strong>2-point conversion fails.</strong>';
      afterPlayComplete();
      return;
    }

    //Handle offense retaining possession
      if(!resultArray.intercepted && (!fumble || recoveredBy !== tackler)){
        newDist = newDist - yards;
        const playTypeForSafety = resultArray.sack ? 'Run' : 'Pass';
        //handle Touchdown
        if(safety){
          result = "Safety";
          await handleSafety(qbName, resultArray.completed ? target.target : '', yards, tackler, predicted, timeTaken, playTypeForSafety, resultArray);
        } else if(touchdown){
          result = "Touchdown";
          await handleTouchdown(newBall, qbName, target.target, resultArray, result, predicted, timeTaken, resultArray);
          await celebrateTouchdown(scoringTeam, oldScore, oldScore + 6);
        }
        //Handle First Down
        else if(newDist <= 0){
          result = "First Down";
          newDown = 1;
          const yardsToGoal = state.Possession === "Home" ? 100 - newBall : newBall;
          newDist = yardsToGoal < 10 ? yardsToGoal : 10;
          updateGameState(1, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, target.target, yards, tackler, result, predicted, timeTaken, recoveredBy);
          await animatePlay('Pass', resultArray);
        } else{
          let playType = 'Pass';
          if (resultArray.sack) {
            playType = 'Run';
            result = fumble ? 'Fumble' : 'Sack';
            target = { target: '' };
          } else if (!resultArray.completed) {
            result = 'Incomplete';
          }
          newDown++;
          if (newDown > 4) {
            if(result != 'Incomplete' && result != 'Sack'){
              result = "TO on Downs";
            }
            await handleTOonDowns(result, newBall, qbName, target.target, resultArray, tackler, predicted, timeTaken, resultArray);
          } else {
            updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, target.target, yards, tackler, result, predicted, timeTaken, recoveredBy);
            await animatePlay(playType, resultArray);
          }
        }
      }
    //Handle Fumble or INT
    else {
      if (resultArray.intercepted) {
        result = "Interception";
        recoveredBy = resultArray.caughtBy;
      } else if (resultArray.sack) {
        result = fumble ? "Fumble" : "Sack";
      } else {
        result = "Fumble";
      }
      updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, target ? target.target : '', yards, tackler, result, predicted, timeTaken, recoveredBy);
      await animatePlay('Pass', resultArray);
      const newPossession = state.Possession === 'Home' ? 'Away' : 'Home';
      updateGameState(1, 10, newPossession, newBall, newBall, newBall, qbName, target ? target.target : '', yards, tackler, null, predicted, undefined, recoveredBy);
    }
    // Apply stamina drains for pass play
    if (resultArray.sack) {
      applyFatigue(qbName, 'Sacked');
    } else {
      applyFatigue(qbName, 'Throw');
    }
    if (resultArray.completed && target && target.target) {
      applyFatigue(target.target, 'Rec');
    }
    Object.keys(routes || {}).forEach(name => {
      applyFatigue(name, 'Route');
    });

    //updateFrontendStats(qbName, recordedYards, result, scoringTeam, tackler, recoveredBy);

    renderBoxScore();

    const passLog = [];
    if(targetData && targetData.logs){
      passLog.push(`Throw roll: ${targetData.logs.selectionRoll.toFixed(1)}`);
      targetData.logs.routeLikelihoods.forEach(l => passLog.push(`${l.name} throwLikelihood: ${l.throwLikelyhood.toFixed(1)}`));
    }
    if(completionData){
      if(resultArray && resultArray.completionRoll !== undefined){
        passLog.push(`Completion roll: ${resultArray.completionRoll.toFixed(1)}`);
      }
      passLog.push(`Completion pct: ${completionPct.toFixed(1)}`);
      completionData.log.forEach(m => passLog.push(m));
    }

    let text = "";
    if (resultArray.sack) {
      const spot = formatBallOnForPoss(newBall, origPossession);
      const loss = Math.abs(yards);
      const tack = tackler || resultArray.sackBy;
      text = `${qbName} sacked at the ${spot} for a loss of ${loss}`;
      if (tack) {
        text += ` (${tack})`;
      }
      text += ".";
      if (fumble) {
        const recoveryPoss = recoveredBy === qbName ? origPossession : (origPossession === 'Home' ? 'Away' : 'Home');
        const recSpot = formatBallOnForPoss(newBall, recoveryPoss);
        text += ` Fumble, recovered by ${recoveredBy} at the ${recSpot}.`;
      }
    } else if (resultArray.intercepted) {
      text = `${qbName} pass intended for ${target ? target.target : ''}. Intercepted by ${resultArray.caughtBy}.`;
    } else if (resultArray.completed) {
      text = `${qbName} pass to ${target.target} for ${yards} yards`;
    } else {
      text = `${qbName} pass intended for ${target ? target.target : ''}. Incomplete.`;
    }

    document.getElementById("result").innerHTML = `<strong>${text}</strong><br/><br/>` +
      `Modifiers: <ul>${passLog.map(m => `<li>${m}</li>`).join('')}</ul>`;

    updateStateUI();
    //refreshUI();
    afterPlayComplete();
  }

  function handleSack(qbName){
    const rushers = defensiveFormation.filter(f =>
      f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))
    );
    if (rushers.length === 0) {
      return { sack: true, sackBy: "NA", yards: -5 };
    }

    const total = rushers.reduce((sum, f) =>
      sum + Number(playerTraits[f.player]?.sackChance || 0), 0);

    let roll = Math.random() * total;
    let sacker = rushers[0].player;

    if (total <= 0) {
      sacker = rushers[Math.floor(Math.random() * rushers.length)].player;
    } else {
      for (const f of rushers) {
        roll -= Number(playerTraits[f.player]?.sackChance || 0);
        if (roll <= 0) {
          sacker = f.player;
          break;
        }
      }
    }

    let loss = 5;
    if (sackLossTable.length) {
      const pctRoll = Math.random() * 100;
      let cumulative = 0;
      let selected = sackLossTable[0];
      for (const entry of sackLossTable) {
        cumulative += Number(entry.pct || 0);
        if (pctRoll <= cumulative) {
          selected = entry;
          break;
        }
      }
      loss = randomInt(Number(selected.min), Number(selected.max));
    }

    const agility = (Number(playerTraits[qbName]?.juke || 0)/10)**2;
    if (Math.random() * 100 <= agility) {
      loss = Math.max(1, loss - 2);
    }

    return { sack: true, sackBy: sacker, yards: -loss };
  }

  function assignRoutes() {
    const routes = {};
    const eligible = getEligibleReceivers().map(r => r.player);
    const lbs = defensiveFormation.filter(d => d.position.startsWith('LB'));
    currentFormation.forEach(f => {
      if (!f.player) return;
      if (!eligible.includes(f.player)) return;
      const routeType = receiverRoutes[f.player] || 'Short';
      if (routeType === 'No Route') return;
      const info = routeTypeAirYards.find(r => r.routeType === routeType);
      const depth = info ? randomInt(info.minAirYards, info.maxAirYards) : 0;
      const time = CalcTimeNeededToOpen(depth, f.player);
      let defender = null;
      if (f.position.startsWith('RB')) {
        const rbIndex = f.position === 'RB1' ? 0 : 1;
        const aligned = defensiveFormation.find(d => d.align === f.position && d.position.startsWith('LB'));
        defender = aligned ? aligned.player : (lbs[rbIndex] ? lbs[rbIndex].player : (lbs[0] ? lbs[0].player : null));
      } else {
        const aligned = defensiveFormation.find(d => d.align === f.position);
        defender = aligned ? aligned.player : null;
      }
      routes[f.player] = { routeType, airYards: depth, TTO: time, defender, position: f.position };
    });
    return routes;
  }

  function CalcTimeNeededToOpen(depth, player) {
    const time = 5;
    const read = playerReadSelection[player];
    if (!read) return;
    const table = timeNeededToOpen.find(t => t.qbRead === read);
    if (!table) return;
    let key;
    if (depth < 10) key = 'lt10';
    else if (depth <= 20) key = 'tenTo20';
    else key = 'twentyOnePlus';
    return table[key];
  }

  function choosePassTarget(qbName, routes, timeToThrow) {
    routes = determineSeparation(routes, timeToThrow);
    const qb = playerTraits[qbName] || {};
    const readRoll = randomInt(0, 100);
    const qbReadsDefense = readRoll <= (Number(qb.readDefense) || 0);

    const routeLikelihoods = [];

    Object.keys(routes).forEach(name => {
      const read = playerReadSelection[name];
      let readVal = 3;
      //setup readVal
      switch (read) {
        case "Primary":
          readVal = 5;
          break;
        case "2nd":
          readVal = 4;
          break;
        case "3rd":
          readVal = 3;
          break;
        case "4th":
          readVal = 2;
          break;
        case "Checkdown":
          readVal = 1;
          break;
        default:
          readVal = 0; // fallback if none match
      }

      const route = routes[name];
      const wr = playerTraits[name] || {};
      route.percievedSeparation = qbReadsDefense ? route.separation : 0;
      //route.throwLikelyhood = ((Number(wr.qbFavorite) || 0) / 10) + (route.percievedSeparation * 3);
      route.throwLikelyhood = readVal + (route.percievedSeparation * 3);

      // Determine weight based on depth of route using completionTable
      let airyardsweight = 0;
      if (completionTable && completionTable.length > 0) {
        for (const row of completionTable) {
          if (route.airYards <= row.pastLos) {
            airyardsweight = Number(row.percentage) || 0;
            break;
          }
        }
      }
      route.airyardsweight = airyardsweight;
      //route.weight = Math.max(0.1, airyardsweight * route.throwLikelyhood);
      route.weight = readVal == 0 ? 0 : airyardsweight + route.throwLikelyhood;
      routeLikelihoods.push({name, throwLikelyhood: route.throwLikelyhood, weight: route.weight});
    });

    const totalWeight = Object.keys(routes).reduce((sum, name) => sum + (routes[name].weight || 0), 0);
    if (totalWeight <= 0) {
      return { target: null, routeInfo: null, logs: { routeLikelihoods, selectionRoll: 0 } };
    }

    let roll = Math.random() * totalWeight;
    const selectionRoll = roll;
    let chosenName = Object.keys(routes)[0];
    for (const name of Object.keys(routes)) {
      const w = routes[name].weight || 0;
      if (roll < w) {
        chosenName = name;
        break;
      }
      roll -= w;
    }

    return { target: chosenName, routeInfo: routes[chosenName], logs: { routeLikelihoods, selectionRoll } };
  }

  function determineSeparation(routes, timeToThrow){
     Object.keys(routes).forEach(name => {
      const route = routes[name];
      const wr = playerTraits[name] || {};
      const db = playerTraits[route.defender] || {};
      let separation = 0;

      if (route.airYards > 10) {
        const wrTotal = (Number(wr.speed) || 0) + (Number(wr.acceleration) || 0);
        const dbTotal = (Number(db.speed) || 0) + (Number(db.acceleration) || 0);
        const roll = randomInt(0, wrTotal + dbTotal);
        if (roll <= wrTotal) separation += 1;
      }

      for (let i = 0; i < 3; i++) {
        const roll = randomInt(0, 100);
        if (roll <= (Number(wr.routeRunning) || 0)) separation += 1;
      }

      for (let i = 0; i < 2; i++) {
        const roll = randomInt(0, 100);
        if (roll <= (Number(db.coverage) || 0)) separation -= 1;
      }

      separation += Math.max(-2,Math.min(0, timeToThrow - routes[name].TTO));

      route.separation = separation;
    });
    return routes;
  }

  function qbAccuracyAdjust(qb) {
    const acc = Number(qb.accuracy) || 0;
    const diff = (acc - 50) / 10;
    const adjust = (diff ** 2) / 2;
    return acc >= 50 ? adjust : -adjust;
  }

  function qbArmStrengthAdjust(qb, routeInfo, completionPct, log) {
    const depth = Number(routeInfo.airYards) || 0;
    const arm = Number(qb.armStrength) || 0;
    if (depth >= 20 && arm - 50 > 0) {
      const roll = Math.random() * 100;
      if (roll <= arm - 50) {
        const armBoost = Math.pow(arm / 25, 2);
        completionPct += armBoost;
        log.push(`ArmStrength +${armBoost.toFixed(1)}`);
      }
    }
    return completionPct;
  }

  function determineCompletionPct(qbName, target, routes) {
    const log = [];
    if (!target) return { pct: 0, log };
    const qb = playerTraits[qbName] || {};
    const routeInfo = target.routeInfo || {};
    const separation = Number(routeInfo.separation) || 0;
    const depth = Number(routeInfo.airYards) || 0;
    let jumpBall = false;

    if (
      separation < 1 ||
      (separation < 3 && (state.BallOn + depth > 100 || state.BallOn + depth < 0))
    ) {
      jumpBall = true;
    }

    let baseCompletion = 0;
    if (completionTable && completionTable.length > 0) {
      for (const row of completionTable) {
        if (depth <= row.pastLos) {
          baseCompletion = Number(row.baseCompletion) || 0;
          break;
        }
      }
    }
    log.push(`Base ${baseCompletion}`);

    const qbAdj = qbAccuracyAdjust(qb);
    let completionPct = baseCompletion + qbAdj;
    log.push(`QB Accuracy ${qbAdj >= 0 ? "+" : ""}${qbAdj.toFixed(1)}`);

    const sepAdjust = completionSeparationAdjustment.find(r => Number(r.separation) === separation);
    if (sepAdjust) {
      const sepVal = Number(sepAdjust.catchPctChange) || 0;
      completionPct += sepVal;
      log.push(`Separation ${sepVal >= 0 ? "+" : ""}${sepVal}`);
    }

    const receiver = playerTraits[target.target] || {};
    const hands = Number(receiver.hands);
    if (!isNaN(hands)) {
      const diff = (hands - 60) / 10;
      const handsBoost = (diff ** 2) / 2;
      completionPct += handsBoost;
      log.push(`Hands ${handsBoost >= 0 ? "+" : ""}${handsBoost.toFixed(1)}`);
    }
    let offStarsPctBoost = 0;
    const offStars = Number(receiver.offStars) || 0;
    const offRoll = Math.random() * 100;
    if (offRoll <= Math.pow(offStars, 2)) {
      offStarsPctBoost = Math.pow(offStars, 2)/3;
    }
    if (offStarsPctBoost !== 0) log.push(`OffStarPower ${offStarsPctBoost >= 0 ? "+" : ""}${offStarsPctBoost.toFixed(1)}`);
    let defStarsPctBoost = 0;
    const defender = playerTraits[routeInfo.defender] || {};
    const defStars = Number(defender.defStars) || 0;
    const defRoll = Math.random() * 100;
    if (defRoll <= Math.pow(defStars, 2)) {
      defStarsPctBoost = -Math.pow(defStars, 2)/3;
    }
    if (defStarsPctBoost !== 0) log.push(`DefStarPower ${defStarsPctBoost >= 0 ? "+" : ""}${defStarsPctBoost.toFixed(1)}`);
    routeInfo.defStarsPctBoost = defStarsPctBoost;
    completionPct += offStarsPctBoost + defStarsPctBoost;

    // Adjust completion percentage based on route variation
    if (routes) {
      const typeSet = new Set();
      Object.values(routes).forEach(r => {
        let type = r.routeType;
        if (type === 'Long' || type === 'Med-Long') type = 'Long';
        typeSet.add(type);
      });
      const routeVariation = typeSet.size * 2.5;
      const routeAdj = Math.min(0,routeVariation - 8);
      completionPct += routeAdj;
      log.push(`RouteVariation ${routeAdj >= 0 ? "+" : ""}${routeAdj.toFixed(1)}`);
    }
    completionPct = qbArmStrengthAdjust(qb, routeInfo, completionPct, log);

    return { pct: completionPct, log };
  }

  function determinePassOutcome(qbName, target, routes, completionPct) {
    if (!target) {
      return { completed: false, intercepted: false, yards: 0, completionRoll: 0 };
    }

    const qb = playerTraits[qbName] || {};
    const routeInfo = target.routeInfo || {};
    const defenderName = routeInfo.defender;
    const defender = playerTraits[defenderName] || {};
    const airYards = Number(routeInfo.airYards) || 0;

    const completionRoll = Math.random() * 100;
    if (completionRoll <= completionPct) {
      const yac = calcYAC(target.target, routeInfo.separation);
      const totalYards = airYards + (Number(yac) || 0);
      return { completed: true, intercepted: false, yards: totalYards, caughtBy: target.target, completionRoll };
    }

    const qbAccCalc = Math.pow(((Number(qb.accuracy) || 0) - 60) / 10, 2) / 2;
    const qbReadCalc = Math.pow(((Number(qb.readDefense) || 0) - 60) / 10, 2) / 2;
    const defBallHawkCalc = Math.pow(((Number(defender.ballHawk) || 0) - 60) / 10, 2) / 2;
    const defReadQBCalc = Math.pow(((Number(defender.readQB) || 0) - 60) / 10, 2) / 2;
    const pickChance = 1 + Math.max(0, 5 - qbAccCalc - qbReadCalc + defBallHawkCalc + defReadQBCalc);
    console.log(pickChance + 'pickchance');

    const pickRoll = Math.random() * 100;
    if (pickRoll <= pickChance) {
      const yac = calcYAC(defenderName, routeInfo.separation);
      const totalYards = airYards + (Number(yac) || 0);
      return { completed: false, intercepted: true, yards: totalYards, caughtBy: defenderName, completionRoll };
    }

    return { completed: false, intercepted: false, yards: 0, completionRoll };
  }

  function calcYAC(playerName, separation = 0){
    const stats = playerTraits[playerName] || {};
    const sepKey = String(separation);
    const table = yacBySeparation[sepKey] || yacBySeparation[0] || [];
    if (table.length === 0) return 0;

    let modLog = [];
    let roll = Math.random() * 100;
    roll = maybeBoostRollForAcceleration(roll, stats, modLog);

    let yards = 0;
    for (const r of table) {
      if (roll >= r.rollMin && roll < r.rollMax) {
        yards = randomInt(r.minYards, r.maxYards);
        break;
      }
    }

    yards = maybeAvoidLoss(yards, stats, modLog);
    yards = adjustChunkRunForSpeed(yards, stats, modLog, true);

    if (yards <= 2) {
      yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
    }
    if (yards >= 1 && yards <= 4) {
      yards += applyTraitEffect("Acceleration", stats.acceleration + Math.min(0, stats.fatigue), true, modLog);
    }
    if (yards > 0 && yards < 5) {
      yards += applyTraitEffect("Juke", stats.juke + Math.min(0, stats.fatigue), true, modLog);
    }

    return yards;
  }

  // === MAIN PLAY ===
  async function runPlay() {
    const playerName = runSelectedPlayer;
    if (!playerName) return;
    disablePlayControls();
    closeRunModal();
    pendingFGTeam = null;

    let tackler = null;

    offStarPower = rollOffStarPower(playerName);
    defStarPower = rollDefStarPower();

    const blockResult = runBlockVsRunDef(playerName);
    if (blockResult.defenseWins) {
      autoStuff = tryAutoStuff();
    } else {
      autoRelease = tryAutoRelease(playerName);
    }

    const rbStats = playerTraits[playerName];
    const carryResult = simulateSingleCarry(rbStats);
    const predicted = predictPlayType(state.Down, state.Distance);

    const yardDelta = carryResult.yards;
    const scoringTeam = state.Possession;
    const oldScore = scoringTeam === "Home"
      ? parseInt(state.HomeScore, 10) || 0
      : parseInt(state.AwayScore, 10) || 0;
    // Home drives left ➡ right (0 -> 100); Away drives right ➡ left (100 -> 0)
      const rawNewBall = state.Possession === "Home"
        ? state.BallOn + yardDelta
        : state.BallOn - yardDelta;
      const newBall = state.Possession === "Home"
        ? Math.min(100, Math.max(0, rawNewBall))
        : Math.max(0, Math.min(100, rawNewBall));
      const touchdown = state.Possession === "Home"
        ? (state.BallOn < 100 && newBall >= 100)
        : (state.BallOn > 0 && newBall <= 0);
      const safety = !touchdown && (state.Possession === "Home" ? rawNewBall <= 0 : rawNewBall >= 100);

      let recordedYards = yardDelta;
      if (touchdown) {
        recordedYards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;
      } else if (safety) {
        recordedYards = state.Possession === "Home" ? -state.BallOn : -(100 - state.BallOn);
      }
    const timeTaken = Math.round(4 + (Math.abs(recordedYards) / 6) * (60 / rbStats.speed));

    if (!touchdown) {
      if(defStarPower){
        tackler = defStarPowerTackler;
      } else{
        tackler = determineTackler(yardDelta);
      }
    }

    let newDown = state.Down;
    let newDist = state.Distance - yardDelta;

    let result = "Normal";
    let recoveredBy = null;
    if (isTwoPtAttempt) {
      const success = touchdown;
      state.Previous = state.BallOn;
      state.BallOn = newBall;
      if (success) {
        if (twoPtTeam === 'Home') {
          state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 2;
        } else {
          state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 2;
        }
      }
      const playLog = logTwoPointPlay(twoPtTeam, playerName, '', recordedYards, success);
      if (playHistory.length >= 2) {
        playHistory[playHistory.length - 2].afterTdPlay = playLog;
      }
      renderPlayTimeline();
      const gameData = {
        gameId: gameId,
        quarter: state.Qtr,
        time: state.Time,
        down: postPATState.down,
        distance: postPATState.distance,
        ballOn: postPATState.ballOn,
        homeScore: state.HomeScore,
        awayScore: state.AwayScore,
        driveStart: postPATState.driveStart,
        previous: postPATState.previous,
        possession: postPATState.possession,
        homeTimeouts: state.HomeTimeouts,
        awayTimeouts: state.AwayTimeouts
      };
      savePlayAndGameWithRetry({ play: playLog, game: gameData });
      state.Down = postPATState.down;
      state.Distance = postPATState.distance;
      state.Possession = postPATState.possession;
      state.BallOn = postPATState.ballOn;
      state.Previous = postPATState.previous;
      state.DriveStart = postPATState.driveStart;
      isTwoPtAttempt = false;
      twoPtTeam = null;
      postPATState = null;
      updateStateUI();
      document.getElementById('result').innerHTML = success ? '<strong>2-point conversion is SUCCESSFUL!</strong>' : '<strong>2-point conversion fails.</strong>';
      afterPlayComplete();
      return;
    }

    if (!touchdown && !safety && tackler && tackler !== "NA") {
      const fum = checkForFumble(playerName, tackler);
      if (fum.fumble) {
        result = "Fumble";
        recoveredBy = fum.recoveredBy;
        if (recoveredBy === tackler) {
          updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, "", yardDelta, tackler, result, predicted, timeTaken, recoveredBy);
          await animatePlay('Run');
          const newPossession = state.Possession === "Home" ? "Away" : "Home";
          updateGameState(1, 10, newPossession, newBall, newBall, newBall, playerName, "", yardDelta, tackler, null, predicted, undefined, recoveredBy);
          applyFatigue(playerName, "Run");
          updateFrontendStats(playerName, recordedYards, result, scoringTeam, tackler, recoveredBy);
          console.log(carryResult);
          document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${carryResult.yards} yards</strong><br/><br/>` +
            `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;
          updateStateUI();
          afterPlayComplete();
          return;
        }
      }
    }

      if (safety) {
        result = "Safety";
        await handleSafety(playerName, "", recordedYards, tackler, predicted, timeTaken, 'Run');
      } else if (touchdown) {
        result = "Touchdown";
        await handleTouchdown(newBall, playerName, "", carryResult, result, predicted, timeTaken);
        recordedYards = carryResult.yards; // handleTouchdown adjusts yards
        await celebrateTouchdown(scoringTeam, oldScore, oldScore + 6);
      } else if (newDist <= 0) {
      result = "First Down";
      newDown = 1;
      const yardsToGoal = state.Possession === "Home" ? 100 - newBall : newBall;
      newDist = yardsToGoal < 10 ? yardsToGoal : 10;
      updateGameState(1, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, "", yardDelta, tackler, result, predicted, timeTaken, recoveredBy);
      await animatePlay('Run');
      playSound("crowdRoar");
    } else {
      newDown++;
      if (newDown > 4) {
        result = "TO on Downs";
        await handleTOonDowns(result, newBall, playerName, "", carryResult, tackler, predicted, timeTaken);
      } else {
        updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, "", yardDelta, tackler, result, predicted, timeTaken, recoveredBy);
        await animatePlay('Run');
      }
    }

      applyFatigue(playerName, "Run");

      updateFrontendStats(playerName, recordedYards, result, scoringTeam, tackler, recoveredBy);
      console.log(carryResult);

      document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${carryResult.yards} yards</strong><br/><br/>` +
        `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;

      updateStateUI();
      //refreshUI();
      afterPlayComplete();
  }

  async function handleTouchdown(newBall, playerName, recName, carryResult, result, predicted, timeTaken, resultArray = {}) {//COMPLETED PASS UPDATES
    pendingFGTeam = state.Possession;
    // Distance covered to reach the goal line differs by team direction
    carryResult.yards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;

    if (state.Possession === "Home") {
      state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 6;
    } else if (state.Possession === "Away") {
      state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 6;
    }
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, recName, carryResult.yards, null, result, predicted, timeTaken);
    let playType = recName === ''? 'Run' : 'Pass';
    await animatePlay(playType, resultArray);
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    const newBallOn = newPossession === "Home" ? 25 : 75;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, playerName, recName, carryResult.yards, null, null, predicted);
  }

  async function handleSafety(playerName, recName, yards, tackler, predicted, timeTaken, playType, resultArray = {}) {
    const scoringTeam = state.Possession === 'Home' ? 'Away' : 'Home';
    if (scoringTeam === 'Home') {
      state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 2;
    } else {
      state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 2;
    }
    const newBall = state.Possession === 'Home' ? 0 : 100;
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, recName, yards, tackler, 'Safety', predicted, timeTaken);
    await animatePlay(playType, resultArray);
    const newPossession = scoringTeam;
    const newBallOn = newPossession === 'Home' ? 25 : 75;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, playerName, recName, yards, null, null, predicted);
  }

  async function handleTOonDowns(result, newBall, playerName, recName, carryResult, tackler, predicted, timeTaken, resultArray = {}) {//COMPLETED PASS UPDATES
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, recName, carryResult.yards, tackler, result, predicted, timeTaken);

    let playType = recName === ''? 'Run' : 'Pass';
    if(resultArray.sack){
      playType = 'Run';
    }
    await animatePlay(playType, resultArray);
    playSound("crowdRoar");
    await animatePlay(playType, resultArray);
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    updateGameState(1, 10, newPossession, newBall, newBall, newBall, playerName, recName, carryResult.yards, tackler, null, predicted);
  }

  function determinePlayOutcome(result, playType, yards, receiver, tackler, recoveredBy, currentDown) {
    const description = result || '';
    let outcome = '';
    let defenseResult = '';
    let turnover = 'No';
    const normalizedPlayType = playType || '';
    const isPass = normalizedPlayType === 'Pass';
    const isRun = normalizedPlayType === 'Run';
    const yardage = typeof yards === 'number' ? yards : Number(yards) || 0;
    const downNumber = typeof currentDown === 'number' ? currentDown : Number(currentDown) || 0;

    if (normalizedPlayType === 'Kick FG') {
      outcome = 'FG Good';
    } else if (normalizedPlayType === 'Kick XP') {
      outcome = 'XP Good';
    } else if (normalizedPlayType === '2PT') {
      outcome = description === '2Pt Successful' ? '2Pt Good' : '2Pt No Good';
    } else if (normalizedPlayType === 'Punt') {
      outcome = 'Normal';
    } else {
      switch (result) {
        case 'Fumble':
          outcome = 'Fumble';
          if (recoveredBy && tackler && recoveredBy === tackler) {
            defenseResult = 'Recovered';
            turnover = 'Yes';
          } else {
            defenseResult = 'Forced';
          }
          break;
        case 'Interception':
          outcome = 'Incompletion';
          defenseResult = 'Intercepted';
          turnover = 'Yes';
          break;
        case 'Incomplete':
          outcome = 'Incompletion';
          defenseResult = 'Incomplete';
          if (downNumber === 4) {
            turnover = 'Yes';
          }
          break;
        case 'Sack':
          outcome = 'Sack';
          defenseResult = 'Sack';
          if (downNumber === 4) {
            turnover = 'Yes';
          }
          break;
        case 'Touchdown':
          outcome = 'Touchdown';
          break;
        case 'Safety':
          outcome = 'Normal';
          defenseResult = 'TFL';
          turnover = 'Yes';
          break;
        case 'TO on Downs':
          turnover = 'Yes';
          if (isPass && receiver) {
            outcome = 'Completion';
            defenseResult = yardage < 0 ? 'TFL' : 'TKL';
          } else {
            outcome = 'Normal';
            defenseResult = yardage < 0 ? 'TFL' : 'TKL';
          }
          break;
        case 'First Down':
        case 'Normal':
        case 'Timeout':
        case 'Kneel':
          if (isPass && receiver) {
            outcome = 'Completion';
          } else {
            outcome = 'Normal';
          }
          break;
        default:
          if (isPass && receiver) {
            outcome = 'Completion';
          } else if (result) {
            outcome = result;
          }
      }
    }

    if (!outcome) outcome = 'Normal';

    if (!defenseResult) {
      if (outcome === 'Completion' || outcome === 'Normal') {
        if (isRun || isPass) {
          defenseResult = yardage < 0 ? 'TFL' : 'TKL';
        }
      } else if (outcome === 'Sack') {
        defenseResult = 'Sack';
      }
    }

    if (outcome === 'Incompletion' && defenseResult === 'TKL') {
      defenseResult = 'Incomplete';
    }

    return { outcome, defenseResult, turnover, description };
  }

  function logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, recName, yards, tackler, result, predicted, qtr, time, recoveredBy) {//MAKE PASS UPDATES
      let playType = 'Run';
      if (recName !== '' || result === 'Sack') {
        playType = 'Pass';
      }
      const { outcome, defenseResult, turnover, description } = determinePlayOutcome(result, playType, yards, recName, tackler, recoveredBy, state.Down);
      const localPlay = {
        Time: time,
        Down: state.Down,
        Distance: state.Distance,
        QTR: qtr,
        Qtr: qtr,
        DriveStart: Number(driveStart),
        Player: playerName,
        Receiver: recName,
        Yards: yards,
        Result: description || 'Normal',
        ResultCategory: outcome,
        DefenseResult: defenseResult,
        Turnover: turnover,
        Description: description,
        NewBallOn: ballOn,
        BallOn: previousBallOn,
        Tackler: tackler,
        RecoveredBy: recoveredBy,
        Possession: poss,
        HomeScore: state.HomeScore,
        AwayScore: state.AwayScore,
        PlayType: playType
      };
      playHistory.push(localPlay);

      return {
        gameid: gameId,
        playid: '',
        time: time,
        qtr: qtr,
        possession: poss,
        down: state.Down,
        distance: state.Distance,
        ballon: state.BallOn,
        playtype: playType,
        player: playerName,
        receiver: recName,
        yards: yards,
        defensepredicted: predicted,
        predictioncorrect: "",
        tackler: tackler,
        result: outcome,
        defenseresult: defenseResult,
        turnover: turnover,
        description: description,
        desc: description,
        recoveredby: recoveredBy,
        newdown: down,
        newdist: distance,
        newballon: ballOn,
        drivestart: state.DriveStart,
        homescore: state.HomeScore,
        awayscore: state.AwayScore
      };
    }

  function updateRunningClock(result) {//MAKE PASS UPDATES
    const stopResults = ['Touchdown','Timeout','Field Goal','Kickoff','Punt','Safety','End of Quarter','TO on Downs','Fumble', 'Interception', 'Incomplete'];
    if (result) {
      runningClock = !stopResults.includes(result);
    }
  }

  function updateGameState(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, recName, yards, tackler, result, predicted, timeTaken, recoveredBy, playData) {
    let playQuarter = state.Qtr;//COMPLETED PASS UPDATES
    let newTime = state.Time;
    if (typeof timeTaken === 'number') {
      if (runningClock) {
        let min = 24;
        let max = 38;
        if(chewClock){
          min = 36;
          max = 40;
        }
        else if(hurryUp){
          min = 4;
          max = 8;
          
        } 
        timeTaken += randomInt(min, max);
        
      }
      newTime = state.Time - timeTaken;
    }
    const logTime = Math.max(newTime, 0);
    let playLog = playData || null;
    if (!playLog && result != null) {
      playLog = logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, recName, yards, tackler, result, predicted, playQuarter, logTime, recoveredBy);
    }

    let nextDown = down;
    let nextDistance = distance;
    let nextPoss = poss;
    let nextBallOn = ballOn;
    let nextDriveStart = driveStart;
    let nextPrev = previousBallOn;

    if (typeof timeTaken === 'number' && newTime <= 0) {
      const curQuarter = playQuarter;
      updateRunningClock('End of Quarter');
      if (curQuarter === 2) {
        playQuarter = 3;
        newTime = 900;
        const startTeam = state.StartingPossession || state.Possession;
        nextPoss = startTeam === 'Home' ? 'Away' : 'Home';
        nextBallOn = nextPoss === 'Home' ? 25 : 75;
        nextDown = 1;
        nextDistance = 10;
        nextDriveStart = nextBallOn;
        nextPrev = nextBallOn;
        state.HomeTimeouts = 3;
        state.AwayTimeouts = 3;
      } else if (curQuarter === 4) {
        if (state.HomeScore !== state.AwayScore) {
          playQuarter = 'FINAL';
          newTime = 0;
        } else {
          playQuarter = 5;
          newTime = 900;
          nextPoss = 'Home';
          nextBallOn = 25;
          nextDown = 1;
          nextDistance = 10;
          nextDriveStart = 25;
          nextPrev = 25;
        }
      } else if (curQuarter === 5) {
        playQuarter = 'FINAL';
        newTime = 0;
      } else {
        playQuarter = curQuarter + 1;
        newTime = 900;
      }
    } else {
      newTime = logTime;
      updateRunningClock(result);
    }

    const possessionChanged = state.Possession !== nextPoss;
    state.Down = nextDown;
    state.Distance = nextDistance;
    state.BallOn = nextBallOn;
    state.Possession = nextPoss;
    state.Previous = nextPrev;
    state.DriveStart = nextDriveStart;
    state.Time = newTime;
    state.Qtr = playQuarter;
    if (possessionChanged) {
      loadPlayers();
    }
    renderPlayTimeline();

    const gameData = {
      gameId: gameId,
      quarter: state.Qtr,
      time: state.Time,
      down: state.Down,
      distance: state.Distance,
      ballOn: state.BallOn,
      homeScore: state.HomeScore,
      awayScore: state.AwayScore,
      driveStart: state.DriveStart,
      previous: state.Previous,
      possession: state.Possession,
      homeTimeouts: state.HomeTimeouts,
      awayTimeouts: state.AwayTimeouts
    };
    savePlayAndGameWithRetry({ play: playLog, game: gameData });
  }

  function nextDrive() {
    pendingFGTeam = null;
    const newPossession = state.Possession === 'Home' ? 'Away' : 'Home';
    const newBallOn = newPossession === 'Home' ? 25 : 75;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, '', '', 0, null, null);
  }

  function goForTwo() {
    if (pendingFGTeam === null) return;
    twoPtTeam = pendingFGTeam;
    pendingFGTeam = null;
    isTwoPtAttempt = true;
    postPATState = {
      down: state.Down,
      distance: state.Distance,
      possession: state.Possession,
      ballOn: state.BallOn,
      previous: state.Previous,
      driveStart: state.DriveStart
    };
    const startBall = twoPtTeam === 'Home' ? 98 : 2;
    updateGameState(1, 2, twoPtTeam, startBall, startBall, startBall, '', '', 0, null, null);
    updateStateUI();
    enablePlayControls();
  }

  function kickFG() {
    const canPAT = pendingFGTeam !== null;
    const inRange = /**state.Down === 4 &&**/ ((state.Possession === 'Home' && state.BallOn >= 65) || (state.Possession === 'Away' && state.BallOn <= 35));
    if (!canPAT && !inRange) {
      updateKickButton();
      return;
    }
    disablePlayControls();
    if (canPAT) {
      const team = pendingFGTeam;
      if (team === 'Home') {
        state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 1;
      } else {
        state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 1;
      }
      const playLog = logFieldGoalPlay(team, true);
      if (playHistory.length >= 2) {
        playHistory[playHistory.length - 2].afterTdPlay = playHistory[playHistory.length - 1];
      }
      renderPlayTimeline();
      pendingFGTeam = null;
      const gameData = {
        gameId: gameId,
        quarter: state.Qtr,
        time: state.Time,
        down: state.Down,
        distance: state.Distance,
        ballOn: state.BallOn,
        homeScore: state.HomeScore,
        awayScore: state.AwayScore,
        driveStart: state.DriveStart,
        previous: state.Previous,
        possession: state.Possession,
        homeTimeouts: state.HomeTimeouts,
        awayTimeouts: state.AwayTimeouts
      };
      savePlayAndGameWithRetry({ play: playLog, game: gameData });
      document.getElementById('result').innerHTML = '<strong>Extra Point is Good!</strong>';
      updateStateUI();
      afterPlayComplete();
      return;
    }

    const scoringTeam = state.Possession;
    if (scoringTeam === 'Home') {
      state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 3;
    } else {
      state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 3;
    }
    const playLog = logFieldGoalPlay(scoringTeam);
    const newPossession = scoringTeam === 'Home' ? 'Away' : 'Home';
    const newBallOn = newPossession === 'Home' ? 25 : 75;
    pendingFGTeam = null;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, '', '', 0, null, null, '', undefined, undefined, playLog);
    updateStateUI();
    document.getElementById('result').innerHTML = '<strong>Field Goal is Good!</strong>';
    afterPlayComplete();
  }

  function punt() {
    if (state.Down !== 4) {
      updatePuntButton();
      return;
    }
    disablePlayControls();
    const kickingTeam = state.Possession;
    const newPossession = kickingTeam === 'Home' ? 'Away' : 'Home';
    let newBallOn = kickingTeam === 'Home' ? state.BallOn + 40 : state.BallOn - 40;
    newBallOn = Math.max(1, Math.min(99, newBallOn));
    const playLog = logPuntPlay(kickingTeam, newBallOn);
    updateRunningClock('Punt');
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, '', '', 0, null, null, '', 6, undefined, playLog);
    updateStateUI();
    document.getElementById('result').innerHTML = '<strong>Punt.</strong>';
    afterPlayComplete();
  }

  function logFieldGoalPlay(poss, isExtraPoint = false) {
    const resultText = isExtraPoint ? 'Extra Point' : 'Field Goal';
    const playType = isExtraPoint ? 'Kick XP' : 'Kick FG';
    const { outcome, defenseResult, turnover, description } = determinePlayOutcome(resultText, playType, 0, '', '', '', state.Down);
    const localPlay = {
      Time: state.Time,
      Down: state.Down,
      Distance: state.Distance,
      Qtr: state.Qtr,
      DriveStart: state.DriveStart,
      Player: '',
      Receiver: '',
      Yards: 0,
      Result: description,
      ResultCategory: outcome,
      DefenseResult: defenseResult,
      Turnover: turnover,
      Description: description,
      NewBallOn: state.BallOn,
      BallOn: state.Previous,
      Tackler: '',
      RecoveredBy: '',
      Possession: poss,
      HomeScore: state.HomeScore,
      AwayScore: state.AwayScore,
      PlayType: playType
    };
    playHistory.push(localPlay);
    renderPlayTimeline();
    return {
      gameid: gameId,
      playid: '',
      time: state.Time,
      qtr: state.Qtr,
      possession: poss,
      down: state.Down,
      distance: state.Distance,
      ballon: state.BallOn,
      playtype: playType,
      player: '',
      receiver: '',
      yards: 0,
      defensepredicted: '',
      predictioncorrect: '',
      tackler: '',
      result: outcome,
      defenseresult: defenseResult,
      turnover: turnover,
      description: description,
      desc: description,
      recoveredby: '',
      newdown: state.Down,
      newdist: state.Distance,
      newballon: state.BallOn,
      drivestart: state.DriveStart,
      homescore: state.HomeScore,
      awayscore: state.AwayScore
    };
  }

  function logTwoPointPlay(poss, player, receiver, yards, success) {
    const resultText = success ? '2Pt Successful' : '2Pt Failed';
    const { outcome, defenseResult, turnover, description } = determinePlayOutcome(resultText, '2PT', yards || 0, receiver || '', '', '', state.Down);
    const localPlay = {
      Time: state.Time,
      Down: state.Down,
      Distance: state.Distance,
      Qtr: state.Qtr,
      DriveStart: state.DriveStart,
      Player: player || '',
      Receiver: receiver || '',
      Yards: yards || 0,
      Result: description,
      ResultCategory: outcome,
      DefenseResult: defenseResult,
      Turnover: turnover,
      Description: description,
      NewBallOn: state.BallOn,
      BallOn: state.Previous,
      Tackler: '',
      RecoveredBy: '',
      Possession: poss,
      HomeScore: state.HomeScore,
      AwayScore: state.AwayScore,
      PlayType: '2PT'
    };
    playHistory.push(localPlay);
    renderPlayTimeline();
    return {
      gameid: gameId,
      playid: '',
      time: state.Time,
      qtr: state.Qtr,
      possession: poss,
      down: state.Down,
      distance: state.Distance,
      ballon: state.BallOn,
      playtype: '2PT',
      player: player || '',
      receiver: receiver || '',
      yards: yards || 0,
      defensepredicted: '',
      predictioncorrect: '',
      tackler: '',
      result: outcome,
      defenseresult: defenseResult,
      turnover: turnover,
      description: description,
      desc: description,
      recoveredby: '',
      newdown: state.Down,
      newdist: state.Distance,
      newballon: state.BallOn,
      drivestart: state.DriveStart,
      homescore: state.HomeScore,
      awayscore: state.AwayScore
    };
  }

  function logPuntPlay(poss, newBallOn) {
    const { outcome, defenseResult, turnover, description } = determinePlayOutcome('Punt', 'Punt', 40, '', '', '', state.Down);
    const localPlay = {
      Time: state.Time,
      Down: state.Down,
      Distance: state.Distance,
      Qtr: state.Qtr,
      DriveStart: state.DriveStart,
      Player: '',
      Receiver: '',
      Yards: 40,
      Result: description,
      ResultCategory: outcome,
      DefenseResult: defenseResult,
      Turnover: turnover,
      Description: description,
      NewBallOn: newBallOn,
      BallOn: state.BallOn,
      Tackler: '',
      RecoveredBy: '',
      Possession: poss,
      HomeScore: state.HomeScore,
      AwayScore: state.AwayScore,
      PlayType: 'Punt'
    };
    playHistory.push(localPlay);
    renderPlayTimeline();
    return {
      gameid: gameId,
      playid: '',
      time: state.Time,
      qtr: state.Qtr,
      possession: poss,
      down: state.Down,
      distance: state.Distance,
      ballon: state.BallOn,
      playtype: 'Punt',
      player: '',
      receiver: '',
      yards: 40,
      defensepredicted: '',
      predictioncorrect: '',
      tackler: '',
      result: outcome,
      defenseresult: defenseResult,
      turnover: turnover,
      description: description,
      desc: description,
      recoveredby: '',
      newdown: 1,
      newdist: 10,
      newballon: newBallOn,
      drivestart: state.DriveStart,
      homescore: state.HomeScore,
      awayscore: state.AwayScore
    };
  }

  function updateKickButton() {
    const btn = document.getElementById('kickButton');
    if (!btn) return;
    const canPAT = pendingFGTeam !== null;
    const canFG = /**state.Down === 4 &&**/ ((state.Possession === 'Home' && state.BallOn >= 65) || (state.Possession === 'Away' && state.BallOn <= 35));
    btn.style.display = '';
    btn.disabled = !(canPAT || canFG);
    const twoBtn = document.getElementById('twoPtButton');
    if (twoBtn) {
      twoBtn.style.display = '';
      twoBtn.disabled = !canPAT;
    }
  }

  function updatePuntButton() {
    const btn = document.getElementById('puntButton');
    if (!btn) return;
    btn.style.display = '';
    btn.disabled = state.Down !== 4;
  }

  function updateStateUI() {//MAKE PASS UPDATES
    console.log(state);
    const downEl = document.getElementById("downDistance");
    downEl.innerText = formatDownDistance(state.Down, state.Distance, state.BallOn, state.Possession);
    const inRedZone = (state.Possession === "Home" && state.BallOn >= 80) || (state.Possession === "Away" && state.BallOn <= 20);
    downEl.classList.toggle('red-zone', inRedZone);
    const ballEl = document.getElementById("ballOn");
    ballEl.innerText = formatBallOn(state.BallOn);
    ballEl.classList.toggle('red-zone', inRedZone);
    document.getElementById("homeName").innerText = state.Home;
    document.getElementById("awayName").innerText = state.Away;
    document.getElementById("homeRecord").innerText = state.HomeRecord || "";
    document.getElementById("awayRecord").innerText = state.AwayRecord || "";
    if (document.getElementById("homeLogo")) document.getElementById("homeLogo").src = state.HomeLogo || "";
    if (document.getElementById("awayLogo")) document.getElementById("awayLogo").src = state.AwayLogo || "";
    document.getElementById("scoreHome").innerText = state.HomeScore;
    document.getElementById("scoreAway").innerText = state.AwayScore;
    document.getElementById("Quarter").innerText = `${formatQuarter(state.Qtr)}`;
    document.getElementById("Time").innerText = formatClock(state.Time);
    updateTimeoutDots("homeTimeouts", state.HomeTimeouts || 0);
    updateTimeoutDots("awayTimeouts", state.AwayTimeouts || 0);
    document.getElementById("homeFootball").style.visibility = state.Possession === "Home" ? "visible" : "hidden";
    document.getElementById("awayFootball").style.visibility = state.Possession === "Away" ? "visible" : "hidden";
    const homeTab = document.getElementById("boxHomeTab");
    const awayTab = document.getElementById("boxAwayTab");
    if (homeTab) homeTab.innerText = state.Home;
    if (awayTab) awayTab.innerText = state.Away;
    const titles = [
      ["homePassingTitle", `${state.Home} Passing`],
      ["homeRushingTitle", `${state.Home} Rushing`],
      ["homeReceivingTitle", `${state.Home} Receiving`],
      ["homeDefensiveTitle", `${state.Home} Defensive`],
      ["awayPassingTitle", `${state.Away} Passing`],
      ["awayRushingTitle", `${state.Away} Rushing`],
      ["awayReceivingTitle", `${state.Away} Receiving`],
      ["awayDefensiveTitle", `${state.Away} Defensive`],
      ["overviewHomePassingTitle", `${state.Home} Passing`],
      ["overviewHomeRushingTitle", `${state.Home} Rushing`],
      ["overviewHomeReceivingTitle", `${state.Home} Receiving`],
      ["overviewAwayPassingTitle", `${state.Away} Passing`],
      ["overviewAwayRushingTitle", `${state.Away} Rushing`],
      ["overviewAwayReceivingTitle", `${state.Away} Receiving`]
    ];
    titles.forEach(([id, text]) => {
      const el = document.getElementById(id);
      if (el) el.innerText = text;
    });
    updateKickButton();
    updatePuntButton();
    highlightTeamRows();
    updateFirstDownLine();
  }

  function highlightTeamRows() {
    document.querySelectorAll('.stats-table tbody').forEach(tb => {
      tb.querySelectorAll('tr').forEach(row => {
        const cell = row.querySelector('td');
        if (cell && cell.textContent.trim().toUpperCase() === 'TEAM') {
          row.classList.add('team-row');
        }
      });
    });
  }

  function updateFirstDownLine() {
    const line = document.getElementById('firstDownLine');
    const field = document.getElementById('field3D');
    if (!line || !field) return;
    const fieldWidth = field.offsetWidth;
    const yardPx = fieldWidth / 120;
    const ball = Number(state.BallOn) || 0;
    const dist = Number(state.Distance) || 0;
    let targetYard = state.Possession === 'Home'
      ? ball + dist
      : ball - dist;
    targetYard = Math.max(0, Math.min(100, targetYard));
    line.style.left = `${(targetYard + 10) * yardPx}px`;
  }

  function celebrateTouchdown(team, oldScore, newScore) {
    return new Promise(resolve => {
      const scoreboard = document.getElementById("scoreboard");
      const banner = document.getElementById("scoreBanner");
      banner.textContent = "TOUCHDOWN!";
      scoreboard.classList.add("scoring");
      banner.classList.add("show");

      setTimeout(() => {
        banner.classList.remove("show");
        const scoreEl = document.getElementById(team === "Home" ? "scoreHome" : "scoreAway");
        let current = oldScore;
        const increment = newScore > oldScore ? 1 : -1;
        const interval = setInterval(() => {
          current += increment;
          scoreEl.innerText = current;
          if (current === newScore) {
            clearInterval(interval);
            scoreboard.classList.remove("scoring");
            resolve();
          }
        }, 100);
      }, 2000);
    });
  }

  function updatePassingStats(qb, yards, completed, intercepted, td, sack) {
    const team = state.Possession;
    let p = passingStats.find(s => s.playername === qb && s.team === team);
    if (!p) {
      p = { playername: qb, team, attempts: 0, completions: 0, yards: 0, tds: 0, ints: 0, sacks: 0, sackYds: 0};
      passingStats.push(p);
    }
    if (sack){
      p.sacks ++;
      p.sackYds += yards;
    } else{
      p.attempts++;
      if (completed) {
        p.completions++;
        p.yards += yards;
        if (td) p.tds++;
      }
      if (intercepted) {
        p.ints++;
      }
    }
  }

  function updateReceivingStats(rec, yards, completed, td, fumble) {
    const team = state.Possession;
    let r = receivingStats.find(s => s.playername === rec && s.team === team);
    if (!r) {
      r = { playername: rec, team, targets: 0, receptions: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
      receivingStats.push(r);
    }
    r.targets++;
    if (completed) {
      r.receptions++;
      r.yards += yards;
      if (td) r.tds++;
      if (yards > r.long) r.long = yards;
    }
    if (fumble) r.fumbles++;
  }

  function updateDefensiveStatsPass(player, opts = {}) {
    if (!player) return;
    const team = state.Possession === 'Home' ? 'Away' : 'Home';
    let d = defensiveStats.find(s => s.playername === player && s.team === team);
    if (!d) {
      d = { playername: player, team, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0, sacks: 0};
      defensiveStats.push(d);
    }
    if (opts.tackle) {
      d.tackles++;
      if ((opts.yards || 0) < 0) d.tfl++;
      if (opts.fumble) {
        d.ff++;
        if (opts.recoveredBy === player) d.fr++;
      }
    }
    if (opts.deflection) {
      d.deflections = (d.deflections || 0) + 1;
    }
    if (opts.interception) {
      d.ints = (d.ints || 0) + 1;
    }
    if (opts.sack){
      d.sacks = (d.sacks || 0) + 1;
    }
  }

  function updateFrontendStats(player, yards, result, team, tackler, recoveredBy) {
    const defTeam = team === "Home" ? "Away" : "Home";
    let p = frontendStats.find(s => s.playername === player && s.team === team);
    if (!p) {
      p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
      frontendStats.push(p);
    }
    p.carries++;
    p.yards += yards;
    if (result == "Touchdown") p.tds++;
    if (result == "Fumble") p.fumbles++;
    if (yards > p.long) p.long = yards;

    if (tackler && tackler !== "NA") {
      let d = defensiveStats.find(s => s.playername === tackler && s.team === defTeam);
      if (!d) {
        d = { playername: tackler, team: defTeam, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0, sacks: 0 };
        defensiveStats.push(d);
      }
      d.tackles++;
      if (yards < 0) d.tfl++;
      if (result == "Fumble") {
        d.ff++;
        if (recoveredBy === tackler) d.fr++;
      }
    }

    renderBoxScore();
  }

  function renderBoxScore() {
    renderPassingTable("Home");
    renderPassingTable("Away");
    renderRushingTable("Home");
    renderRushingTable("Away");
    renderReceivingTable("Home");
    renderReceivingTable("Away");
    renderDefensiveTable("Home");
    renderDefensiveTable("Away");
    sortBoxScoreTables();
    renderGameLeaders();
    renderTeamStats();
  }

  function renderPassingTable(team) {
    const body = document.getElementById(team === "Home" ? "homePassingBody" : "awayPassingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = passingStats.filter(p => p.team === team);
    players.forEach(p => {
      const avg = p.completions ? (p.yards / p.completions).toFixed(1) : "0.0";
      const sacks = p.sacks ? `${p.sacks}-${Math.abs(p.sackYds)}` : '0-0';
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.completions}/${p.attempts}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.ints}</td><td>${sacks}</td><td>0.0</td>`;
      tr.addEventListener('click', () => showPlayerDetails(p.playername));
      body.appendChild(tr);
    });
  }

  function renderRushingTable(team) {
    const body = document.getElementById(team === "Home" ? "homeRushingBody" : "awayRushingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = frontendStats.filter(p => p.team === team).sort((a, b) => b.yards - a.yards);
    let total = { carries: 0, yards: 0, tds: 0, long: 0 };
    players.forEach(p => {
      const avg = p.carries ? (p.yards / p.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.carries}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.long}</td>`;
      tr.addEventListener('click', () => showPlayerDetails(p.playername));
      body.appendChild(tr);
      total.carries += p.carries;
      total.yards += p.yards;
      total.tds += p.tds;
      if (p.long > total.long) total.long = p.long;
    });
    if (players.length) {
      const avgTeam = total.carries ? (total.yards / total.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>TEAM</td><td>${total.carries}</td><td>${total.yards}</td><td>${avgTeam}</td><td>${total.tds}</td><td>${total.long}</td>`;
      body.appendChild(tr);
    }
  }

  function renderReceivingTable(team) {
    const body = document.getElementById(team === "Home" ? "homeReceivingBody" : "awayReceivingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = receivingStats.filter(p => p.team === team).sort((a, b) => b.yards - a.yards);
    let total = { receptions: 0, yards: 0, tds: 0, long: 0, targets: 0 };
    players.forEach(p => {
      const avg = p.receptions ? (p.yards / p.receptions).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.receptions}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.long}</td><td>${p.targets}</td>`;
      tr.addEventListener('click', () => showPlayerDetails(p.playername));
      body.appendChild(tr);
      total.receptions += p.receptions;
      total.yards += p.yards;
      total.tds += p.tds;
      total.targets += p.targets;
      if (p.long > total.long) total.long = p.long;
    });
    if (players.length) {
      const avgTeam = total.receptions ? (total.yards / total.receptions).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>TEAM</td><td>${total.receptions}</td><td>${total.yards}</td><td>${avgTeam}</td><td>${total.tds}</td><td>${total.long}</td><td>${total.targets}</td>`;
      body.appendChild(tr);
    }
  }

  function renderDefensiveTable(team) {
    const body = document.getElementById(team === "Home" ? "homeDefensiveBody" : "awayDefensiveBody");
    if (!body) return;
    body.innerHTML = "";
    const players = defensiveStats.filter(p => p.team === team).sort((a, b) => b.tackles - a.tackles);
    players.forEach(p => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.tackles}</td><td>${p.tfl}</td><td>${p.sacks || 0}</td><td>${p.ff}</td><td>${p.fr}</td><td>${p.ints || 0}</td><td>${p.deflections || 0}</td>`;
      tr.addEventListener('click', () => showPlayerDetails(p.playername));
      body.appendChild(tr);
    });
  }

  function sortBoxScoreTables() {
    document.querySelectorAll('#boxscore .stats-table tbody').forEach(tbody => {
      const table = tbody.closest('table');
      const sortIndex = table.classList.contains('defensive-table') ? 1 : 2;
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const teamRow = rows.find(r => r.firstElementChild && r.firstElementChild.textContent.trim().toUpperCase() === 'TEAM');
      const playerRows = teamRow ? rows.filter(r => r !== teamRow) : rows;
      playerRows.sort((a, b) => {
        const aVal = parseFloat(a.children[sortIndex].textContent) || 0;
        const bVal = parseFloat(b.children[sortIndex].textContent) || 0;
        return bVal - aVal;
      });
      tbody.innerHTML = '';
      playerRows.forEach(r => tbody.appendChild(r));
      if (teamRow) tbody.appendChild(teamRow);
    });
  }

  function applyFatigue(playerName, actionType) {
    const drain = drainSettings[actionType] || 0;
    playerTraits[playerName].fatigue = playerTraits[playerName].fatigue - drain;
  }

  // === FRONTEND LOGIC ENGINE ===
  function simulateSingleCarry(stats) {
    const modLog = [];
    let roll = 0;
    let yards = 0;
    if (autoStuff) {
      // integer in [-2, 2]
      yards = Math.floor(Math.random() * 5) - 2;
      modLog.push('Auto Stuff!');
      if (yards <= 2) yards += applyTraitEffect("Vision", stats.vision + Math.min(0, stats.fatigue), true, modLog);
      if (yards <= 4) yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
    } else{
      roll = getModifiedRoll(stats, modLog);
      roll = maybeBoostRollForAcceleration(roll, stats, modLog);
      yards = getYardageOutcome(roll, stats, modLog);
      if (offStarPower) {
        yards += Math.floor(playerTraits[stats.name].offStars);
        modLog.push(`Yard +`+Math.floor(playerTraits[stats.name].offStars)+` : offStarPower`);
      }
      if (defStarPower) {
        yards += - Math.floor(playerTraits[defStarPowerTackler].defStars);
        modLog.push(`Yard -`+Math.floor(playerTraits[defStarPowerTackler].defStars)+` : defStarPower`);
      }
      yards = maybeAvoidLoss(yards, stats, modLog);
      yards = adjustChunkRunForSpeed(yards, stats, modLog, false);

      if (yards <= 2) yards += applyTraitEffect("Vision", stats.vision + Math.min(0, stats.fatigue), true, modLog);
      if (yards <= 4) yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
      if (yards >= 3 && yards <= 4) yards += applyTraitEffect("Acceleration", stats.acceleration + Math.min(0, stats.fatigue), true, modLog);
      if (yards > 0 && yards < 10) yards += applyTraitEffect("Juke", stats.juke + Math.min(0, stats.fatigue), true, modLog);
    }

    return { name: stats.name, roll, yards, modLog };
  }

  function getModifiedRoll(stats, modLog) {
    // Float base roll from 0 to ~100.000
    let baseRoll = Math.random() * 100; // 0–100 float

    if (autoRelease) {
      baseRoll += 8;
      modLog.push('Pre +7 Auto Release');
    }

    // Calculate vision mod
    let visionMod = (stats.vision + Math.min(0, stats.fatigue) - 60) * 0.055;
    modLog.push(`Pre ${visionMod > 0 ? "+" : ""}${visionMod.toFixed(1)} Vision`);

    const modified = baseRoll + visionMod;

    // Clamp final result to valid roll range
    return Math.max(0, Math.min(100, modified));
  }

  function maybeBoostRollForAcceleration(roll, stats, modLog) {
    if (roll < 88) { //CHANGE - solid gain or less. No hard code
      const chance = (stats.acceleration + Math.min(0, stats.fatigue) - 60) / 200;
      if (Math.random() < Math.max(0, chance)) {
        const maxBoost = Math.floor((stats.acceleration + Math.min(0, stats.fatigue) - 60) / 4);
        const boost = randomInt(1, Math.min(10, maxBoost));
        modLog.push(`Pre +${boost} Accel (Boost Roll)`);
        return Math.min(99, roll + boost);
      }
    }
    return roll;
  }

  function getYardageOutcome(roll, stats, modLog) {
    if (roll >= 100){
      return getStrictBreakawayYards(stats, modLog);
    }
    for (const r of rollThresholds) {
      if (roll >= r.rollMin && roll < r.rollMax) {
        if (r.label === "RunType_Breakaway") {
          return getStrictBreakawayYards(stats, modLog);
        }
        return randomInt(r.minYards, r.maxYards);
      }
    }
    return 0;
  }

  function getStrictBreakawayYards(stats, modLog) {
    const baseRoll = Math.floor(Math.random() * 100);
    const speedBoost = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) * 0.3);
    const adjustedRoll = Math.min(100, baseRoll + Math.max(0, speedBoost));
    if (speedBoost !== 0) modLog.push(`Pre +${speedBoost} Speed`);

    let cumulative = 0;
    for (const range of breakawaySettings) {
      if (adjustedRoll >= 100){
        return randomInt(81, 100);
      }
      cumulative += range.percentage;
      if (adjustedRoll <= cumulative) {
        return randomInt(range.minYards, range.maxYards);
      }
    }
    return 16;
  }

  function maybeAvoidLoss(yards, stats, modLog) {
    if (yards < 0) {
      const power = stats.size + stats.strength + Math.min(0, stats.fatigue);
      const chanceToAvoid = power / 2.2; //CHANGE - no hard code
      if (Math.random() < chanceToAvoid / 100) {
        const newYards = randomInt(1, 2);
        modLog.push(`Loss Avoided by Power → ${newYards} yds`);
        return newYards;
      }
    }
    return yards;
  }

  function adjustChunkRunForSpeed(yards, stats, modLog, yac) {
    if (yac && yards >= 5){
      const bonus = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) / 5); //CHANGE no hard code
      if (bonus !== 0) modLog.push(`Yard ${bonus > 0 ? "+" : ""}${bonus} Speed`);
      return yards + bonus;
    }
    else if (yards >= 10 && yards <= 15) { //CHANGE no hard code
      const bonus = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) / 10); //CHANGE no hard code
      if (bonus !== 0) modLog.push(`Yard ${bonus > 0 ? "+" : ""}${bonus} Speed`);
      return yards + bonus;
    }
    return yards;
  }

  function applyTraitEffect(traitName, traitValue, condition, modLog) {
    if (!condition) return 0;
    const deviation = traitValue - 60;
    const triggerChance = Math.abs(deviation) / 100;
    if (Math.random() < triggerChance) {
      const effect = Math.sign(deviation) * Math.min(2, Math.floor(Math.abs(deviation) / 15));
      if (effect !== 0) {
        modLog.push(`Yard ${effect > 0 ? "+" : ""}${effect} ${traitName}`);
        return effect;
      }
    }
    return 0;
  }

  function average(a, b) {
    return (a + b) / 2;
  }

  function randomInt(min, max) {
    const range = max - min + 1;
    if (range <= 0) throw new Error("Invalid range");

    const maxUint32 = 0xFFFFFFFF;
    const bucketSize = Math.floor(maxUint32 / range);
    const maxAcceptable = bucketSize * range;

    let rand;
    const uint32 = new Uint32Array(1);

    do {
      window.crypto.getRandomValues(uint32);
      rand = uint32[0];
    } while (rand >= maxAcceptable);

    return min + (rand % range);
  }

  function predictPlayType(down, distance) {
    return "Run"; // Stub, can be enhanced with real logic
  }


  //UI Functions ONLY - ANIMATIONS BELOW!
  function show3DDrive(startYard, prevYard, currentYard, playType = 'Run', passResult) {
    passComplete = passResult.completed;
    passIntercepted = passResult.intercepted;
    if(passResult.sack){
      playType = 'Run';
    }

    const touchdown = passResult.touchdown || (playType === 'Run' && (currentYard <= 0 || currentYard >= 100));

    // Hide previous play visuals until we know which animation to show
    const runDiv = document.getElementById("play");
    const passDiv = document.getElementById("arc-container");
    runDiv.style.display = "none";
    passDiv.style.display = "none";

    return new Promise(resolve => {
      const field = document.getElementById("field3D");
      const fieldWidth = field.offsetWidth;
      const yardPx = fieldWidth / 120;
      const fieldHeight = field.offsetHeight;
      //const canvas = document.getElementById("arcCanvas");
      //canvas.width = fieldWidth;
      //canvas.height = fieldHeight;
      const endYard = touchdown ? (state.Possession === 'Home' ? 102 : -2) : currentYard;
      let drivePX = (startYard + 10) * yardPx;
      let prevPX = (prevYard + 10) * yardPx;
      let currPX = (endYard + 10) * yardPx;
      let drive = document.getElementById("drive");
      // Handle drive line based on direction
      if (state.Possession == "Home") {
        drive.style.left = `${drivePX}px`;
        drive.style.right = `auto`;
        drive.style.width = `${prevPX - drivePX}px`;
        drive.style.setProperty('--left-pos', `-5px`);
      } else {
        drivePX = fieldWidth - drivePX;
        prevPX = fieldWidth - prevPX;
        currPX = fieldWidth - currPX;
        drive.style.left = `auto`;
        drive.style.right = `${drivePX}px`;
        drive.style.width = `${prevPX - drivePX}px`;
        drive.style.setProperty('--left-pos', `${prevPX - drivePX - 5}px`);
      }

      const lastPlay = runDiv;
      // Fade out old marker
      lastPlay.style.opacity = 0;// lastDot.style.opacity = arrow.style.opacity = 0;
      setTimeout(() => {
        // Prepare the element for the upcoming animation
        if (playType === 'Run') {
          runDiv.style.display = "block";
        } else {
          passDiv.style.display = "block";
        }
        lastPlay.style.transition = "none";
        lastPlay.style.backgroundColor = playType === 'Pass' ? 'transparent' : 'black';
        lastPlay.style.width = `0px`;
        lastPlay.style.opacity = 1;
        if(state.Possession == "Home"){
          lastPlay.style.left = `${prevPX}px`;
        } else{
          lastPlay.style.right = `${prevPX}px`;
        }

        if (playType === 'Run') {
          lastPlay.style.top = `50%`;
          lastPlay.style.height = `6px`;
          setTimeout(() => {
            // Animate based on direction of play
            if (state.Possession == "Home") {
              lastPlay.style.transition = "width 1.4s ease, left 1.4s ease";
              lastPlay.style.left = `${prevPX}px`;
              lastPlay.style.right = `auto`;
              lastPlay.style.width = `${currPX - prevPX}px`;
              if(lastPlay.classList.contains("swapped")){                
                lastPlay.classList.remove("swapped");
              }
            } else {
              lastPlay.style.transition = "width 1.4s ease, right 1.4s ease";
              lastPlay.style.left = `auto`;
              lastPlay.style.right = `${prevPX}px`;
              lastPlay.style.width = `${(currPX - prevPX)}px`;
              if(!lastPlay.classList.contains("swapped")){                
                lastPlay.classList.add("swapped");
              }
            }
            const playWidth = currPX - prevPX;
            if (playWidth <= 0) {
              // No animation to wait for; resolve manually after short delay
              setTimeout(() => {
                resolve();
              }, 300);
            } else {
              const onEnd = (e) => {
                if (e.propertyName === 'width') {
                  lastPlay.removeEventListener('transitionend', onEnd);
                  resolve();
                }
              };
              lastPlay.addEventListener('transitionend', onEnd);
            }
          }, 50);
        } else {
          //lastDot.style.opacity = arrow.style.opacity = 0;
          buildArcWithArrow(passDiv, {
            prevPx: prevPX,
            currPx: currPX,
            rise: 150,
            direction: "up"
          }).then(resolve);
        }
      }, 400);
    });
  }
  function show3DDriveOLD(startYard, prevYard, currentYard, playType = 'Run', passResult) {
    passComplete = passResult.completed;
    passIntercepted = passResult.intercepted;
    return new Promise(resolve => {
      const field = document.getElementById("field3D");
      const fieldWidth = field.offsetWidth;
      const yardPx = fieldWidth / 120;
      const fieldHeight = field.offsetHeight;
      const canvas = document.getElementById("arcCanvas");
      canvas.width = fieldWidth;
      canvas.height = fieldHeight;
      let drivePX = (startYard + 10) * yardPx;
      let prevPX = (prevYard + 10) * yardPx;
      let currPX = (currentYard + 10) * yardPx;
      let drive = document.getElementById("drive3D");
      const driveDot = drive.querySelector(".drive-dot");
      // Handle drive line based on direction
      if (state.Possession == "Home") {
        drive.style.left = `${drivePX}px`;
        drive.style.right = `auto`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = 'auto';
        driveDot.style.left = '0';
      } else {
        drivePX = fieldWidth - drivePX;
        prevPX = fieldWidth - prevPX;
        currPX = fieldWidth - currPX;
        drive.style.left = `auto`;
        drive.style.right = `${drivePX}px`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = '0';
        driveDot.style.left = 'auto';
      }

      const lastPlay = document.getElementById("lastPlayMarker");
      const lastDot = lastPlay.querySelector(".last-dot");
      const arrow = lastPlay.querySelector(".drive-arrow");
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.style.opacity = 0; // Hide previous catch point immediately
      // Fade out old marker
      lastPlay.style.opacity = lastDot.style.opacity = arrow.style.opacity = 0;
      setTimeout(() => {
        lastPlay.style.transition = "none";
        lastPlay.style.backgroundColor = playType === 'Pass' ? 'transparent' : 'black';
        lastPlay.style.width = `0px`;
        lastPlay.style.opacity = 1;
        lastDot.style.opacity = 1;
        arrow.style.opacity = 1;
        if(state.Possession == "Home"){
          lastDot.style.left = `0`;
          lastDot.style.right = `auto`;
          lastPlay.style.left = `${prevPX}px`;
          arrow.style.left = `0px`;
          arrow.style.right = `auto`;
        } else{
          lastDot.style.right = `0`;
          lastDot.style.left = `auto`;
          lastPlay.style.right = `${prevPX}px`;
          arrow.style.left = `auto`;
          arrow.style.right = `0px`;
        }

        if (playType === 'Run') {
          lastPlay.style.top = `50%`;
          lastPlay.style.height = `6px`;
          arrow.style.top = `-10px`;
          setTimeout(() => {
            // Animate based on direction of play
            if (state.Possession == "Home") {
              lastPlay.style.transition = "width 1.4s ease, left 1.4s ease";
              arrow.style.transition = "left 1.4s ease";
              lastPlay.style.left = `${prevPX}px`;
              lastPlay.style.right = `auto`;
              lastPlay.style.width = `${currPX - prevPX}px`;
              arrow.style.left = `${(currPX - prevPX) - 10}px`;
              arrow.style.right = `auto`;
              arrow.style.transform = "rotate(0deg)";
            } else {
              lastPlay.style.transition = "width 1.4s ease, right 1.4s ease";
              arrow.style.transition = "right 1.4s ease";
              lastPlay.style.left = `auto`;
              lastPlay.style.right = `${prevPX}px`;
              lastPlay.style.width = `${(currPX - prevPX)}px`;
              arrow.style.left = `auto`;
              arrow.style.right = `${(currPX - prevPX) - 10}px`;
              arrow.style.transform = "rotate(180deg)";
            }
            const playWidth = currPX - prevPX;
            if (playWidth <= 0) {
              // No animation to wait for; resolve manually after short delay
              setTimeout(() => {
                resolve();
              }, 300);
            } else {
              const onEnd = (e) => {
                if (e.propertyName === 'width') {
                  lastPlay.removeEventListener('transitionend', onEnd);
                  resolve();
                }
              };
              lastPlay.addEventListener('transitionend', onEnd);
            }
          }, 50);
        } else {
          lastDot.style.opacity = arrow.style.opacity = 0;
          drawPassArc(prevPX, currPX, passComplete).then(resolve);
        }
      }, 400);
    });
  }
  function drawPassArc(x0, x1, passComplete = true) {
    return new Promise(resolve => {
      const canvas = document.getElementById("arcCanvas");
      const ctx = canvas.getContext("2d");
      const yardPx = canvas.width / 120;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const midX = (x0 + x1) / 2;
      const y = canvas.height * 0.45;
      const peakHeight = Math.min(yardPx * 12, Math.max(yardPx * 5, (x1 - x0) * 0.6));
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.lineCap = "round";
      let offset = 0;
        let startTime = null;
        function animate(time) {
          if (!startTime) startTime = time;
          const elapsed = time - startTime;
        offset -= 2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setLineDash([10, 5]);
        ctx.lineDashOffset = offset;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.quadraticCurveTo(midX, y - peakHeight, x1, y);
        ctx.stroke();
        if (elapsed < 3000) {
          requestAnimationFrame(animate);
        } else {
          showCatchPoint(x1, y, passComplete).then(resolve);
        }
      }
      requestAnimationFrame(animate);
    });
  }
  function showCatchPoint(x, y, complete = true) {
    return new Promise(resolve => {
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.innerText = complete ? "➤" : "✖";
      catchPoint.style.left = `${x - 8}px`;
      catchPoint.style.top = `${y - 20}px`;
      catchPoint.style.opacity = 0;
      // Fade in and stay
      setTimeout(() => {
        catchPoint.style.transition = "opacity 0.8s ease";
        catchPoint.style.opacity = 1;
        setTimeout(resolve, 800);
      }, 100);
    });
  }
  //New UI functionality
  function makeArcPath(x, y, width, rise, direction = "up") {
    let x0 = x, y0 = y;
    let x1 = x + width, y1 = y;           // baseline anchors  
    let cx = x + width / 2;  
    const cy = direction === "up" ? y - rise : y + rise;
    if(state.Possession == "Away"){
      x0 = width-1;
      x1 = 0;
      cx = x + width / 2;
    }
    return {
      d: `M ${x0} ${y0} Q ${cx} ${cy} ${x1} ${y1}`,
      start: { x: x0, y: y0 },
      end:   { x: x1, y: y1 }
    };
  }
  function buildArcWithArrow(mountEl, { prevPx, currPx, rise, direction = "up" }) {
    return new Promise(resolve => {
      let width = Math.abs(currPx - prevPx);

      const cs = getComputedStyle(document.documentElement);
      const stroke  = parseFloat(cs.getPropertyValue('--arc-width')) || 5;
      const arrowL  = parseFloat(cs.getPropertyValue('--arrow-l'))   || 12;
      // Duration/easing: read from CSS so both animations match
      const durStr  = cs.getPropertyValue('--arc-duration').trim() || '1.2s';
      const durMs   = durStr.endsWith('ms') ? parseFloat(durStr) : parseFloat(durStr) * 1000;
      const easing  = 'ease-out';
      // Pad so the arrow never clips
      let pad = 1;//Math.ceil(Math.max(stroke, arrowL) + 6);
      if(state.Possession == "Away"){
        pad = -1;
      }
      const baselineY = rise + pad;
      const vbWidth = width + pad * 2;
      const vbHeight = baselineY + rise + pad;
      // Build SVG
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${vbWidth} ${vbHeight}`);
      svg.setAttribute("width", vbWidth);
      svg.setAttribute("height", vbHeight);
      const { d, start, end } = makeArcPath(pad, baselineY, width, rise, direction);

      // Compute control point (same as makeArcPath) for reversed path’s angle math
      const cx = pad + width / 2;
      const cy = direction === "up" ? baselineY - rise : baselineY + rise;

      // Use drawStart/drawEnd so the rest of your code remains unchanged
      const drawStart = start;
      const drawEnd   = end;

      const path = document.createElementNS(svgNS, "path");
      path.setAttribute("class", "arc-path");
      path.setAttribute("pathLength", "1");
      path.setAttribute("d", d);
      svg.appendChild(path);
      // Position the arc container at the previous pixel location so the
      // animation originates from the correct spot on the field.
      mountEl.style.position = "absolute";
      if(state.Possession == "Home"){
        mountEl.style.left = `${prevPx}px`;
        mountEl.style.right = ``;
      } else{
        mountEl.style.right = `${prevPx}px`;
        mountEl.style.left = ``;
      }
      // Ensure the container dimensions match the SVG so width animates
      // from the starting point instead of the page origin.
      mountEl.style.width = `${vbWidth}px`;
      mountEl.style.height = `${vbHeight}px`;
      // Mount SVG
      mountEl.innerHTML = "";
      mountEl.appendChild(svg);
      // Arrow element: tip aligned, oriented along the straight chord
      const angleRad = Math.atan2(end.y - start.y, end.x - start.x);
      const angleDeg = angleRad * (180 / Math.PI);
      const arrow = document.createElement("span");
      arrow.className = "arc-arrow";
      arrow.style.setProperty("--angle", `${angleDeg}deg`);
      let arrowLeft = end.x + 12;
      if(state.Possession == "Away"){
        arrowLeft = end.x - 12;
      }
      // Start at the base (start anchor), end at the right anchor
      arrow.style.left = `${arrowLeft}px`;
      arrow.style.top  = `${start.y}px`;
      mountEl.appendChild(arrow);
      // ✅ Circle at the starting point
      const circle = document.createElement("span");
      circle.className = "arc-start";
      circle.style.left = `${start.x}px`;
      circle.style.top  = `${start.y}px`;
      mountEl.appendChild(circle);
      // Animate the arrow's position in sync with the path draw
      const animation = arrow.animate(
        [
          { left: `${start.x}px`, top: `${start.y}px` },
          { left: `${arrowLeft}px`, top: `${end.y}px` }
        ],
        { duration: durMs, easing, fill: 'forwards' }
      );
      animation.finished.then(() => resolve());
    });
  }
  // Example: arc 280px wide, 60px rise, arrow travels left -> right while the arc draws
  /**buildArcWithArrow(document.getElementById("arc-container"), startYd, {
    width: 300,
    rise: 150,
    direction: "up"
  });**/
  

  function playSound(id) {
    const sound = document.getElementById(id);
    if (sound) {
      sound.currentTime = 0; // rewind
      sound.play();
    }
  }

  function openClockModal() {
    const modal = document.getElementById('clockModal');
    if (modal) modal.classList.add('open');
    updateClockToggles();
  }

  function closeClockModal() {
    const modal = document.getElementById('clockModal');
    if (modal) modal.classList.remove('open');
  }

  function updateClockToggles() {
    const hurryBtn = document.getElementById('hurryUpToggle');
    const chewBtn = document.getElementById('chewClockToggle');
    if (hurryBtn) {
      hurryBtn.classList.toggle('active', hurryUp);
      hurryBtn.textContent = `Hurry Up: ${hurryUp ? 'On' : 'Off'}`;
    }
    if (chewBtn) {
      chewBtn.classList.toggle('active', chewClock);
      chewBtn.textContent = `Chew Clock: ${chewClock ? 'On' : 'Off'}`;
    }
  }

  function toggleHurryUp() {
    hurryUp = !hurryUp;
    if (hurryUp) {
      chewClock = false;
    }
    updateClockToggles();
  }

  function toggleChewClock() {
    chewClock = !chewClock;
    if (chewClock) {
      hurryUp = false;
    }
    updateClockToggles();
  }

  async function spikeBall() {
    console.log('Spike Ball selected');
    const qbSlot = currentFormation.find(f => f.position === 'QB');
    const qbName = qbSlot ? qbSlot.player : null;
    if (!qbName) return;
    disablePlayControls();
    closeClockModal();

    const predicted = predictPlayType(state.Down, state.Distance);
    const yardDelta = 0;
    const newBall = state.BallOn;
    const newDist = state.Distance;
    let newDown = state.Down + 1;
    const timeTaken = 1;

    if (newDown > 4) {
      await handleTOonDowns('TO on Downs', newBall, qbName, 'No One', { yards: yardDelta }, null, predicted, timeTaken, { completed: false });
    } else {
      updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, 'No One', yardDelta, null, 'Incomplete', predicted, timeTaken);
      await animatePlay('Pass', { completed: false });
    }

    applyFatigue(qbName, 'Throw');

    document.getElementById('result').innerHTML = `<strong>${qbName}</strong> spikes the ball.`;
    updateStateUI();
    afterPlayComplete();
  }

  async function kneel() {
    console.log('Kneel selected');
    const qbSlot = currentFormation.find(f => f.position === 'QB');
    const qbName = qbSlot ? qbSlot.player : null;
    if (!qbName) return;
    disablePlayControls();
    closeClockModal();

    const predicted = predictPlayType(state.Down, state.Distance);
    const yardDelta = -1;
    const rawNewBall = state.Possession === 'Home' ? state.BallOn + yardDelta : state.BallOn - yardDelta;
    const newBall = state.Possession === 'Home' ? Math.max(0, rawNewBall) : Math.min(100, rawNewBall);
    const newDist = state.Distance - yardDelta;
    let newDown = state.Down + 1;
    const timeTaken = 3;

    if (newDown > 4) {
      await handleTOonDowns('TO on Downs', newBall, qbName, '', { yards: yardDelta }, 'NA', predicted, timeTaken);
    } else {
      updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, '', yardDelta, 'NA', 'Kneel', predicted, timeTaken);
      await animatePlay('Run');
    }

    applyFatigue(qbName, 'Run');
    updateFrontendStats(qbName, yardDelta, 'Kneel', state.Possession, 'NA', null);

    document.getElementById('result').innerHTML = `<strong>${qbName}</strong> kneels for -1 yard.`;
    updateStateUI();
    afterPlayComplete();
  }

  // On load
  refreshUI().catch(console.error);
</script>
