<script>
  let state = {};
  let players = [];
  let playerTraits = {};
  let rollThresholds = [];
  let breakawaySettings = [];
  let drainSettings = {};  // Populated from backend on load
  let frontendStats = [];
  let gameId = 1;
  let playHistory = [];
  let savedFormations = [];
  let currentFormation = [];
  let defensiveFormation = [];
  let autoStuff = false;
  let autoRelease = false;
  let offStarPower = false;
  let defStarPower = false;
  const RUN_POSITIONS = ['WR1','RB1','RB2','QB'];
  let selectedPlayer = null;


  function updateStickyOffsets() {
    const scoreboard = document.getElementById('scoreboard');
    if (!scoreboard) return;
    const root = document.documentElement;
    root.style.setProperty('--scoreboardHeight', scoreboard.offsetHeight + 'px');
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const target = document.getElementById(btn.dataset.tab);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.boxscore-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.boxscore-pill').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.boxscore-subtab').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const target = document.getElementById(btn.dataset.subtab);
        if (target) target.classList.add('active');
      });
    });
      updateStickyOffsets();
      window.addEventListener('resize', updateStickyOffsets);
      loadGamesList();
      const backBtn = document.getElementById('backButton');
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          document.getElementById('gameUI').style.display = 'none';
          document.getElementById('gameList').style.display = 'block';
          backBtn.style.display = 'none';
          loadGamesList();
        });
      }
      document.querySelectorAll('.formation-slot').forEach(slot => {
        slot.addEventListener('dragover', allowDrop);
        slot.addEventListener('drop', handleDrop);
        slot.addEventListener('click', () => moveSelectedTo(slot));
        slot.addEventListener('touchstart', e => { e.preventDefault(); moveSelectedTo(slot); });
      });
      const bench = document.getElementById('bench');
      if (bench) {
        bench.addEventListener('dragover', allowDrop);
        bench.addEventListener('drop', handleDrop);
        bench.addEventListener('click', e => { if (e.target === bench) moveSelectedTo(bench); });
        bench.addEventListener('touchstart', e => { if (e.target === bench) { e.preventDefault(); moveSelectedTo(bench); } });
      }
      const clearBtn = document.getElementById('clearFormation');
      if (clearBtn) clearBtn.addEventListener('click', clearFormation);
      const saveBtn = document.getElementById('saveFormation');
      if (saveBtn) saveBtn.addEventListener('click', saveFormation);
      const openBtn = document.getElementById('openFormation');
      if (openBtn) openBtn.addEventListener('click', () => {
        document.getElementById('formationModal').classList.add('open');
      });
      const closeBtn = document.getElementById('closeFormation');
      if (closeBtn) closeBtn.addEventListener('click', () => {
        document.getElementById('formationModal').classList.remove('open');
      });
      const losBtn = document.getElementById('viewLOS');
      if (losBtn) losBtn.addEventListener('click', () => {
        renderLOS();
        document.getElementById('losModal').classList.add('open');
      });
      const closeLOS = document.getElementById('closeLOS');
      if (closeLOS) closeLOS.addEventListener('click', () => {
        document.getElementById('losModal').classList.remove('open');
      });
    });

  function loadGamesList() {
    google.script.run.withSuccessHandler(renderGameCards).getGamesList();
  }

  function renderGameCards(games) {
    const container = document.getElementById('gameList');
    if (!container) return;
    container.innerHTML = '';
    games.forEach(g => {
      const card = document.createElement('div');
      const id = Number(g.GameId);
      card.className = 'game-card';
      card.innerHTML = `
        <div class="team-row">
          <img class="team-logo" src="${g.HomeLogo || ''}" alt="Home Logo" />
          <div class="team-name-wrap">
            <span class="team-name">${g.Home}</span>
            <span class="poss-indicator">${g.Possession === 'Home' ? 'üèà' : ''}</span>
          </div>
          <span class="team-score">${g.HomeScore}</span>
          <span class="team-time">${g.Time || ''}</span>
          <span class="team-down">${formatDownDistance(g.Down, g.Distance)}</span>
        </div>
        <div class="team-row">
          <img class="team-logo" src="${g.AwayLogo || ''}" alt="Away Logo" />
          <div class="team-name-wrap">
            <span class="team-name">${g.Away}</span>
            <span class="poss-indicator">${g.Possession === 'Away' ? 'üèà' : ''}</span>
          </div>
          <span class="team-score">${g.AwayScore}</span>
          <span class="team-qtr">${formatQuarter(g.Qtr)}</span>
          <span class="team-ball">${formatBallOnForPoss(g.BallOn, g.Possession)}</span>
        </div>
        `;
      card.addEventListener('click', () => {
        gameId = id;
        refreshUI(id);
        document.getElementById('gameList').style.display = 'none';
        document.getElementById('gameUI').style.display = 'block';
        const backBtn = document.getElementById('backButton');
        if (backBtn) backBtn.style.display = 'block';
        updateStickyOffsets();
      });
      container.appendChild(card);
    });
  }

  function toggleMenu() {
    document.getElementById('playerMenu').classList.toggle('open');
  }

  function renderPlayerCards() {
    const menu = document.getElementById('playerMenu');
    if (!menu) return;
    menu.innerHTML = '';
    Object.values(playerTraits).forEach(p => {
      const card = document.createElement('div');
        card.className = 'player-card';
        card.innerHTML = `
              <h4>${p.name}</h4>
              <div>Size: ${p.size}</div>
              <div>Strength: ${p.strength}</div>
              <div>Speed: ${p.speed}</div>
              <div>Stamina: ${p.stamina}</div>
              <div>Run Blocking: ${p.runBlocking}</div>
              <div>Pass Protect: ${p.passProtect}</div>
              <div>Run Stop: ${p.runStop}</div>
              <div>Tackling: ${p.tackling}</div>
              <div>Run Def: ${p.runDef}</div>
              <div>Tackle Chance: ${p.tackleChance}</div>
            `;
        menu.appendChild(card);
      });
    }

  // === GAME SETUP ===
  function refreshUI(selectedGameId) {
    state = {};
    players = [];
    playerTraits = {};
    rollThresholds = [];
    breakawaySettings = [];
    drainSettings = {};  // Populated from backend on load
    frontendStats = [];
    playHistory = [];
    if (typeof selectedGameId !== 'undefined') {
      gameId = selectedGameId;
    }
    google.script.run.withSuccessHandler(function (gameState) {
      console.log("‚úÖ Loaded game state");
      if (!gameState) {
        console.error(`‚ùå No game state returned for game ${gameId}`);
        return;
      }
      state = gameState;
      updateStateUI();

      loadPlayersTraits(function () {
        loadSettings(function () {
          google.script.run
            .withSuccessHandler(async function (data) {
              console.log("‚úÖ Loaded play history", data);
              playHistory = data;
              frontendStats = [];

              playHistory.forEach(play => {
                if (!play.Player || !play.PlayType || play.PlayType !== 'Run') return;

                const player = play.Player;
                const team = play.Possession || '';
                const yards = parseFloat(play.Yards) || 0;
                const td = play.Result === "Touchdown";
                const fumble = play.Result === "Fumble";

                let p = frontendStats.find(s => s.playername === player && s.team === team);
                if (!p) {
                  p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
                  frontendStats.push(p);
                }

                p.carries++;
                p.yards += yards;
                if (td) p.tds++;
                if (fumble) p.fumbles++;
                if (yards > p.long) p.long = yards;
              });

              renderPlayTimeline();

              updateFatigueBasedOnStatsOnInitialLoad();
              renderBoxScore();
              await animatePlay();
            })
            .withFailureHandler(function (error) {
              console.error("‚ùå Failed to load play history:", error.message);
            })
            .getPlayHistory(gameId);
        });
      });
    }).withFailureHandler(function (error) {
      console.error("‚ùå Failed to load game state:", error.message);
    }).getGameState(gameId);

  }


  function updateFatigueBasedOnStatsOnInitialLoad() {
    if (playerTraits && drainSettings && drainSettings.Run) {
      for (let i = 0; i < frontendStats.length; i++) {
        const stat = frontendStats[i];
        const pt = playerTraits[stat.playername];
        if (pt) {
          pt.fatigue = pt.stamina - (stat.carries * drainSettings.Run);
        }
      }
    }
  }
  async function animatePlay() { 
    // use current game state to drive the animation in the proper direction
    await show3DDrive(state.DriveStart, state.Previous, state.BallOn, playType = 'run', passComplete = true); //CHANGE - dont hardcode run and pass
  }

  function formatBallOn(yard) {
    yard = parseInt(yard, 10);
    // Convert field position to the perspective of the team with the ball
    const perspectiveYard = state.Possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatBallOnForPoss(yard, possession) {
    yard = parseInt(yard, 10);
    const perspectiveYard = possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatDownDistance(down, distance) {
    const ord = ["1st", "2nd", "3rd", "4th"];
    const d = ord[down - 1] || down + "th";
    return `${d} & ${distance}`;
  }

  function formatQuarter(qtr) {
    const ord = ["1st", "2nd", "3rd", "4th", "OT"];
    return ord[qtr - 1] || qtr + "th";
  }

  function computeDriveInfo() {
    let plays = 0;
    for (let i = playHistory.length - 1; i >= 0; i--) {
      const play = playHistory[i];
      if (play.Possession !== state.Possession) break;
      plays++;
    }
    const yards = state.Possession === "Home"
      ? state.BallOn - state.DriveStart
      : state.DriveStart - state.BallOn;
    //return { plays, yards: Math.max(0, yards) };
    document.getElementById("driveInfo").innerText = `${plays} plays, ${yards} yards`;
  }

  function updateTimeoutDots(id, count) {
    const container = document.getElementById(id);
    if (!container) return;
    const dots = Array.from(container.children);
    dots.forEach((dot, idx) => {
      dot.classList.toggle('used', idx >= count);
    });
  }

  function buildPlayText(play) {
    let text = `<strong>${play.Player}</strong> runs for ${play.Yards} Yards.`;

    if (play.Result && play.Result !== "Normal") {
      if (play.Result === "Touchdown") {
        text += ` <span style="color:green; font-weight:bold;">${play.Result}!</span>`;
      } else if (play.Result === "TO on Downs") {
        text += ` <span style="color:red; font-weight:bold;">${play.Result}!</span>`;
      } else {
        text += ` <strong>${play.Result}!</strong>`;
      }
    }

    text += ` Tackle made at the ${formatBallOnForPoss(play.NewBallOn, play.Possession)} by ${play.Tackler}.`;

    return text;
  }

  function renderPlayTimeline() {
    const container = document.getElementById("playTimeline");
    if (!container) return;
    container.innerHTML = "";
    playHistory.forEach(play => {
      if (!play.Player || (play.PlayType && play.PlayType !== "Run")) return;
      const time = new Date(play.Timestamp).toLocaleTimeString();
      const downDist = formatDownDistance(play.Down, play.Distance);
      const text = buildPlayText(play);
      const offense = play.Possession || "";
      const score = `${play.homeScore !== undefined ? play.homeScore : state.HomeScore} - ${play.AwayScore !== undefined ? play.AwayScore : state.AwayScore}`;
      const row = document.createElement("tr");
      row.innerHTML = `<td>${time}</td><td><div class="play-down">${downDist}</div><div class="play-text">${text}</div></td><td>${offense}</td><td>${score}</td>`;
      container.appendChild(row);
    });
    computeDriveInfo();
  }

    function loadPlayers() {
      populateBench();
      updateRunnerDropdown();
    }

    function populateBench() {
      const bench = document.getElementById('bench');
      if (!bench) return;
      // Clear existing assignments
      document.querySelectorAll('.formation-slot').forEach(slot => {
        if (slot.firstChild) {
          bench.appendChild(slot.firstChild);
        }
        slot.classList.remove('filled');
        slot.dataset.player = '';
      });
      bench.innerHTML = '';
      const teamName = state[state.Possession];
      Object.entries(playerTraits).forEach(([name, traits]) => {
        if (traits.team === teamName) {
          const item = document.createElement('div');
          let posClass = traits.position.toLowerCase();
          if (posClass === 'te' || posClass === 'ol') posClass = 'teol';
          item.className = `player-item ${posClass}`;
          item.draggable = true;
          item.dataset.player = name;
          //const initials = name.split(' ').map(n => n[0]).join('');
          item.textContent = name;
          item.title = `${name} (${traits.position})`;
          item.addEventListener('dragstart', dragStart);
          item.addEventListener('touchstart', selectPlayer);
          item.addEventListener('click', selectPlayer);
          bench.appendChild(item);
        }
      });
    }

    function updateRunnerDropdown() {
      const dropdown = document.getElementById('playerDropdown');
      if (!dropdown) return;
      dropdown.innerHTML = '';
      const teamName = state[state.Possession];
      let runners = [];
      if (currentFormation.length > 0) {
        runners = currentFormation
          .filter(f => RUN_POSITIONS.includes(f.position) && f.player)
          .map(f => f.player)
          .filter(name => playerTraits[name] && playerTraits[name].team === teamName);
      }
      runners.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.text = name;
        dropdown.appendChild(option);
      });
    }

    function dragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.player);
    }

    function allowDrop(e) {
      e.preventDefault();
    }

    function handleDrop(e) {
      e.preventDefault();
      const name = e.dataTransfer.getData('text/plain');
      const item = document.querySelector(`.player-item[data-player="${name}"]`);
      if (!item) return;
      const source = item.parentElement;
      const target = e.currentTarget;
      if (target.classList.contains('formation-slot')) {
        if (target.firstChild) {
          document.getElementById('bench').appendChild(target.firstChild);
        }
        target.appendChild(item);
        target.classList.add('filled');
        target.dataset.player = name;
      } else {
        target.appendChild(item);
      }
      if (source.classList && source.classList.contains('formation-slot')) {
        source.classList.remove('filled');
        source.dataset.player = '';
      }
    }

    function selectPlayer(e) {
      e.preventDefault();
      e.stopPropagation();
      const item = e.currentTarget;
      if (selectedPlayer === item) {
        item.classList.remove('selected');
        selectedPlayer = null;
        return;
      }
      if (selectedPlayer) selectedPlayer.classList.remove('selected');
      selectedPlayer = item;
      item.classList.add('selected');
    }

    function moveSelectedTo(target) {
      if (!selectedPlayer) return;
      const bench = document.getElementById('bench');
      const item = selectedPlayer;
      const source = item.parentElement;
      if (target.classList.contains('formation-slot')) {
        if (target.firstChild) {
          bench.appendChild(target.firstChild);
          target.classList.remove('filled');
        }
        target.appendChild(item);
        target.classList.add('filled');
        target.dataset.player = item.dataset.player;
      } else {
        target.appendChild(item);
      }
      if (source.classList && source.classList.contains('formation-slot')) {
        source.classList.remove('filled');
        source.dataset.player = '';
      }
      item.classList.remove('selected');
      selectedPlayer = null;
    }

    function clearFormation() {
      const bench = document.getElementById('bench');
      if (!bench) return;
      document.querySelectorAll('.formation-slot').forEach(slot => {
        if (slot.firstChild) {
          bench.appendChild(slot.firstChild);
        }
        slot.classList.remove('filled');
        slot.dataset.player = '';
      });
      currentFormation = [];
      selectedPlayer = null;
      document.querySelectorAll('.player-item.selected').forEach(p => p.classList.remove('selected'));
      updateRunnerDropdown();
    }

    function saveFormation() {
      const required = ['QB','TEOL2','TEOL3','TEOL4'];
      const formation = [];
      let valid = true;
      document.querySelectorAll('.formation-slot').forEach(slot => {
        const pos = slot.dataset.position;
        const playerEl = slot.querySelector('.player-item');
        if (playerEl) {
          formation.push({ position: pos, player: playerEl.dataset.player });
        } else if (required.includes(pos)) {
          valid = false;
        }
      });
      if (!valid) {
        alert('Please fill all required positions');
        return;
      }
      currentFormation = formation;
      updateRunnerDropdown();
      savedFormations.push(formation);
      console.log('Saved formation', formation);
      setDefensiveFormation();
      document.getElementById('formationModal').classList.remove('open');
    }

  function setDefensiveFormation() {
    const offenseTeam = state[state.Possession];
    const defenseTeam = state[state.Possession === 'Home' ? 'Away' : 'Home'];
    const defenders = Object.values(playerTraits).filter(p => p.team === defenseTeam);

    const dbs = defenders.filter(p => p.defPos === 'DB').sort((a,b) => b.defStars - a.defStars);
    const dls = defenders.filter(p => p.defPos === 'DL').sort((a,b) => b.defStars - a.defStars);
    const lbs = defenders.filter(p => p.defPos === 'LB').sort((a,b) => b.defStars - a.defStars);
    const safeties = defenders.filter(p => p.defPos === 'S').sort((a,b) => b.defStars - a.defStars);

    const wrs = currentFormation
      .filter(f => f.position.startsWith('WR'))
      .map(f => ({ pos: f.position, player: f.player, stars: playerTraits[f.player]?.offStars || 0 }))
      .sort((a,b) => b.stars - a.stars);

    const olPositions = ['TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].filter(pos =>
      currentFormation.some(f => f.position === pos)
    );

    // DB assignments ‚Äì fill from DBs, then LBs if needed
    const dbAssignments = [];
    for (let i = 0; i < wrs.length; i++) {
      let player = null;
      if (dbs.length > 0) {
        player = dbs.shift();
      } else if (lbs.length > 0) {
        player = lbs.shift();
      }
      dbAssignments.push({
        position: `DB${i+1}`,
        player: player ? player.name : '',
        align: wrs[i].pos
      });
    }

    // DL assignments ‚Äì fill from DLs, then LBs if needed
    const dlAssignments = [];
    olPositions.forEach((ol, i) => {
      let player = null;
      if (dls.length > 0) {
        player = dls.shift();
      } else if (lbs.length > 0) {
        player = lbs.shift();
      }
      dlAssignments.push({
        position: `DL${i+1}`,
        player: player ? player.name : '',
        align: ol
      });
    });

    let assigned = dbAssignments.length + dlAssignments.length;
    let remaining = Math.max(0, 7 - assigned);

    const predicted = predictPlayType(state.Down, state.Distance).toLowerCase();
    const lbAssignments = [];
    const backs = ['QB','RB1','RB2'];
    let lbNeeded = (predicted === 'run' || predicted === 'screen') ? backs.length : 2;
    lbNeeded = Math.min(lbNeeded, remaining);
    for (let i = 0; i < lbNeeded; i++) {
      let player = null;
      if (lbs.length > 0) {
        player = lbs.shift();
      } else if (dls.length > 0) {
        player = dls.shift();
      } else if (dbs.length > 0) {
        player = dbs.shift();
      }
      if (player) {
        const assignment = { position: `LB${i+1}`, player: player.name };
        if (predicted === 'run' || predicted === 'screen') {
          assignment.align = backs[i];
        }
        lbAssignments.push(assignment);
      }
    }

    assigned += lbAssignments.length;
    remaining = Math.max(0, 7 - assigned);

    // Safety ‚Äì pick from safeties, then remaining LBs, DBs, DLs
    let safetyAssignment = null;
    if (remaining > 0) {
      if (safeties.length > 0) {
        const s = safeties.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (lbs.length > 0) {
        const s = lbs.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (dbs.length > 0) {
        const s = dbs.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (dls.length > 0) {
        const s = dls.shift();
        safetyAssignment = { position: 'S', player: s.name };
      }
    }

    defensiveFormation = [...dbAssignments, ...dlAssignments, ...lbAssignments];
    if (safetyAssignment) defensiveFormation.push(safetyAssignment);
    console.log('Defensive formation', defensiveFormation);
  }

  function renderLOS() {
    const field = document.getElementById('losField');
    if (!field) return;
    field.innerHTML = '';
    const line = document.createElement('div');
    line.className = 'los-line';
    field.appendChild(line);

    const safetyRow = document.createElement('div');
    safetyRow.className = 'los-row';
    defensiveFormation.filter(d => d.position.startsWith('S')).forEach(s => {
      safetyRow.appendChild(createLosPlayer(s.player));
    });
    if (safetyRow.childElementCount > 0) field.appendChild(safetyRow);

    const lbRow = document.createElement('div');
    lbRow.className = 'los-row';
    defensiveFormation.filter(d => d.position.startsWith('LB')).forEach(lb => {
      lbRow.appendChild(createLosPlayer(lb.player));
    });
    if (lbRow.childElementCount > 0) field.appendChild(lbRow);

    const grid = document.createElement('div');
    grid.className = 'los-grid';
    const losSlots = ['WR1','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5','WR2','WR3'];
    losSlots.forEach(pos => {
      const col = document.createElement('div');
      col.className = 'los-col';
      const def = defensiveFormation.find(d => d.align === pos);
      col.appendChild(createLosPlayer(def ? def.player : ''));
      const off = currentFormation.find(f => f.position === pos);
      col.appendChild(createLosPlayer(off ? off.player : ''));
      grid.appendChild(col);
    });
    field.appendChild(grid);

    const qbRow = document.createElement('div');
    qbRow.className = 'los-row';
    const qb = currentFormation.find(f => f.position === 'QB');
    qbRow.appendChild(createLosPlayer(qb ? qb.player : ''));
    field.appendChild(qbRow);

    const rbRow = document.createElement('div');
    rbRow.className = 'los-row';
    ['RB1','RB2'].forEach(pos => {
      const p = currentFormation.find(f => f.position === pos);
      rbRow.appendChild(createLosPlayer(p ? p.player : ''));
    });
    field.appendChild(rbRow);
  }

  function createLosPlayer(name) {
    const div = document.createElement('div');
    div.className = name ? 'los-player' : 'los-player empty';
    if (name) {
      div.textContent = name;
    }
    return div;
  }

  function loadPlayersTraits(callback) {
    google.script.run.withSuccessHandler(function (playerData) {
      console.log("‚úÖ Loaded player traits");
      const playerMap = {};
      playerData.forEach(player => {
        playerTraits[player.name] = player;
      });
      loadPlayers();
      renderPlayerCards();
      if (callback) callback();
    }).getPlayerTraits();
  }

  function loadSettings(callback) {
    console.log("‚úÖ Loaded drain settings");
    google.script.run.withSuccessHandler(function (data) {
      rollThresholds = data.thresholds;
      breakawaySettings = data.breakaways;
      drainSettings = data.staminaDrains;
      if (callback) callback();
    }).getFrontendSettings();
  }

  function runBlockVsRunDef(ballCarrier) {
    let dlTotal = 0;
    let olTotal = 0;

    defensiveFormation.forEach(f => {
      if (f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))) {
        dlTotal += Number(playerTraits[f.player]?.runDef || 0);
      }
    });

    currentFormation.forEach(f => {
      if (!f.player) return;
      const pos = f.position;
      const isOffensive = ['QB','RB1','RB2','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].includes(pos);
      if (isOffensive && f.player !== ballCarrier) {
        olTotal += Number(playerTraits[f.player]?.runDef || 0);
      }
    });

    const total = dlTotal + olTotal;
    if (total <= 0) return { defenseWins: false };
    const roll = Math.floor(Math.random() * total) + 1;
    return { defenseWins: roll <= dlTotal };
  }

  function tryAutoStuff() {
    let starPower = 0;
    defensiveFormation.forEach(f => {
      if (f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))) {
        starPower += Number(playerTraits[f.player]?.defStars || 0);
      }
    });
    const roll = Math.floor(Math.random() * 100) + 1;
    return roll <= starPower;
  }

  function tryAutoRelease(ballCarrier) {
    let starPower = 0;
    currentFormation.forEach(f => {
      if (!f.player) return;
      const pos = f.position;
      const isOffensive = ['QB','RB1','RB2','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].includes(pos);
      if (isOffensive && f.player !== ballCarrier) {
        starPower += Number(playerTraits[f.player]?.offStars || 0);
      }
    });
    const roll = Math.floor(Math.random() * 100) + 1;
    return roll <= starPower;
  }

  function rollOffStarPower(ballCarrier) {
    const stars = Number(playerTraits[ballCarrier]?.offStars || 0);
    const threshold = Math.pow(stars, 2);
    const roll = Math.random() * 100;
    return roll <= threshold;
  }

  function rollDefStarPower() {
    const candidates = defensiveFormation
      .filter(f => f.player && (f.position.startsWith('DL') || f.position.startsWith('LB')))
      .map(f => {
        const stars = Number(playerTraits[f.player]?.defStars || 0);
        return { name: f.player, stars, weight: Math.pow(stars, 2) };
      });

    const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
    if (totalWeight <= 0) return false;

    let roll = Math.random() * totalWeight;
    let chosen = candidates[0];
    for (const c of candidates) {
      if (roll < c.weight) {
        chosen = c;
        break;
      }
      roll -= c.weight;
    }

    const threshold = Math.pow(chosen.stars, 2);
    const activationRoll = Math.random() * 100;
    return activationRoll <= threshold;
  }

  function afterPlayComplete() {
    autoStuff = false;
    autoRelease = false;
    offStarPower = false;
    defStarPower = false;
  }

  // === MAIN PLAY ===
  async function runPlay() {
    const playerName = document.getElementById("playerDropdown").value;
    if (!playerName) return;

    let tackler = "NA";

    offStarPower = rollOffStarPower(playerName);
    defStarPower = rollDefStarPower();

    const blockResult = runBlockVsRunDef(playerName);
    if (blockResult.defenseWins) {
      autoStuff = tryAutoStuff();
    } else {
      autoRelease = tryAutoRelease(playerName);
    }

    const rbStats = playerTraits[playerName];
    const carryResult = simulateSingleCarry(rbStats);
    const predicted = predictPlayType(state.Down, state.Distance);

    const yardDelta = carryResult.yards;
    const scoringTeam = state.Possession;
    const oldScore = scoringTeam === "Home"
      ? parseInt(state.HomeScore, 10) || 0
      : parseInt(state.AwayScore, 10) || 0;
    // Home drives left ‚û° right (0 -> 100); Away drives right ‚û° left (100 -> 0)
    const newBall = state.Possession === "Home"
      ? Math.min(100, Math.max(0, state.BallOn + yardDelta))
      : Math.max(0, Math.min(100, state.BallOn - yardDelta));
    const touchdown = state.Possession === "Home"
      ? (state.BallOn < 100 && newBall >= 100)
      : (state.BallOn > 0 && newBall <= 0);

    let newDown = state.Down;
    let newDist = state.Distance - yardDelta;

    let result = "Normal";

    let recordedYards = yardDelta;
    if (touchdown) {
      result = "Touchdown";
      await handleTouchdown(newBall, playerName, carryResult, result, tackler, predicted);
      recordedYards = carryResult.yards; // handleTouchdown adjusts yards
      await celebrateTouchdown(scoringTeam, oldScore, oldScore + 6);
    } else if (newDist <= 0) {
      result = "First Down";
      newDown = 1;
      newDist = 10;
      updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, yardDelta, tackler, result, predicted);
      await animatePlay();
      playSound("crowdRoar");
    } else {
      newDown++;
      if (newDown > 4) {
      result = "TO on Downs";
        await handleTOonDowns(result, newBall, playerName, carryResult, result, tackler, predicted);
      } else {
        updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, yardDelta, tackler, result, predicted);
        await animatePlay();
      }
    }

    applyFatigue(playerName, "Run");

    updateFrontendStats(playerName, recordedYards, result, state.Possession);
    console.log(carryResult);

    document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${carryResult.yards} yards</strong><br/><br/>` +
      `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;

    updateStateUI();
    //refreshUI();
    afterPlayComplete();
  }

  async function handleTouchdown(newBall, playerName, carryResult, result, tackler, predicted) {
    // Distance covered to reach the goal line differs by team direction
    carryResult.yards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;
    if (state.Possession === "Home") {
      state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 6;
    } else if (state.Possession === "Away") {
      state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 6;
    }
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, carryResult.yards, tackler, result, predicted);

    await animatePlay();
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    const newBallOn = newPossession === "Home" ? 25 : 75;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, playerName, carryResult.yards, tackler, null, predicted);
    loadPlayers();
  }

  async function handleTOonDowns(result, newBall, playerName, carryResult, result, tackler, predicted) {
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, carryResult.yards, tackler, result, predicted);

    await animatePlay();
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    updateGameState(1, 10, newPossession, newBall, newBall, newBall, playerName, carryResult.yards, tackler, null, predicted);
    loadPlayers();
  }

  function logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, yards, tackler, result, predicted) {
    const timestamp = new Date().toISOString();
    const localPlay = {
      Timestamp: timestamp,
      Down: state.Down,
      Distance: state.Distance,
      Player: playerName,
      Yards: yards,
      Result: result || "Normal",
      NewBallOn: ballOn,
      Tackler: tackler,
      Possession: state.Possession,
      HomeScore: state.HomeScore,
      AwayScore: state.AwayScore,
      PlayType: "Run"
    };
    playHistory.push(localPlay);

    google.script.run.logPlayHistory({
      gameid: gameId,
      timestamp: timestamp, // ‚úÖ passed in from frontend
      possession: state.Possession,
      down: state.Down,
      distance: state.Distance,
      ballon: state.BallOn,
      playtype: "Run",
      player: playerName,
      yards: yards,
      defensepredicted: predicted,
      predictioncorrect: "",
      tackler: tackler,
      result: result,
      desc: "",
      newdown: down,
      newdist: distance,
      newballon: ballOn,
      drivestart: state.DriveStart,
      homescore: state.HomeScore,
      awayscore: state.AwayScore
    });
  }

  function updateGameState(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, yards, tackler, result, predicted) {
    if(result != null){
      logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, yards, tackler, result, predicted);
    }
    state.Down = down;
    state.Distance = distance;
    state.BallOn = ballOn
    state.Possession = poss;
    state.Previous = previousBallOn;
    state.DriveStart = driveStart;
    renderPlayTimeline();

    google.script.run.pushGameState({
      gameId: gameId,
      quarter: state.Qtr,
      down: state.Down,
      distance: state.Distance,
      ballOn: state.BallOn,
      homeScore: state.HomeScore,
      awayScore: state.AwayScore,
      driveStart: state.DriveStart,
      previous: state.Previous,
      possession: state.Possession
    });
  }

  function updateStateUI() {
    console.log(state);
    document.getElementById("downDistance").innerText = formatDownDistance(state.Down, state.Distance);
    document.getElementById("ballOn").innerText = formatBallOn(state.BallOn);
    document.getElementById("homeName").innerText = state.Home;
    document.getElementById("awayName").innerText = state.Away;
    document.getElementById("homeRecord").innerText = state.HomeRecord || "";
    document.getElementById("awayRecord").innerText = state.AwayRecord || "";
    if (document.getElementById("homeLogo")) document.getElementById("homeLogo").src = state.HomeLogo || "";
    if (document.getElementById("awayLogo")) document.getElementById("awayLogo").src = state.AwayLogo || "";
    document.getElementById("scoreHome").innerText = state.HomeScore;
    document.getElementById("scoreAway").innerText = state.AwayScore;
    document.getElementById("Quarter").innerText = `${formatQuarter(state.Qtr)}`;
    document.getElementById("Time").innerText = `${state.Time}`;
    updateTimeoutDots("homeTimeouts", state.HomeTimeouts || 0);
    updateTimeoutDots("awayTimeouts", state.AwayTimeouts || 0);
    document.getElementById("homeFootball").style.visibility = state.Possession === "Home" ? "visible" : "hidden";
    document.getElementById("awayFootball").style.visibility = state.Possession === "Away" ? "visible" : "hidden";
    const homeTab = document.getElementById("boxHomeTab");
    const awayTab = document.getElementById("boxAwayTab");
    if (homeTab) homeTab.innerText = state.Home;
    if (awayTab) awayTab.innerText = state.Away;
    const titles = [
      ["homePassingTitle", `${state.Home} Passing`],
      ["homeRushingTitle", `${state.Home} Rushing`],
      ["homeReceivingTitle", `${state.Home} Receiving`],
      ["awayPassingTitle", `${state.Away} Passing`],
      ["awayRushingTitle", `${state.Away} Rushing`],
      ["awayReceivingTitle", `${state.Away} Receiving`],
      ["overviewHomePassingTitle", `${state.Home} Passing`],
      ["overviewHomeRushingTitle", `${state.Home} Rushing`],
      ["overviewHomeReceivingTitle", `${state.Home} Receiving`],
      ["overviewAwayPassingTitle", `${state.Away} Passing`],
      ["overviewAwayRushingTitle", `${state.Away} Rushing`],
      ["overviewAwayReceivingTitle", `${state.Away} Receiving`]
    ];
    titles.forEach(([id, text]) => {
      const el = document.getElementById(id);
      if (el) el.innerText = text;
    });
    highlightTeamRows();
    updateFirstDownLine();
  }

  function highlightTeamRows() {
    document.querySelectorAll('.stats-table tbody').forEach(tb => {
      tb.querySelectorAll('tr').forEach(row => {
        const cell = row.querySelector('td');
        if (cell && cell.textContent.trim().toUpperCase() === 'TEAM') {
          row.classList.add('team-row');
        }
      });
    });
  }

  function updateFirstDownLine() {
    const line = document.getElementById('firstDownLine');
    const field = document.getElementById('field3D');
    if (!line || !field) return;
    const fieldWidth = field.offsetWidth;
    const yardPx = fieldWidth / 120;
    const ball = Number(state.BallOn) || 0;
    const dist = Number(state.Distance) || 0;
    let targetYard = state.Possession === 'Home'
      ? ball + dist
      : ball - dist;
    targetYard = Math.max(0, Math.min(100, targetYard));
    line.style.left = `${(targetYard + 10) * yardPx}px`;
  }

  function celebrateTouchdown(team, oldScore, newScore) {
    return new Promise(resolve => {
      const scoreboard = document.getElementById("scoreboard");
      const banner = document.getElementById("scoreBanner");
      banner.textContent = "TOUCHDOWN!";
      scoreboard.classList.add("scoring");
      banner.classList.add("show");

      setTimeout(() => {
        banner.classList.remove("show");
        const scoreEl = document.getElementById(team === "Home" ? "scoreHome" : "scoreAway");
        let current = oldScore;
        const increment = newScore > oldScore ? 1 : -1;
        const interval = setInterval(() => {
          current += increment;
          scoreEl.innerText = current;
          if (current === newScore) {
            clearInterval(interval);
            scoreboard.classList.remove("scoring");
            resolve();
          }
        }, 100);
      }, 2000);
    });
  }

  function updateFrontendStats(player, yards, result, team) {

    if(result == "Touchdown" || result == "TO on Downs"){
      if(team == "Home"){
        team = "Away";
      } else{
        team = "Home";
      }
    }
    let p = frontendStats.find(s => s.playername === player && s.team === team);
    if (!p) {
      p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
      frontendStats.push(p);
    }
    p.carries++;
    p.yards += yards;
    if (result == "Touchdown") p.tds++;
    if (yards > p.long) p.long = yards;

    renderBoxScore();
  }

  function renderBoxScore() {
    renderRushingTable("Home");
    renderRushingTable("Away");
    sortBoxScoreTables();
  }

  function renderRushingTable(team) {
    const body = document.getElementById(team === "Home" ? "homeRushingBody" : "awayRushingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = frontendStats.filter(p => p.team === team).sort((a, b) => b.yards - a.yards);
    let total = { carries: 0, yards: 0, tds: 0, long: 0 };
    players.forEach(p => {
      const avg = p.carries ? (p.yards / p.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.carries}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.long}</td>`;
      body.appendChild(tr);
      total.carries += p.carries;
      total.yards += p.yards;
      total.tds += p.tds;
      if (p.long > total.long) total.long = p.long;
    });
    if (players.length) {
      const avgTeam = total.carries ? (total.yards / total.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>TEAM</td><td>${total.carries}</td><td>${total.yards}</td><td>${avgTeam}</td><td>${total.tds}</td><td>${total.long}</td>`;
      body.appendChild(tr);
    }
  }

  function sortBoxScoreTables() {
    document.querySelectorAll('#boxscore .stats-table tbody').forEach(tbody => {
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const teamRow = rows.find(r => r.firstElementChild && r.firstElementChild.textContent.trim().toUpperCase() === 'TEAM');
      const playerRows = teamRow ? rows.filter(r => r !== teamRow) : rows;
      playerRows.sort((a, b) => {
        const aYards = parseFloat(a.children[2].textContent) || 0;
        const bYards = parseFloat(b.children[2].textContent) || 0;
        return bYards - aYards;
      });
      tbody.innerHTML = '';
      playerRows.forEach(r => tbody.appendChild(r));
      if (teamRow) tbody.appendChild(teamRow);
    });
  }

  function applyFatigue(playerName, actionType) {
    const drain = drainSettings[actionType] || 0;
    playerTraits[playerName].fatigue = playerTraits[playerName].fatigue - drain;
  }

  // === FRONTEND LOGIC ENGINE ===
  function simulateSingleCarry(stats) {
    const modLog = [];
    let roll = getModifiedRoll(stats, modLog);
    roll = maybeBoostRollForAcceleration(roll, stats, modLog);
    let yards = getYardageOutcome(roll, stats, modLog);
    yards = maybeAvoidLoss(yards, stats, modLog);
    yards = adjustChunkRunForSpeed(yards, stats, modLog);

    if (yards <= 2) yards += applyTraitEffect("Vision", stats.vision + Math.min(0, stats.fatigue), true, modLog);
    if (yards <= 4) yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
    if (yards >= 3 && yards <= 4) yards += applyTraitEffect("Acceleration", stats.acceleration + Math.min(0, stats.fatigue), true, modLog);
    if (yards > 0 && yards < 10) yards += applyTraitEffect("Juke", stats.juke + Math.min(0, stats.fatigue), true, modLog);
    if (offStarPower) {
      yards += 5;
      modLog.push(`Yard +5 : offStarPower`);
    }
    if (defStarPower) {
      yards += -5;
      modLog.push(`Yard -5 : defStarPower`);
    }

    return { name: stats.name, roll, yards, modLog };
  }

  function getModifiedRoll(stats, modLog) {
    // Float base roll from 1.000 to ~100.000
    let baseRoll = Math.random() * 100; // 1‚Äì100 float

    if (autoRelease) {
      baseRoll += 7;
      modLog.push('Pre +7 Auto Release');
    }
    if (autoStuff) {
      baseRoll -= 10;
      modLog.push('Pre -10 Auto Stuff');
    }

    // Calculate vision mod
    let visionMod = (stats.vision + Math.min(0, stats.fatigue) - 60) * 0.055;
    modLog.push(`Pre ${visionMod > 0 ? "+" : ""}${visionMod.toFixed(1)} Vision`);

    const modified = baseRoll + visionMod;

    // Clamp final result to valid roll range
    return Math.max(1, Math.min(100, modified));
  }

  function maybeBoostRollForAcceleration(roll, stats, modLog) {
    if (roll < 88) { //CHANGE - solid gain or less. No hard code
      const chance = (stats.acceleration + Math.min(0, stats.fatigue) - 60) / 200;
      if (Math.random() < Math.max(0, chance)) {
        const maxBoost = Math.floor((stats.acceleration + Math.min(0, stats.fatigue) - 60) / 4);
        const boost = randomInt(1, Math.min(10, maxBoost));
        modLog.push(`Pre +${boost} Accel (Boost Roll)`);
        return Math.min(99, roll + boost);
      }
    }
    return roll;
  }

  function getYardageOutcome(roll, stats, modLog) {
    if (roll >= 100){
      return getStrictBreakawayYards(stats, modLog);
    }
    for (const r of rollThresholds) {
      if (roll >= r.rollMin && roll < r.rollMax) {
        if (r.label === "RunType_Breakaway") {
          return getStrictBreakawayYards(stats, modLog);
        }
        return randomInt(r.minYards, r.maxYards);
      }
    }
    return 0;
  }

  function getStrictBreakawayYards(stats, modLog) {
    const baseRoll = Math.floor(Math.random() * 100);
    const speedBoost = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) * 0.3);
    const adjustedRoll = Math.min(100, baseRoll + Math.max(0, speedBoost));
    if (speedBoost !== 0) modLog.push(`Pre +${speedBoost} Speed`);

    let cumulative = 0;
    for (const range of breakawaySettings) {
      if (adjustedRoll >= 100){
        return randomInt(81, 100);
      }
      cumulative += range.percentage;
      if (adjustedRoll <= cumulative) {
        return randomInt(range.minYards, range.maxYards);
      }
    }
    return 16;
  }

  function maybeAvoidLoss(yards, stats, modLog) {
    if (yards < 0) {
      const power = stats.size + stats.strength + Math.min(0, stats.fatigue);
      const chanceToAvoid = power / 2.2; //CHANGE - no hard code
      if (Math.random() < chanceToAvoid / 100) {
        const newYards = randomInt(1, 2);
        modLog.push(`Loss Avoided by Power ‚Üí ${newYards} yds`);
        return newYards;
      }
    }
    return yards;
  }

  function adjustChunkRunForSpeed(yards, stats, modLog) {
    if (yards >= 10 && yards <= 15) { //CHANGE no hard code
      const bonus = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) / 10); //CHANGE no hard code
      if (bonus !== 0) modLog.push(`Yard ${bonus > 0 ? "+" : ""}${bonus} Speed`);
      return yards + bonus;
    }
    return yards;
  }

  function applyTraitEffect(traitName, traitValue, condition, modLog) {
    if (!condition) return 0;
    const deviation = traitValue - 60;
    const triggerChance = Math.abs(deviation) / 100;
    if (Math.random() < triggerChance) {
      const effect = Math.sign(deviation) * Math.min(2, Math.floor(Math.abs(deviation) / 15));
      if (effect !== 0) {
        modLog.push(`Yard ${effect > 0 ? "+" : ""}${effect} ${traitName}`);
        return effect;
      }
    }
    return 0;
  }

  function average(a, b) {
    return (a + b) / 2;
  }

  function randomInt(min, max) {
    const range = max - min + 1;
    if (range <= 0) throw new Error("Invalid range");

    const maxUint32 = 0xFFFFFFFF;
    const bucketSize = Math.floor(maxUint32 / range);
    const maxAcceptable = bucketSize * range;

    let rand;
    const uint32 = new Uint32Array(1);

    do {
      window.crypto.getRandomValues(uint32);
      rand = uint32[0];
    } while (rand >= maxAcceptable);

    return min + (rand % range);
  }

  function predictPlayType(down, distance) {
    return "Run"; // Stub, can be enhanced with real logic
  }


  //UI Functions ONLY - ANIMATIONS BELOW!
  function show3DDrive(startYard, prevYard, currentYard, playType = 'run', passComplete = true) {
    return new Promise(resolve => {
      const field = document.getElementById("field3D");
      const fieldWidth = field.offsetWidth;
      const yardPx = fieldWidth / 120;
      const fieldHeight = field.offsetHeight;
      const canvas = document.getElementById("arcCanvas");
      canvas.width = fieldWidth;
      canvas.height = fieldHeight;
      let drivePX = (startYard + 10) * yardPx;
      let prevPX = (prevYard + 10) * yardPx;
      let currPX = (currentYard + 10) * yardPx;
      let drive = document.getElementById("drive3D");
      const driveDot = drive.querySelector(".drive-dot");
      // Handle drive line based on direction
      if (state.Possession == "Home") {
        drive.style.left = `${drivePX}px`;
        drive.style.right = `auto`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = 'auto';
        driveDot.style.left = '0';
      } else {
        drivePX = fieldWidth - drivePX;
        prevPX = fieldWidth - prevPX;
        currPX = fieldWidth - currPX;
        drive.style.left = `auto`;
        drive.style.right = `${drivePX}px`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = '0';
        driveDot.style.left = 'auto';
      }

      const lastPlay = document.getElementById("lastPlayMarker");
      const lastDot = lastPlay.querySelector(".last-dot");
      const arrow = lastPlay.querySelector(".drive-arrow");
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.style.opacity = 0; // Hide previous catch point immediately
      // Fade out old marker
      lastPlay.style.opacity = lastDot.style.opacity = arrow.style.opacity = 0;
      setTimeout(() => {
        lastPlay.style.transition = "none";
        lastPlay.style.backgroundColor = playType === 'pass' ? 'transparent' : 'black';
        lastPlay.style.width = `0px`;
        lastPlay.style.opacity = 1;
        lastDot.style.opacity = 1;
        arrow.style.opacity = 1;
        if(state.Possession == "Home"){
          lastDot.style.left = `0`;
          lastDot.style.right = `auto`;
          lastPlay.style.left = `${prevPX}px`;
          arrow.style.left = `0px`;
          arrow.style.right = `auto`;
        } else{
          lastDot.style.right = `0`;
          lastDot.style.left = `auto`;
          lastPlay.style.right = `${prevPX}px`;
          arrow.style.left = `auto`;
          arrow.style.right = `0px`;
        }

        if (playType === 'run') {
          lastPlay.style.top = `50%`;
          lastPlay.style.height = `6px`;
          arrow.style.top = `-10px`;
          setTimeout(() => {
            // Animate based on direction of play
            if (state.Possession == "Home") {
              lastPlay.style.transition = "width 1.4s ease, left 1.4s ease";
              arrow.style.transition = "left 1.4s ease";
              lastPlay.style.left = `${prevPX}px`;
              lastPlay.style.right = `auto`;
              lastPlay.style.width = `${currPX - prevPX}px`;
              arrow.style.left = `${(currPX - prevPX) - 10}px`;
              arrow.style.right = `auto`;
              arrow.style.transform = "rotate(0deg)";
            } else {
              lastPlay.style.transition = "width 1.4s ease, right 1.4s ease";
              arrow.style.transition = "right 1.4s ease";
              lastPlay.style.left = `auto`;
              lastPlay.style.right = `${prevPX}px`;
              lastPlay.style.width = `${(currPX - prevPX)}px`;
              arrow.style.left = `auto`;
              arrow.style.right = `${(currPX - prevPX) - 10}px`;
              arrow.style.transform = "rotate(180deg)";
            }
            const playWidth = currPX - prevPX;
            if (playWidth <= 0) {
              // No animation to wait for; resolve manually after short delay
              setTimeout(() => {
                resolve();
              }, 300);
            } else {
              const onEnd = (e) => {
                if (e.propertyName === 'width') {
                  lastPlay.removeEventListener('transitionend', onEnd);
                  resolve();
                }
              };
              lastPlay.addEventListener('transitionend', onEnd);
            }
          }, 50);
        } else {
          lastDot.style.opacity = arrow.style.opacity = 0;
          drawPassArc(prevPX, currPX, passComplete).then(resolve);
        }
      }, 400);
    });
  }
  function drawPassArc(x0, x1, passComplete = true) {
    return new Promise(resolve => {
      const canvas = document.getElementById("arcCanvas");
      const ctx = canvas.getContext("2d");
      const yardPx = canvas.width / 120;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const midX = (x0 + x1) / 2;
      const y = canvas.height * 0.45;
      const peakHeight = Math.min(yardPx * 12, Math.max(yardPx * 5, (x1 - x0) * 0.6));
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.lineCap = "round";
      let offset = 0;
      let startTime = null;
      function animate(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        offset -= 2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setLineDash([10, 5]);
        ctx.lineDashOffset = offset;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.quadraticCurveTo(midX, y - peakHeight, x1, y);
        ctx.stroke();
        if (elapsed < 3000) {
          requestAnimationFrame(animate);
        } else {
          showCatchPoint(x1, y, passComplete).then(resolve);
        }
      }
      requestAnimationFrame(animate);
    });
  }
  function showCatchPoint(x, y, complete = true) {
    return new Promise(resolve => {
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.innerText = complete ? "‚û§" : "‚úñ";
      catchPoint.style.left = `${x - 8}px`;
      catchPoint.style.top = `${y - 20}px`;
      catchPoint.style.opacity = 0;
      // Fade in and stay
      setTimeout(() => {
        catchPoint.style.transition = "opacity 0.8s ease";
        catchPoint.style.opacity = 1;
        setTimeout(resolve, 800);
      }, 100);
    });
  }

  function playSound(id) {
    const sound = document.getElementById(id);
    if (sound) {
      sound.currentTime = 0; // rewind
      sound.play();
    }
  }

  // On load
  refreshUI();
</script>