<script>
  let state = {};
  let players = [];
  let playerTraits = {};
  let rollThresholds = [];
  let breakawaySettings = [];
  let drainSettings = {};  // Populated from backend on load
  let tackleSettings = [];
  let frontendStats = [];
  let defensiveStats = [];
  let passingStats = [];
  let receivingStats = [];
  let gameId = 1;
  let playHistory = [];
  let savedFormations = [];
  let currentFormation = [];
  let defensiveFormation = [];
  let autoStuff = false;
  let autoRelease = false;
  let offStarPower = false;
  let defStarPower = false;
  let defStarPowerTackler = '';
  const RUN_POSITIONS = ['WR1','RB1','RB2','QB'];
  const ROUTE_OPTIONS = ['Screen','Short','Medium','Med-Long','Long','Deep'];
  const QB_READ_OPTIONS = ['Primary','2nd','3rd','4th','Checkdown'];
  let receiverRoutes = {};
  let playerReadSelection = {};
  let qbReadAssignments = {};
  let selectedPlayer = null;
  let runningClock = false;
  let completionTable = [];
  let routeTypeAirYards = [];
  let timeNeededToOpen = [];
  let completionSeparationAdjustment = [];
  let yacBySeparation = {};


  function updateStickyOffsets() {
    const scoreboard = document.getElementById('scoreboard');
    if (!scoreboard) return;
    const root = document.documentElement;
    root.style.setProperty('--scoreboardHeight', scoreboard.offsetHeight + 'px');
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const target = document.getElementById(btn.dataset.tab);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.boxscore-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.boxscore-pill').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.boxscore-subtab').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const target = document.getElementById(btn.dataset.subtab);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.playbyplay-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.playbyplay-pill').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const showSummary = btn.dataset.subtab === 'summary';
        document.getElementById('playTimeline').style.display = showSummary ? 'none' : '';
        const summaryDiv = document.getElementById('scoringSummary');
        if (showSummary) renderScoringSummary();
        summaryDiv.style.display = showSummary ? '' : 'none';
      });
    });
      updateStickyOffsets();
      window.addEventListener('resize', updateStickyOffsets);
      loadGamesList();
      const backBtn = document.getElementById('backButton');
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          document.getElementById('gameUI').style.display = 'none';
          document.getElementById('gameList').style.display = 'block';
          backBtn.style.display = 'none';
          loadGamesList();
        });
      }
      document.querySelectorAll('.formation-slot').forEach(slot => {
        slot.addEventListener('dragover', allowDrop);
        slot.addEventListener('drop', handleDrop);
        slot.addEventListener('click', () => moveSelectedTo(slot));
        slot.addEventListener('touchstart', e => { e.preventDefault(); moveSelectedTo(slot); });
      });
      const bench = document.getElementById('bench');
      if (bench) {
        bench.addEventListener('dragover', allowDrop);
        bench.addEventListener('drop', handleDrop);
        bench.addEventListener('click', e => { if (e.target === bench) moveSelectedTo(bench); });
        bench.addEventListener('touchstart', e => { if (e.target === bench) { e.preventDefault(); moveSelectedTo(bench); } });
      }
      const clearBtn = document.getElementById('clearFormation');
      if (clearBtn) clearBtn.addEventListener('click', clearFormation);
      const saveBtn = document.getElementById('saveFormation');
      if (saveBtn) saveBtn.addEventListener('click', saveFormation);
      const openBtn = document.getElementById('openFormation');
      if (openBtn) openBtn.addEventListener('click', () => {
        document.getElementById('formationModal').classList.add('open');
      });
      const closeBtn = document.getElementById('closeFormation');
      if (closeBtn) closeBtn.addEventListener('click', () => {
        document.getElementById('formationModal').classList.remove('open');
      });
      const losBtn = document.getElementById('viewLOS');
      if (losBtn) losBtn.addEventListener('click', () => {
        renderLOS();
        document.getElementById('losModal').classList.add('open');
      });
      const closeLOS = document.getElementById('closeLOS');
      if (closeLOS) closeLOS.addEventListener('click', () => {
        document.getElementById('losModal').classList.remove('open');
      });
      const routeBtn = document.getElementById('openRoutes');
      if (routeBtn) routeBtn.addEventListener('click', () => {
        renderRoutesModal();
        document.getElementById('routesModal').classList.add('open');
      });
      const closeRoutes = document.getElementById('closeRoutes');
      if (closeRoutes) closeRoutes.addEventListener('click', () => {
        document.getElementById('routesModal').classList.remove('open');
      });
      const clearRoutesBtn = document.getElementById('clearRoutes');
      if (clearRoutesBtn) clearRoutesBtn.addEventListener('click', clearRoutes);
      const saveRoutesBtn = document.getElementById('saveRoutes');
      if (saveRoutesBtn) saveRoutesBtn.addEventListener('click', () => {
        document.getElementById('routesModal').classList.remove('open');
      });
    });

  function loadGamesList() {
    google.script.run.withSuccessHandler(renderGameCards).getGamesList();
  }

  function renderGameCards(games) {
    const container = document.getElementById('gameList');
    if (!container) return;
    container.innerHTML = '';
    games.forEach(g => {
      const card = document.createElement('div');
      const id = Number(g.GameId);
      const isFinal = g.Qtr === 'FINAL';
      const homeRowClass = g.HomeScore > g.AwayScore ? 'team-row winner' : g.HomeScore < g.AwayScore ? 'team-row loser' : 'team-row';
      const awayRowClass = g.AwayScore > g.HomeScore ? 'team-row winner' : g.AwayScore < g.HomeScore ? 'team-row loser' : 'team-row';
      card.className = 'game-card' + (isFinal ? ' final' : '');

      if (isFinal) {
        card.innerHTML = `
        <div class="${homeRowClass}">
          <img class="team-logo" src="${g.HomeLogo || ''}" alt="Home Logo" />
          <span class="team-name">${g.Home}</span>
          <span class="team-score">${g.HomeScore}</span>
        </div>
        <div class="${awayRowClass}">
          <img class="team-logo" src="${g.AwayLogo || ''}" alt="Away Logo" />
          <span class="team-name">${g.Away}</span>
          <span class="team-score">${g.AwayScore}</span>
        </div>
        `;
      } else {
        const redZone = (g.Possession === 'Home' && g.BallOn >= 80) || (g.Possession === 'Away' && g.BallOn <= 20);
        const downDisplay = formatDownDistance(g.Down, g.Distance, g.BallOn, g.Possession);
        card.innerHTML = `
        <div class="${homeRowClass}">
          <img class="team-logo" src="${g.HomeLogo || ''}" alt="Home Logo" />
          <div class="team-name-wrap">
            <span class="team-name">${g.Home}</span>
            <span class="poss-indicator">${g.Possession === 'Home' ? 'üèà' : ''}</span>
          </div>
          <span class="team-score">${g.HomeScore}</span>
          <span class="team-time">${formatClock(parseTimeToSeconds(g.Time))}</span>
          <span class="team-down${redZone ? ' red-zone' : ''}">${downDisplay}</span>
        </div>
        <div class="${awayRowClass}">
          <img class="team-logo" src="${g.AwayLogo || ''}" alt="Away Logo" />
          <div class="team-name-wrap">
            <span class="team-name">${g.Away}</span>
            <span class="poss-indicator">${g.Possession === 'Away' ? 'üèà' : ''}</span>
          </div>
          <span class="team-score">${g.AwayScore}</span>
          <span class="team-qtr">${formatQuarter(g.Qtr)}</span>
          <span class="team-ball">${formatBallOnForPoss(g.BallOn, g.Possession)}</span>
        </div>
        `;
      }
      card.addEventListener('click', () => {
        gameId = id;
        refreshUI(id);
        document.getElementById('gameList').style.display = 'none';
        document.getElementById('gameUI').style.display = 'block';
        const backBtn = document.getElementById('backButton');
        if (backBtn) backBtn.style.display = 'block';
        updateStickyOffsets();
      });
      container.appendChild(card);
    });
  }

  function toggleMenu() {
    document.getElementById('playerMenu').classList.toggle('open');
  }

  function renderPlayerCards() {
    const menu = document.getElementById('playerMenu');
    if (!menu) return;
    menu.innerHTML = '';
    Object.values(playerTraits).forEach(p => {
      const card = document.createElement('div');
        card.className = 'player-card';
        card.innerHTML = `
              <h4>${p.name}</h4>
              <div>Size: ${p.size}</div>
              <div>Strength: ${p.strength}</div>
              <div>Speed: ${p.speed}</div>
              <div>Stamina: ${p.stamina}</div>
              <div>Run Blocking: ${p.runBlocking}</div>
              <div>Pass Protect: ${p.passProtect}</div>
              <div>Run Stop: ${p.runStop}</div>
              <div>Tackling: ${p.tackling}</div>
              <div>Run Def: ${p.runDef}</div>
              <div>Tackle Chance: ${p.tackleChance}</div>
            `;
        menu.appendChild(card);
      });
    }

  // === GAME SETUP ===
  function refreshUI(selectedGameId) {
    state = {};
    players = [];
    playerTraits = {};
    rollThresholds = [];
    breakawaySettings = [];
    drainSettings = {};  // Populated from backend on load
    frontendStats = [];
    defensiveStats = [];
    passingStats = [];
    receivingStats = [];
    playHistory = [];
    if (typeof selectedGameId !== 'undefined') {
      gameId = selectedGameId;
    }
    google.script.run.withSuccessHandler(function (gameState) {
      console.log("‚úÖ Loaded game state");
      if (!gameState) {
        console.error(`‚ùå No game state returned for game ${gameId}`);
        return;
      }
      state = gameState;
      state.Time = parseTimeToSeconds(state.Time);
      runningClock = false;
      updateStateUI();

      loadPlayersTraits(function () {
        loadSettings(function () {
          google.script.run
            .withSuccessHandler(async function (data) {
              console.log("‚úÖ Loaded play history", data);
              playHistory = data;
              if (!state.StartingPossession) {
                const first = playHistory[0];
                state.StartingPossession = first ? first.Possession : state.Possession;
              }
              normalizeBallOn(playHistory);
              frontendStats = [];
              defensiveStats = [];
              passingStats = [];
              receivingStats = [];

              playHistory.forEach(play => {
                if (!play.PlayType) return;

                if (play.PlayType === 'Run') {
                  if (!play.Player) return;
                  const player = play.Player;
                  const team = play.Possession || '';
                  const yards = parseFloat(play.Yards) || 0;
                  const td = play.Result === "Touchdown";
                  const fumble = play.Result === "Fumble";
                  const recoveredBy = play.RecoveredBy || play.recoveredby;

                  let p = frontendStats.find(s => s.playername === player && s.team === team);
                  if (!p) {
                    p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
                    frontendStats.push(p);
                  }
                  p.carries++;
                  p.yards += yards;
                  if (td) p.tds++;
                  if (fumble) p.fumbles++;
                  if (yards > p.long) p.long = yards;

                  if (play.Tackler && play.Tackler !== 'NA') {
                    const defTeam = team === 'Home' ? 'Away' : 'Home';
                    let d = defensiveStats.find(s => s.playername === play.Tackler && s.team === defTeam);
                    if (!d) {
                      d = { playername: play.Tackler, team: defTeam, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0 };
                      defensiveStats.push(d);
                    }
                    d.tackles++;
                    if (yards < 0) d.tfl++;
                    if (fumble) {
                      d.ff++;
                      if (recoveredBy === play.Tackler) d.fr++;
                    }
                  }
                } else if (play.PlayType === 'Pass') {
                  const qb = play.Passer || play.Player || '';
                  const receiver = play.Target || play.Receiver || '';
                  const team = play.Possession || '';
                  const yards = parseFloat(play.Yards) || 0;
                  const result = play.Result || '';
                  const completed = result !== 'Incomplete' && result !== 'Intercepted';
                  const intercepted = result === 'Intercepted';
                  const td = result === 'Touchdown';
                  const fumble = result === 'Fumble';
                  if (qb) {
                    let ps = passingStats.find(s => s.playername === qb && s.team === team);
                    if (!ps) {
                      ps = { playername: qb, team, attempts: 0, completions: 0, yards: 0, tds: 0, ints: 0 };
                      passingStats.push(ps);
                    }
                    ps.attempts++;
                    if (completed) {
                      ps.completions++;
                      ps.yards += yards;
                      if (td) ps.tds++;
                    }
                    if (intercepted) ps.ints++;
                  }
                  if (receiver) {
                    let rs = receivingStats.find(s => s.playername === receiver && s.team === team);
                    if (!rs) {
                      rs = { playername: receiver, team, targets: 0, receptions: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
                      receivingStats.push(rs);
                    }
                    rs.targets++;
                    if (completed) {
                      rs.receptions++;
                      rs.yards += yards;
                      if (td) rs.tds++;
                      if (yards > rs.long) rs.long = yards;
                    }
                    if (fumble) rs.fumbles++;
                  }
                  if (intercepted) {
                    const defTeam = team === 'Home' ? 'Away' : 'Home';
                    const defender = play.Interceptor || play.Tackler;
                    if (defender) {
                      let d = defensiveStats.find(s => s.playername === defender && s.team === defTeam);
                      if (!d) {
                        d = { playername: defender, team: defTeam, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0 };
                        defensiveStats.push(d);
                      }
                      d.ints++;
                    }
                  } else if (play.Defender) {
                    const defTeam = team === 'Home' ? 'Away' : 'Home';
                    let d = defensiveStats.find(s => s.playername === play.Defender && s.team === defTeam);
                    if (!d) {
                      d = { playername: play.Defender, team: defTeam, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0 };
                      defensiveStats.push(d);
                    }
                    d.deflections = (d.deflections || 0) + 1;
                  }
                }
              });

              renderPlayTimeline();

              updateFatigueBasedOnStatsOnInitialLoad();
              renderBoxScore();
              await animatePlay('Run');
            })
            .withFailureHandler(function (error) {
              console.error("‚ùå Failed to load play history:", error.message);
            })
            .getPlayHistory(gameId);
        });
      });
    }).withFailureHandler(function (error) {
      console.error("‚ùå Failed to load game state:", error.message);
    }).getGameState(gameId);

  }


  function updateFatigueBasedOnStatsOnInitialLoad() {
    if (playerTraits && drainSettings && drainSettings.Run) {
      for (let i = 0; i < frontendStats.length; i++) {
        const stat = frontendStats[i];
        const pt = playerTraits[stat.playername];
        if (pt) {
          pt.fatigue = pt.stamina - (stat.carries * drainSettings.Run);
        }
      }
    }
  }
  async function animatePlay(playType, passResult = {}) { 
    // use current game state to drive the animation in the proper direction
    await show3DDrive(state.DriveStart, state.Previous, state.BallOn, playType = playType, passResult); //CHANGE - dont hardcode run and pass
  }

  function formatBallOn(yard) {
    yard = parseInt(yard, 10);
    // Convert field position to the perspective of the team with the ball
    const perspectiveYard = state.Possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatBallOnForPoss(yard, possession) {
    yard = parseInt(yard, 10);
    const perspectiveYard = possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatDownDistance(down, distance, ballOn = state.BallOn, possession = state.Possession) {
    const ord = ["1st", "2nd", "3rd", "4th"];
    const d = ord[down - 1] || down + "th";
    const yardsToGoal = possession === "Home" ? 100 - Number(ballOn) : Number(ballOn);
    const dist = Number(distance);
    const distText = dist >= yardsToGoal ? "Goal" : dist;
    return `${d} & ${distText}`;
  }

  function formatQuarter(qtr) {
    if (qtr === 'FINAL') return 'FINAL';
    const ord = ["1st", "2nd", "3rd", "4th", "OT"];
    return ord[qtr - 1] || qtr + "th";
  }

  function parseTimeToSeconds(t) {
    if (typeof t === 'number') return t;
    if (typeof t === 'string') {
      if (t.includes(':')) {
        const [m, s] = t.split(':').map(Number);
        return m * 60 + s;
      }
      const num = Number(t);
      if (!isNaN(num)) return num;
    }
    return 0;
  }

  function formatClock(seconds) {
    const sec = Math.max(0, Math.floor(Number(seconds)));
    const m = Math.floor(sec / 60);
    const s = String(sec % 60).padStart(2, '0');
    return `${m}:${s}`;
  }

  function computeDriveInfo() {
    let plays = 0;
    for (let i = playHistory.length - 1; i >= 0; i--) {
      const play = playHistory[i];
      if (play.Possession !== state.Possession) break;
      plays++;
    }
    const yards = state.Possession === "Home"
      ? state.BallOn - state.DriveStart
      : state.DriveStart - state.BallOn;
    //return { plays, yards: Math.max(0, yards) };
    document.getElementById("driveInfo").innerText = `${plays} plays, ${yards} yards`;
  }

  function updateTimeoutDots(id, count) {
    const container = document.getElementById(id);
    if (!container) return;
    const dots = Array.from(container.children);
    dots.forEach((dot, idx) => {
      dot.classList.toggle('used', idx >= count);
    });
  }

  function buildPlayText(play) {
    if (play.PlayType === 'Pass') {
      const qb = play.Player || '';
      const receiver = play.Receiver || '';
      const yards = play.Yards;
      const tackler = play.Tackler;
      let text = '';
      if (play.Result === 'Intercepted') {
        const poss = play.Possession === 'Home' ? 'Away' : 'Home';
        const spot = formatBallOnForPoss(play.NewBallOn, poss);
        text = `${qb} pass intended for ${receiver}. Intercepted at the ${spot} by ${tackler}.`;
      } else if (play.Result === 'Incomplete') {
        text = `${qb} pass intended for ${receiver}. Incomplete.`;
      } else {
        const spot = formatBallOnForPoss(play.NewBallOn, play.Possession);
        text = `${qb} pass to ${receiver} to ${spot} for ${yards} yards`;
        if (tackler && tackler !== 'NA') {
          text += ` (${tackler})`;
        }
        text += '.';
      }
      if (play.Result && !['Normal','Fumble','Intercepted','Incomplete'].includes(play.Result)) {
        if (play.Result === 'Touchdown') {
          text += ` <span style="color:green; font-weight:bold;">${play.Result}!</span>`;
        } else if (play.Result === 'TO on Downs') {
          text += ` <span style="color:red; font-weight:bold;">${play.Result}!</span>`;
        } else {
          text += ` <strong>${play.Result}!</strong>`;
        }
      }
      if (play.Result === 'Fumble' && play.RecoveredBy) {
        const recoveryPoss = play.RecoveredBy === receiver ? play.Possession : (play.Possession === 'Home' ? 'Away' : 'Home');
        text += ` FUMBLE! Recovered by ${play.RecoveredBy} at the ${formatBallOnForPoss(play.NewBallOn, recoveryPoss)}.`;
      }
      return text;
    } else {
      let text = `<strong>${play.Player}</strong> runs for ${play.Yards} Yards.`;

      if (play.Result && play.Result !== "Normal" && play.Result !== "Fumble") {
        if (play.Result === "Touchdown") {
          text += ` <span style="color:green; font-weight:bold;">${play.Result}!</span>`;
        } else if (play.Result === "TO on Downs") {
          text += ` <span style="color:red; font-weight:bold;">${play.Result}!</span>`;
        } else {
          text += ` <strong>${play.Result}!</strong>`;
        }
      }

      if (play.Result !== "Touchdown" && play.Tackler && play.Tackler !== "NA") {
        text += ` Tackle made at the ${formatBallOnForPoss(play.NewBallOn, play.Possession)} by ${play.Tackler}.`;
      }

      if (play.Result === "Fumble" && play.RecoveredBy) {
        const recoveryPoss = play.RecoveredBy === play.Player ? play.Possession : (play.Possession === "Home" ? "Away" : "Home");
        text += ` FUMBLE! Recovered by ${play.RecoveredBy} at the ${formatBallOnForPoss(play.NewBallOn, recoveryPoss)}.`;
      }

      return text;
    }
  }

  function normalizeBallOn(history) {
    let prevBall = null;
    let prevDrive = null;
    let prevPoss = null;
    history.forEach(play => {
      if (prevDrive === null || play.DriveStart !== prevDrive || play.Possession !== prevPoss) {
        prevBall = Number(play.DriveStart);
        prevDrive = play.DriveStart;
        prevPoss = play.Possession;
      }
      play.BallOn = Number(prevBall);
      if (play.NewBallOn !== undefined && play.NewBallOn !== "") {
        prevBall = Number(play.NewBallOn);
      }
    });
  }

  function groupPlaysByDrive(plays) {
    const drives = [];
    let current = null;
    plays.forEach(play => {
      if (!play.Player || (play.PlayType && play.PlayType !== "Run")) return;
      const key = play.Possession + '-' + play.DriveStart;
      if (!current || current.key !== key) {
        current = { key, possession: play.Possession, driveStart: Number(play.DriveStart), plays: [] };
        drives.push(current);
      }
      current.plays.push(play);
    });
    drives.forEach(drive => {
      const last = drive.plays[drive.plays.length - 1];
      drive.result = last.Result || '';
      drive.homeScore = last.HomeScore !== undefined ? last.HomeScore : state.HomeScore;
      drive.awayScore = last.AwayScore !== undefined ? last.AwayScore : state.AwayScore;
      const end = Number(last.NewBallOn);
      drive.yards = drive.possession === 'Home' ? end - drive.driveStart : drive.driveStart - end;
      drive.playsCount = drive.plays.length;
    });
    return drives;
  }

  function updateLastPlayDesc() {
    const el = document.getElementById('lastPlayDesc');
    if (!el) return;
    if (playHistory.length === 0) {
      el.innerHTML = '';
      return;
    }
    const lastPlay = playHistory[playHistory.length - 1];
    const text = buildPlayText(lastPlay);
    el.innerHTML = `<strong>Last Play:</strong> ${text}`;
  }

  function renderPlayTimeline() {
    const container = document.getElementById("playTimeline");
    if (!container) return;
    container.innerHTML = "";
    const drives = groupPlaysByDrive(playHistory);
    drives.forEach(drive => {
      const section = document.createElement('div');
      section.className = 'drive-section';

      const header = document.createElement('div');
      header.className = 'drive-header';

      const toggle = document.createElement('div');
      toggle.className = 'drive-toggle';
      toggle.textContent = '^';

      const logo = document.createElement('img');
      logo.className = 'drive-logo';
      logo.src = drive.possession === 'Home' ? (state.HomeLogo || '') : (state.AwayLogo || '');

      /**const info = document.createElement('div');
      const resultDiv = document.createElement('span');
      resultDiv.className = 'drive-result';
      resultDiv.textContent = drive.result;
      const summaryDiv = document.createElement('span');
      summaryDiv.className = 'drive-summary';
      summaryDiv.textContent = `${drive.playsCount} Plays, ${drive.yards} Yards`;
      info.appendChild(resultDiv);
      info.appendChild(summaryDiv);**/
      
      const info = document.createElement('div');
      info.className = 'drive-overview';
      const resultDiv = document.createElement('span');
      resultDiv.className = 'drive-result';
      resultDiv.textContent = drive.result;
      const summaryDiv = document.createElement('span');
      summaryDiv.className = 'drive-summary';
      summaryDiv.textContent = `${drive.playsCount} Plays, ${drive.yards} Yards`;
      info.appendChild(resultDiv);
      info.appendChild(summaryDiv);

      const scoreDiv = document.createElement('div');
      scoreDiv.className = 'drive-score';
      scoreDiv.innerHTML = `<div><span class="team-name">${state.Home}</span> <span class="score-value">${drive.homeScore}</span></div><div><span class="team-name">${state.Away}</span> <span class="score-value">${drive.awayScore}</span></div>`;

      header.appendChild(toggle);
      header.appendChild(logo);
      header.appendChild(info);
      header.appendChild(scoreDiv);
      section.appendChild(header);

      const playsDiv = document.createElement('div');
      playsDiv.className = 'drive-plays';
      drive.plays.forEach(play => {
        const playRow = document.createElement('div');
        playRow.className = 'play-row';
        const sitDiv = document.createElement('div');
        sitDiv.className = 'play-situation';
        const downDist = formatDownDistance(play.Down, play.Distance, play.BallOn, play.Possession);
        const spot = formatBallOnForPoss(play.BallOn, play.Possession);
        sitDiv.innerHTML = `${downDist} at ${spot}`;
        const descDiv = document.createElement('div');
        descDiv.className = 'play-desc';
        const time = formatClock(play.Time);
        const playQuarter = play.QTR ?? play.Qtr ?? state.Qtr;
        const qtr = formatQuarter(playQuarter);
        const text = buildPlayText(play);
        descDiv.innerHTML = `(${time} - ${qtr}) ${text}`;
        playRow.appendChild(sitDiv);
        playRow.appendChild(descDiv);
        playsDiv.appendChild(playRow);
      });
      section.appendChild(playsDiv);

      function toggleSection() {
        const collapsed = playsDiv.classList.toggle('collapsed');
        toggle.textContent = collapsed ? 'v' : '^';
      }
      header.addEventListener('click', toggleSection);
      toggle.addEventListener('click', function(e) { e.stopPropagation(); toggleSection(); });

      container.appendChild(section);
    });
    computeDriveInfo();
    updateLastPlayDesc();
    renderScoringSummary();
  }

  function renderScoringSummary() {
    const container = document.getElementById('scoringSummary');
    if (!container) return;
    container.innerHTML = '';
    const scoringPlays = playHistory.filter(p => ['Touchdown', 'Field Goal', 'Safety'].includes(p.Result));
    const byQuarter = {};
    scoringPlays.forEach(p => {
      const q = p.QTR ?? p.Qtr ?? state.Qtr;
      if (!byQuarter[q]) byQuarter[q] = [];
      byQuarter[q].push(p);
    });
    Object.keys(byQuarter).sort((a,b) => a - b).forEach(q => {
      const qLabel = formatQuarter(q).toUpperCase();
      const qText = qLabel === 'OT' ? 'OVERTIME' : `${qLabel} QUARTER`;
      const header = document.createElement('div');
      header.className = 'summary-quarter';
      header.innerHTML = `<div class="quarter-label">${qText}</div><div class="summary-home-scorehead">${state.Home}</div><div class="summary-away-scorehead">${state.Away}</div>`;
      container.appendChild(header);
      const line = document.createElement('div');
      line.className = 'summary-line';
      container.appendChild(line);
      let idx = 0;
      byQuarter[q].forEach(play => {
        const row = document.createElement('div');
        row.className = 'summary-play' + (idx % 2 ? ' alt' : '');
        const logo = document.createElement('img');
        logo.className = 'summary-logo';
        logo.src = play.Possession === 'Home' ? (state.HomeLogo || '') : (state.AwayLogo || '');
        const resultDiv = document.createElement('div');
        resultDiv.className = 'summary-result-time';
        const map = { 'Touchdown':'TD', 'Field Goal':'FG', 'Safety':'Safety' };
        const time = formatClock(play.Time);
        resultDiv.textContent = `${map[play.Result] || play.Result} ${time}`;
        const homeScore = document.createElement('div');
        homeScore.className = 'summary-home-score';
        homeScore.textContent = play.HomeScore;
        const awayScore = document.createElement('div');
        awayScore.className = 'summary-away-score';
        awayScore.textContent = play.AwayScore;
        const desc = document.createElement('div');
        desc.className = 'summary-description';
        desc.innerHTML = buildPlayText(play);
        row.appendChild(logo);
        row.appendChild(resultDiv);
        row.appendChild(homeScore);
        row.appendChild(awayScore);
        row.appendChild(desc);
        container.appendChild(row);
        idx++;
      });
    });
  }

    function loadPlayers() {
      populateBench();
      updateRunnerDropdown();
      receiverRoutes = {};
      playerReadSelection = {};
      qbReadAssignments = {};
    }

    function populateBench() {
      const bench = document.getElementById('bench');
      if (!bench) return;
      // Clear existing assignments
      document.querySelectorAll('.formation-slot').forEach(slot => {
        if (slot.firstChild) {
          bench.appendChild(slot.firstChild);
        }
        slot.classList.remove('filled');
        slot.dataset.player = '';
      });
      bench.innerHTML = '';
      const teamName = state[state.Possession];
      Object.entries(playerTraits).forEach(([name, traits]) => {
        if (traits.team === teamName) {
          const item = document.createElement('div');
          let posClass = traits.position.toLowerCase();
          if (posClass === 'te' || posClass === 'ol') posClass = 'teol';
          item.className = `player-item ${posClass}`;
          item.draggable = true;
          item.dataset.player = name;
          item.title = `${name} (${traits.position})`;
          const offStars = '‚òÖ'.repeat(Number(traits.offStars) || 0);
          const defStars = '‚òÖ'.repeat(Number(traits.defStars) || 0);
          item.innerHTML = `
            <div class="player-name">${name}</div>
            <div class="star-row"><span>Off:</span><span class="stars off">${offStars}</span></div>
            <div class="star-row"><span>Def:</span><span class="stars def">${defStars}</span></div>
            <div class="player-attributes"><span>Size: ${traits.size}</span><span>Speed: ${traits.speed}</span></div>
          `;
          item.addEventListener('dragstart', dragStart);
          item.addEventListener('touchstart', selectPlayer);
          item.addEventListener('click', selectPlayer);
          bench.appendChild(item);
        }
      });
    }

    function updateRunnerDropdown() {
      const dropdown = document.getElementById('playerDropdown');
      if (!dropdown) return;
      dropdown.innerHTML = '';
      const teamName = state[state.Possession];
      let runners = [];
      if (currentFormation.length > 0) {
        runners = currentFormation
          .filter(f => RUN_POSITIONS.includes(f.position) && f.player)
          .map(f => f.player)
          .filter(name => playerTraits[name] && playerTraits[name].team === teamName);
      }
      runners.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.text = name;
        dropdown.appendChild(option);
      });
    }

    function dragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.player);
    }

    function allowDrop(e) {
      e.preventDefault();
    }

    function handleDrop(e) {
      e.preventDefault();
      const name = e.dataTransfer.getData('text/plain');
      const item = document.querySelector(`.player-item[data-player="${name}"]`);
      if (!item) return;
      const source = item.parentElement;
      const target = e.currentTarget;
      if (target.classList.contains('formation-slot')) {
        if (target.firstChild) {
          document.getElementById('bench').appendChild(target.firstChild);
        }
        target.appendChild(item);
        target.classList.add('filled');
        target.dataset.player = name;
      } else {
        target.appendChild(item);
      }
      if (source.classList && source.classList.contains('formation-slot')) {
        source.classList.remove('filled');
        source.dataset.player = '';
      }
    }

    function selectPlayer(e) {
      e.preventDefault();
      e.stopPropagation();
      const item = e.currentTarget;
      if (selectedPlayer === item) {
        item.classList.remove('selected');
        selectedPlayer = null;
        return;
      }
      if (selectedPlayer) selectedPlayer.classList.remove('selected');
      selectedPlayer = item;
      item.classList.add('selected');
    }

    function moveSelectedTo(target) {
      if (!selectedPlayer) return;
      const bench = document.getElementById('bench');
      const item = selectedPlayer;
      const source = item.parentElement;
      if (target.classList.contains('formation-slot')) {
        if (target.firstChild) {
          bench.appendChild(target.firstChild);
          target.classList.remove('filled');
        }
        target.appendChild(item);
        target.classList.add('filled');
        target.dataset.player = item.dataset.player;
      } else {
        target.appendChild(item);
      }
      if (source.classList && source.classList.contains('formation-slot')) {
        source.classList.remove('filled');
        source.dataset.player = '';
      }
      item.classList.remove('selected');
      selectedPlayer = null;
    }

    function clearFormation() {
      const bench = document.getElementById('bench');
      if (!bench) return;
      document.querySelectorAll('.formation-slot').forEach(slot => {
        if (slot.firstChild) {
          bench.appendChild(slot.firstChild);
        }
        slot.classList.remove('filled');
        slot.dataset.player = '';
      });
      currentFormation = [];
      selectedPlayer = null;
      document.querySelectorAll('.player-item.selected').forEach(p => p.classList.remove('selected'));
      updateRunnerDropdown();
    }

    function saveFormation() {
      const required = ['QB','TEOL2','TEOL3','TEOL4'];
      const formation = [];
      let valid = true;
      document.querySelectorAll('.formation-slot').forEach(slot => {
        const pos = slot.dataset.position;
        const playerEl = slot.querySelector('.player-item');
        if (playerEl) {
          formation.push({ position: pos, player: playerEl.dataset.player });
        } else if (required.includes(pos)) {
          valid = false;
        }
      });
      if (!valid) {
        alert('Please fill all required positions');
        return;
      }
      currentFormation = formation;
      updateRunnerDropdown();
      savedFormations.push(formation);
      console.log('Saved formation', formation);
      setDefensiveFormation();
      document.getElementById('formationModal').classList.remove('open');
    }

    function getEligibleReceivers() {
      const wrs = currentFormation.filter(f => f.position.startsWith('WR') && f.player);
      const rbs = currentFormation.filter(f => f.position.startsWith('RB') && f.player);
      const teols = currentFormation
        .filter(f => f.position.startsWith('TEOL') && f.player)
        .sort((a,b) => parseInt(a.position.replace('TEOL','')) - parseInt(b.position.replace('TEOL','')));
      const eligibleTeols = [];
      if (teols.length > 0) {
        eligibleTeols.push(teols[0]);
        if (teols.length > 1) eligibleTeols.push(teols[teols.length - 1]);
      }
      return [...wrs, ...rbs, ...eligibleTeols];
    }

    function renderRoutesModal() {
      const list = document.getElementById('routesList');
      if (!list) return;
      list.innerHTML = '';
      const players = getEligibleReceivers();
      players.forEach(p => {
        const row = document.createElement('div');
        row.className = 'route-row';
        row.innerHTML = `
          <span class="route-player">${p.player}</span>
          <select class="route-select" data-player="${p.player}">
            ${ROUTE_OPTIONS.map(r => `<option value="${r}">${r}</option>`).join('')}
          </select>
          <select class="qb-read-select" data-player="${p.player}">
            <option value=""></option>
            ${QB_READ_OPTIONS.map(r => `<option value="${r}">${r}</option>`).join('')}
          </select>
        `;
        list.appendChild(row);
        const routeSel = row.querySelector('.route-select');
        routeSel.value = receiverRoutes[p.player] || 'Short';
        routeSel.addEventListener('change', e => {
          receiverRoutes[p.player] = e.target.value;
        });
        const readSel = row.querySelector('.qb-read-select');
        readSel.value = playerReadSelection[p.player] || '';
        readSel.addEventListener('change', e => handleReadChange(p.player, e.target));
      });
    }

    function handleReadChange(player, select) {
      const val = select.value;
      const prev = playerReadSelection[player];
      if (prev) {
        delete qbReadAssignments[prev];
      }
      if (val && qbReadAssignments[val]) {
        const otherPlayer = qbReadAssignments[val];
        playerReadSelection[otherPlayer] = '';
        const otherSelect = document.querySelector(`.qb-read-select[data-player="${otherPlayer}"]`);
        if (otherSelect) otherSelect.value = '';
      }
      if (val) {
        qbReadAssignments[val] = player;
        playerReadSelection[player] = val;
      } else {
        playerReadSelection[player] = '';
      }
    }

    function clearRoutes() {
      receiverRoutes = {};
      playerReadSelection = {};
      qbReadAssignments = {};
      document.querySelectorAll('.route-select').forEach(sel => sel.value = 'Short');
      document.querySelectorAll('.qb-read-select').forEach(sel => sel.value = '');
    }

  function setDefensiveFormation() {
    const offenseTeam = state[state.Possession];
    const defenseTeam = state[state.Possession === 'Home' ? 'Away' : 'Home'];
    const defenders = Object.values(playerTraits).filter(p => p.team === defenseTeam);

    const dbs = defenders.filter(p => p.defPos === 'DB').sort((a,b) => b.defStars - a.defStars);
    const dls = defenders.filter(p => p.defPos === 'DL').sort((a,b) => b.defStars - a.defStars);
    const lbs = defenders.filter(p => p.defPos === 'LB').sort((a,b) => b.defStars - a.defStars);
    const safeties = defenders.filter(p => p.defPos === 'S').sort((a,b) => b.defStars - a.defStars);

    const wrs = currentFormation
      .filter(f => f.position.startsWith('WR'))
      .map(f => ({ pos: f.position, player: f.player, stars: playerTraits[f.player]?.offStars || 0 }))
      .sort((a,b) => b.stars - a.stars);

    const olPositions = ['TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].filter(pos =>
      currentFormation.some(f => f.position === pos)
    );

    // DB assignments ‚Äì fill from DBs, then LBs if needed
    const dbAssignments = [];
    for (let i = 0; i < wrs.length; i++) {
      let player = null;
      if (dbs.length > 0) {
        player = dbs.shift();
      } else if (lbs.length > 0) {
        player = lbs.shift();
      }
      dbAssignments.push({
        position: `DB${i+1}`,
        player: player ? player.name : '',
        align: wrs[i].pos
      });
    }

    // DL assignments ‚Äì fill from DLs, then LBs if needed
    const dlAssignments = [];
    olPositions.forEach((ol, i) => {
      let player = null;
      if (dls.length > 0) {
        player = dls.shift();
      } else if (lbs.length > 0) {
        player = lbs.shift();
      }
      dlAssignments.push({
        position: `DL${i+1}`,
        player: player ? player.name : '',
        align: ol
      });
    });

    let assigned = dbAssignments.length + dlAssignments.length;
    let remaining = Math.max(0, 7 - assigned);

    const predicted = predictPlayType(state.Down, state.Distance).toLowerCase();
    const lbAssignments = [];
    const backs = ['QB','RB1','RB2'];
    let lbNeeded = (predicted === 'run' || predicted === 'screen') ? backs.length : 2;
    lbNeeded = Math.min(lbNeeded, remaining);
    for (let i = 0; i < lbNeeded; i++) {
      let player = null;
      if (lbs.length > 0) {
        player = lbs.shift();
      } else if (dls.length > 0) {
        player = dls.shift();
      } else if (dbs.length > 0) {
        player = dbs.shift();
      }
      if (player) {
        const assignment = { position: `LB${i+1}`, player: player.name };
        if (predicted === 'run' || predicted === 'screen') {
          assignment.align = backs[i];
        }
        lbAssignments.push(assignment);
      }
    }

    assigned += lbAssignments.length;
    remaining = Math.max(0, 7 - assigned);

    // Safety ‚Äì pick from safeties, then remaining LBs, DBs, DLs
    let safetyAssignment = null;
    if (remaining > 0) {
      if (safeties.length > 0) {
        const s = safeties.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (lbs.length > 0) {
        const s = lbs.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (dbs.length > 0) {
        const s = dbs.shift();
        safetyAssignment = { position: 'S', player: s.name };
      } else if (dls.length > 0) {
        const s = dls.shift();
        safetyAssignment = { position: 'S', player: s.name };
      }
    }

    defensiveFormation = [...dbAssignments, ...dlAssignments, ...lbAssignments];
    if (safetyAssignment) defensiveFormation.push(safetyAssignment);
    console.log('Defensive formation', defensiveFormation);
  }

  function renderLOS() {
    const field = document.getElementById('losField');
    if (!field) return;
    field.innerHTML = '';
    const line = document.createElement('div');
    line.className = 'los-line';
    field.appendChild(line);

    const safetyRow = document.createElement('div');
    safetyRow.className = 'los-row';
    defensiveFormation.filter(d => d.position.startsWith('S')).forEach(s => {
      safetyRow.appendChild(createLosPlayer(s.player));
    });
    if (safetyRow.childElementCount > 0) field.appendChild(safetyRow);

    const lbRow = document.createElement('div');
    lbRow.className = 'los-row';
    defensiveFormation.filter(d => d.position.startsWith('LB')).forEach(lb => {
      lbRow.appendChild(createLosPlayer(lb.player));
    });
    if (lbRow.childElementCount > 0) field.appendChild(lbRow);

    const grid = document.createElement('div');
    grid.className = 'los-grid';
    const losSlots = ['WR1','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5','WR2','WR3'];
    losSlots.forEach(pos => {
      const col = document.createElement('div');
      col.className = 'los-col';
      const def = defensiveFormation.find(d => d.align === pos);
      col.appendChild(createLosPlayer(def ? def.player : ''));
      const off = currentFormation.find(f => f.position === pos);
      col.appendChild(createLosPlayer(off ? off.player : ''));
      grid.appendChild(col);
    });
    field.appendChild(grid);

    const qbRow = document.createElement('div');
    qbRow.className = 'los-row';
    const qb = currentFormation.find(f => f.position === 'QB');
    qbRow.appendChild(createLosPlayer(qb ? qb.player : ''));
    field.appendChild(qbRow);

    const rbRow = document.createElement('div');
    rbRow.className = 'los-row';
    ['RB1','RB2'].forEach(pos => {
      const p = currentFormation.find(f => f.position === pos);
      rbRow.appendChild(createLosPlayer(p ? p.player : ''));
    });
    field.appendChild(rbRow);
  }

  function createLosPlayer(name) {
    const div = document.createElement('div');
    div.className = name ? 'los-player' : 'los-player empty';
    if (name) {
      div.textContent = name;
    }
    return div;
  }

  function loadPlayersTraits(callback) {
    google.script.run.withSuccessHandler(function (playerData) {
      console.log("‚úÖ Loaded player traits");
      const playerMap = {};
      playerData.forEach(player => {
        playerTraits[player.name] = player;
      });
      loadPlayers();
      renderPlayerCards();
      if (callback) callback();
    }).getPlayerTraits();
  }

  function loadSettings(callback) {
    console.log("üîÑ Loading game settings...");
    google.script.run
      .withSuccessHandler(function (data) {
        if (!data || !data.thresholds) {
          console.error("‚ö†Ô∏è Invalid settings object received:", data);
          alert("Settings could not be loaded. Please check the sheet and try again.");
          return;
        }

        rollThresholds = data.thresholds;
        breakawaySettings = data.breakaways;
        drainSettings = data.staminaDrains;
        tackleSettings = data.tackleTable || [];
        completionTable = data.completionTable || [];
        routeTypeAirYards = data.routeTypeAirYards || [];
        timeNeededToOpen = data.timeNeededToThrow || [];
        completionSeparationAdjustment = data.completionSeparationAdjustment || [];
        yacBySeparation = data.yacBySeparation || {};

        console.log("‚úÖ Game settings fully initialized.");
        if (callback) callback();
      })
      .withFailureHandler(err => {
        console.error("‚ùå Server error:", err.message);
        alert("There was a problem loading game settings.");
      })
      .getFrontendSettings();
  }

  function runBlockVsRunDef(ballCarrier) {
    let dlTotal = 0;
    let olTotal = 0;

    defensiveFormation.forEach(f => {
      if (f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))) {
        dlTotal += Number(playerTraits[f.player]?.runDef || 0);
      }
    });

    currentFormation.forEach(f => {
      if (!f.player) return;
      const pos = f.position;
      const isOffensive = ['QB','RB1','RB2','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].includes(pos);
      if (isOffensive && f.player !== ballCarrier) {
        olTotal += Number(playerTraits[f.player]?.runDef || 0);
      }
    });

    const total = dlTotal + olTotal;
    console.log(dlTotal + " -- " + olTotal);
    if (total <= 0) return { defenseWins: false };
    const roll = Math.floor(Math.random() * total) + 1;
    console.log(" -- " + roll);
    return { defenseWins: roll <= dlTotal };
  }

  function determineTackler(yards) {
    if (!tackleSettings || tackleSettings.length === 0) return "NA";
    const gain = Math.max(0, Math.floor(yards));
    let range = tackleSettings.find(r => gain <= r.yardageCap);
    if (!range) range = tackleSettings[tackleSettings.length - 1];

    const hasDL = defensiveFormation.some(f => f.player && f.position.startsWith("DL"));
    const hasLB = defensiveFormation.some(f => f.player && f.position.startsWith("LB"));
    const hasDBS = defensiveFormation.some(
      f => f.player && (f.position.startsWith("DB") || f.position.startsWith("S"))
    );

    const groups = [];
    if (hasDL && range.DL > 0) groups.push({ name: "DL", chance: range.DL });
    if (hasLB && range.LB > 0) groups.push({ name: "LB", chance: range.LB });
    if (hasDBS && range.DBS > 0) groups.push({ name: "DBS", chance: range.DBS });

    const totalChance = groups.reduce((sum, g) => sum + g.chance, 0);
    if (totalChance <= 0) return "NA";

    let roll = Math.random() * totalChance;
    console.log(roll);
    let group = groups[groups.length - 1].name;
    for (const g of groups) {
      if (roll < g.chance) {
        group = g.name;
        break;
      }
      roll -= g.chance;
    }
    console.log(group);

    const inGroup = defensiveFormation.filter(f => {
      if (!f.player) return false;
      if (group === "DL") return f.position.startsWith("DL");
      if (group === "LB") return f.position.startsWith("LB");
      return f.position.startsWith("DB") || f.position.startsWith("S");
    });
    if (inGroup.length === 0) return "NA";

    const total = inGroup.reduce((sum, f) => sum + Number(playerTraits[f.player]?.tackleChance || 0), 0);
    if (total <= 0) return inGroup[Math.floor(Math.random() * inGroup.length)].player;

    let r = Math.random() * total;
    console.log(r);
    for (const f of inGroup) {
      console.log(f.player + " - " + playerTraits[f.player]?.tackleChance);

      r -= Number(playerTraits[f.player]?.tackleChance || 0);
      if (r <= 0) return f.player;
    }
    return inGroup[inGroup.length - 1].player;
  }

  function checkForFumble(runner, tackler) {
    if (!runner || !tackler || tackler === "NA") return { fumble: false };
    const rb = playerTraits[runner];
    const def = playerTraits[tackler];
    if (!rb || !def) return { fumble: false };
    const strip = Number(def.strip || 0);
    const ballSec = Number(rb.ballsecurity ?? rb.hands ?? 50);
    const fumbleChance = (strip / 10) * ((100 - ballSec) / 100);
    const roll = Math.random() * 100;
    if (roll <= fumbleChance) {
      const defStars = Number(def.defStars || 0);
      const offStars = Number(rb.offStars || 0);
      const starsSum = defStars + offStars;
      const recoveryRoll = Math.random() * starsSum;
      const recoveredBy = recoveryRoll <= defStars ? tackler : runner;
      return { fumble: true, recoveredBy };
    }
    return { fumble: false };
  }

  function tryAutoStuff() {
    console.log("autoStuffing");
    let starPower = 0;
    defensiveFormation.forEach(f => {
      if (f.player && (f.position.startsWith('DL') || f.position.startsWith('LB'))) {
        console.log(Number(playerTraits[f.player]?.defStars || 0));
        console.log((Number(playerTraits[f.player]?.defStars || 0))**2);

        starPower += ((Number(playerTraits[f.player]?.defStars || 0))**2)/2.5;
      }
    });
    console.log("Star Power" + starPower);
    const roll = Math.floor(Math.random() * 100) + 1;
    return roll <= starPower;
  }

  function tryAutoRelease(ballCarrier) {
    let starPower = 0;
    currentFormation.forEach(f => {
      if (!f.player) return;
      const pos = f.position;
      const isOffensive = ['QB','RB1','RB2','TEOL1','TEOL2','TEOL3','TEOL4','TEOL5'].includes(pos);
      if (isOffensive && f.player !== ballCarrier) {
        starPower += ((Number(playerTraits[f.player]?.offStars || 0))**2)/2.5;
      }
    });
    const roll = Math.floor(Math.random() * 100) + 1;
    return roll <= starPower;
  }

  function rollOffStarPower(ballCarrier) {
    const stars = Number(playerTraits[ballCarrier]?.offStars || 0);
    const threshold = Math.pow(stars, 2);
    const roll = Math.random() * 100;
    return roll <= threshold;
  }

  function rollDefStarPower() {
    const candidates = defensiveFormation
      .filter(f => f.player && (f.position.startsWith('DL') || f.position.startsWith('LB')))
      .map(f => {
        const stars = Number(playerTraits[f.player]?.defStars || 0);
        return { name: f.player, stars, weight: Math.pow(stars, 2) };
      });

    const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
    if (totalWeight <= 0) return false;

    let roll = Math.random() * totalWeight;
    let chosen = candidates[0];
    for (const c of candidates) {
      if (roll < c.weight) {
        chosen = c;
        defStarPowerTackler = chosen.name;
        break;
      }
      roll -= c.weight;
    }

    const threshold = Math.pow(chosen.stars, 2);
    const activationRoll = Math.random() * 100;
    return activationRoll <= threshold;
  }

  function afterPlayComplete() {
    autoStuff = false;
    autoRelease = false;
    offStarPower = false;
    defStarPower = false;
  }

  function determineTimeToThrow() {
    let predictionEffect = 0;
    //if predicted, pass:  
    predictionEffect = 20;
    //else: 
    //predictionEffect = -10;

    let passRushSum = defensiveFormation
      .filter(f => f.position.startsWith('DL') || f.position.startsWith('LB'))
      .reduce((sum, f) => sum + Number(playerTraits[f.player]?.passRush || 0), 0);
    passRushSum += predictionEffect*2;

    let passProtectSum = currentFormation
      .filter(f => f.position.startsWith('RB') || f.position.startsWith('TEOL'))
      .reduce((sum, f) => sum + Number(playerTraits[f.player]?.passProtect || 0), 0);
    passProtectSum -= predictionEffect*2;

    let passProtection = true;
    const maxRoll = Math.round(passRushSum + passProtectSum);
    const roll = randomInt(0, maxRoll);
    if (roll <= passRushSum) passProtection = false;

    return handleRush(passProtection, predictionEffect);
  }

  function handleRush(passProtection, predictionEffect) {
    if (passProtection) {
      let protectionStrength = currentFormation
        .filter(f => f.position.startsWith('RB') || f.position.startsWith('TEOL'))
        .reduce((sum, f) => {
          const offStars = Number(playerTraits[f.player]?.offStars || 0);
          return sum + (Math.pow(offStars, 2) / 2);
        }, 0);

      protectionStrength *= 1.25;

      let roll = Math.random() * 100;
      if (roll <= protectionStrength + 25) {
        roll = Math.random() * 100;
        if (roll <= protectionStrength + 15) {
          roll = Math.random() * 100;
          return roll <= protectionStrength ? 5 : 4;
        }
        return 3;
      }
      return 2;
    }

    let rushStrength = defensiveFormation
      .filter(f => f.position.startsWith('DL') || f.position.startsWith('LB'))
      .reduce((sum, f) => {
        const defStars = Number(playerTraits[f.player]?.defStars || 0);
        return sum + (Math.pow(defStars, 2) / 2);
      }, 0);
    rushStrength += predictionEffect/3;  

    let sackChance = defensiveFormation
      .filter(f => f.position.startsWith('DL') || f.position.startsWith('LB'))
      .reduce((sum, f) => sum + Number(playerTraits[f.player]?.defStars || 0), 0);
    sackChance += Math.max(0, predictionEffect);  

    let roll = Math.random() * 100;
    if (roll <= rushStrength) {
      roll = Math.random() * 100;
      return roll <= sackChance ? -1 : 0;
    }
    return 1;
  }

  // === PASS PLAY ===
  async function passPlay(qbName) {
    if (!qbName) return;
    let resultArray;
    let completionPct;
    let routes;
    let target;
    const timeToThrow = determineTimeToThrow();
    if(timeToThrow < 0){
      resultArray = handleSack();
    } else{
      routes = assignRoutes();
      target = choosePassTarget(qbName, routes);
      completionPct = determineCompletionPct(qbName, target);
      resultArray = determinePassOutcome(qbName, target, routes, completionPct);
    }

    //postPlayStuff
    const scoringTeam = state.Possession;
    const oldScore = scoringTeam === "Home"
      ? parseInt(state.HomeScore, 10) || 0
      : parseInt(state.AwayScore, 10) || 0;
    let yards = resultArray.yards || 0;
    let touchdown = false;
    let tackler = null;
    let fumble = false;
    let recoveredBy = null;
    let newBall = state.BallOn;
    let newDown = state.Down;
    let newDist = state.Distance;

    //HandleSack
    if (resultArray.sack){
      newBall = state.Possession === 'Home' ? newBall + yards : newBall - yards;
      const fum = checkForFumble(qbName, resultArray.sackBy, resultArray.sack);
      if (fum.fumble) {
        fumble = true;
        recoveredBy = fum.recoveredBy;
      }
      tackler = resultArray.sackBy;
      updateDefensiveStatsPass(tackler, { tackle: true, yards: yards, sack: true, fumble: fumble, recoveredBy: recoveredBy});
    }
    //Handle Completed Pass
    if (resultArray.completed){
      newBall = state.Possession === 'Home' ? newBall + yards : newBall - yards;
      touchdown = state.Possession === 'Home' ? newBall >= 100 : newBall <= 0;
      if(touchdown){
        yards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;
      }
      if (!touchdown) {
        tackler = determineTackler(yards); //NEEDS UPDATING
        const fum = checkForFumble(target.target, tackler);
        if (fum.fumble) {
          fumble = true;
          recoveredBy = fum.recoveredBy;
        }
      }
    }
    updatePassingStats(qbName, yards, resultArray.completed, resultArray.intercepted, touchdown, resultArray.sack);
    if (target) {
      updateReceivingStats(target.target, yards, resultArray.completed, touchdown, fumble);
    }
    if (resultArray.intercepted) {
      updateDefensiveStatsPass(resultArray.caughtBy, { interception: true });
    } else {
      const defenderName = target && target.routeInfo ? target.routeInfo.defender : null;
      if (defenderName && !resultArray.completed) {
        if (target.routeInfo.defStarsPctBoost) {
          updateDefensiveStatsPass(defenderName, { deflection: true });
        }
      }
      if (tackler) {
        updateDefensiveStatsPass(tackler, { tackle: true, yards, fumble, recoveredBy });
      }
    }
    //Handle Interception
    if(resultArray.intercepted){

    }

    let timeTaken = 5;  //NEEDS UPDATING
    let predicted = "PASS";  //NEEDS UPDATING
    let result = "Normal";

    //Handle offense retaining possession
    if(!resultArray.intercepted && recoveredBy != (state.Possession === "Home" ? "Away" : "Home")){
      newDist = newDist - yards;
      //handle Touchdown
      if(touchdown){
        result = "Touchdown";
        await handleTouchdown(newBall, qbName, target.target, resultArray, result, predicted, timeTaken, resultArray);
        await celebrateTouchdown(scoringTeam, oldScore, oldScore + 6);
      }
      //Handle First Down
      else if(newDist <= 0){
        result = "First Down";
        newDown = 1;
        const yardsToGoal = state.Possession === "Home" ? 100 - newBall : newBall;
        newDist = yardsToGoal < 10 ? yardsToGoal : 10;
        updateGameState(1, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, target.target, yards, tackler, result, predicted, timeTaken, recoveredBy);
        await animatePlay('Pass', resultArray);
      } else{
        let playType = 'Pass';
        if(resultArray.sack){
          let playType = 'Run';
          target = {target: ''};
        }
        else if(!resultArray.completed){
          result = "Incomplete";
        }
        newDown++;
        if (newDown > 4) {
          result = "TO on Downs";
          await handleTOonDowns(result, newBall, qbName, target.target, resultArray, tackler, predicted, timeTaken, resultArray);
        } else {
          updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, qbName, target.target, yards, tackler, result, predicted, timeTaken, recoveredBy);
          await animatePlay(playType, resultArray);
        }
      }
    }
    //Handle Fumble or INT
    else{
      if(recoveredBy = (state.Possession === "Home" ? "Away" : "Home") ){
        result = "Fumble";
      } else if(resultArray.intercepted){
        result = "Intercepted";
      }
    }
    //updateFrontendStats(qbName, recordedYards, result, scoringTeam, tackler, recoveredBy);

    renderBoxScore();
    //document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${result.yards} yards</strong><br/><br/>` +
    //  `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;

    updateStateUI();
    //refreshUI();
    afterPlayComplete();
  }

  function handleSack(){
    return { sack: true, sackBy: "Player", yards: -5};
  }

  function assignRoutes() {
    const routes = {};
    const eligible = getEligibleReceivers().map(r => r.player);
    const lbs = defensiveFormation.filter(d => d.position.startsWith('LB'));
    currentFormation.forEach(f => {
      if (!f.player) return;
      if (!eligible.includes(f.player)) return;
      const routeType = receiverRoutes[f.player] || 'Short';
      const info = routeTypeAirYards.find(r => r.routeType === routeType);
      const depth = info ? randomInt(info.minAirYards, info.maxAirYards) : 0;
      const time = CalcTimeNeededToOpen(depth, f.player);
      let defender = null;
      if (f.position.startsWith('RB')) {
        const rbIndex = f.position === 'RB1' ? 0 : 1;
        const aligned = defensiveFormation.find(d => d.align === f.position && d.position.startsWith('LB'));
        defender = aligned ? aligned.player : (lbs[rbIndex] ? lbs[rbIndex].player : (lbs[0] ? lbs[0].player : null));
      } else {
        const aligned = defensiveFormation.find(d => d.align === f.position);
        defender = aligned ? aligned.player : null;
      }
      routes[f.player] = { routeType, airYards: depth, TTO: time, defender, position: f.position };
    });
    return routes;
  }

  function CalcTimeNeededToOpen(depth, player) {
    const time = 5;
    const read = playerReadSelection[player];
    if (!read) return;
    const table = timeNeededToOpen.find(t => t.qbRead === read);
    if (!table) return;
    let key;
    if (depth < 10) key = 'lt10';
    else if (depth <= 20) key = 'tenTo20';
    else key = 'twentyOnePlus';
    return table[key];
  }

  function choosePassTarget(qbName, routes) {
    routes = determineSeparation(routes);
    const qb = playerTraits[qbName] || {};
    const readRoll = randomInt(0, 100);
    const qbReadsDefense = readRoll <= (Number(qb.readDefense) || 0);

    Object.keys(routes).forEach(name => {
      const route = routes[name];
      const wr = playerTraits[name] || {};
      route.percievedSeparation = qbReadsDefense ? route.separation : 0;
      route.throwLikelyhood = ((Number(wr.qbFavorite) || 0) / 10) + (route.percievedSeparation * 3);

      // Determine weight based on depth of route using completionTable
      let airyardsweight = 0;
      if (completionTable && completionTable.length > 0) {
        for (const row of completionTable) {
          if (route.airYards <= row.pastLos) {
            airyardsweight = Number(row.percentage) || 0;
            break;
          }
        }
      }
      route.airyardsweight = airyardsweight;
      route.weight = airyardsweight * route.throwLikelyhood;
    });

    const totalWeight = Object.keys(routes).reduce((sum, name) => sum + (routes[name].weight || 0), 0);
    if (totalWeight <= 0) return null;

    let roll = Math.random() * totalWeight;
    let chosen = Object.keys(routes)[0];
    for (const name of Object.keys(routes)) {
      const w = routes[name].weight || 0;
      if (roll < w) {
        chosen = {target: name, routeInfo: routes[name]};
        break;
      }
      roll -= w;
    }

    return chosen;
  }

  function determineSeparation(routes){
     Object.keys(routes).forEach(name => {
      const route = routes[name];
      const wr = playerTraits[name] || {};
      const db = playerTraits[route.defender] || {};
      let separation = 0;

      if (route.airYards > 10) {
        const wrTotal = (Number(wr.speed) || 0) + (Number(wr.acceleration) || 0);
        const dbTotal = (Number(db.speed) || 0) + (Number(db.acceleration) || 0);
        const roll = randomInt(0, wrTotal + dbTotal);
        if (roll <= wrTotal) separation += 1;
      }

      for (let i = 0; i < 3; i++) {
        const roll = randomInt(0, 100);
        if (roll <= (Number(wr.routeRunning) || 0)) separation += 1;
      }

      for (let i = 0; i < 2; i++) {
        const roll = randomInt(0, 100);
        if (roll <= (Number(db.coverage) || 0)) separation -= 1;
      }

      route.separation = separation;
    });
    return routes;
  }

  function qbAccuracyAdjust(qb) {
    const acc = Number(qb.accuracy) || 0;
    const diff = (acc - 50) / 10;
    const adjust = (diff ** 2) / 2;
    return acc >= 50 ? adjust : -adjust;
  }

  function determineCompletionPct(qbName, target) {
    if (!target) return 0;
    const qb = playerTraits[qbName] || {};
    const routeInfo = target.routeInfo || {};
    const separation = Number(routeInfo.separation) || 0;
    const depth = Number(routeInfo.airYards) || 0;
    let jumpBall = false;

    if (
      separation < 1 ||
      (separation < 3 && (state.BallOn + depth > 100 || state.BallOn + depth < 0))
    ) {
      jumpBall = true;
    }

    let baseCompletion = 0;
    if (completionTable && completionTable.length > 0) {
      for (const row of completionTable) {
        if (depth <= row.pastLos) {
          baseCompletion = Number(row.baseCompletion) || 0;
          break;
        }
      }
    }

    let completionPct = baseCompletion + qbAccuracyAdjust(qb);
    const sepAdjust = completionSeparationAdjustment.find(r => Number(r.separation) === separation);
    if (sepAdjust) {
      completionPct += Number(sepAdjust.catchPctChange) || 0;
    }
    const receiver = playerTraits[target.target] || {};
    const hands = Number(receiver.hands);
    if (!isNaN(hands)) {
      const diff = (hands - 60) / 10;
      completionPct += (diff ** 2) / 2;
    }
    let offStarsPctBoost = 0;
    const offStars = Number(receiver.offStars) || 0;
    const offRoll = Math.random() * 100;
    if (offRoll <= Math.pow(offStars, 2)) {
      offStarsPctBoost = Math.pow(offStars, 2);
    }
    let defStarsPctBoost = 0;
    const defender = playerTraits[routeInfo.defender] || {};
    const defStars = Number(defender.defStars) || 0;
    const defRoll = Math.random() * 100;
    if (defRoll <= Math.pow(defStars, 2)) {
      defStarsPctBoost = -Math.pow(defStars, 2);
    }
    routeInfo.defStarsPctBoost = defStarsPctBoost;
    completionPct += offStarsPctBoost + defStarsPctBoost;
    return completionPct;
  }

  function determinePassOutcome(qbName, target, routes, completionPct) {
    if (!target) {
      return { completed: false, intercepted: false, yards: 0 };
    }

    const qb = playerTraits[qbName] || {};
    const routeInfo = target.routeInfo || {};
    const defenderName = routeInfo.defender;
    const defender = playerTraits[defenderName] || {};
    const airYards = Number(routeInfo.airYards) || 0;

    const completionRoll = Math.random() * 100;
    if (completionRoll <= completionPct) {
      const yac = calcYAC(target.target, routeInfo.separation);
      const totalYards = airYards + (Number(yac) || 0);
      return { completed: true, intercepted: false, yards: totalYards, caughtBy: target.target};
    }

    const qbAccCalc = Math.pow(((Number(qb.accuracy) || 0) - 60) / 10, 2) / 2;
    const qbReadCalc = Math.pow(((Number(qb.readDefense) || 0) - 60) / 10, 2) / 2;
    const defBallHawkCalc = Math.pow(((Number(defender.ballHawk) || 0) - 60) / 10, 2) / 2;
    const defReadQBCalc = Math.pow(((Number(defender.readQB) || 0) - 60) / 10, 2) / 2;
    const pickChance = 1 + Math.max(0, 5 - qbAccCalc - qbReadCalc + defBallHawkCalc + defReadQBCalc);

    const pickRoll = Math.random() * 100;
    if (pickRoll <= pickChance) {
      const yac = calcYAC(defenderName, routeInfo.separation);
      const totalYards = airYards + (Number(yac) || 0);
      return { completed: false, intercepted: true, yards: totalYards, caughtBy: defenderName};
    }

    return { completed: false, intercepted: false, yards: 0 };
  }

  function calcYAC(playerName, separation = 0){
    const stats = playerTraits[playerName] || {};
    const sepKey = String(separation);
    const table = yacBySeparation[sepKey] || yacBySeparation[0] || [];
    if (table.length === 0) return 0;

    let modLog = [];
    let roll = Math.random() * 100;
    roll = maybeBoostRollForAcceleration(roll, stats, modLog);

    let yards = 0;
    for (const r of table) {
      if (roll >= r.rollMin && roll < r.rollMax) {
        yards = randomInt(r.minYards, r.maxYards);
        break;
      }
    }

    yards = maybeAvoidLoss(yards, stats, modLog);
    yards = adjustChunkRunForSpeed(yards, stats, modLog, true);

    if (yards <= 2) {
      yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
    }
    if (yards >= 1 && yards <= 4) {
      yards += applyTraitEffect("Acceleration", stats.acceleration + Math.min(0, stats.fatigue), true, modLog);
    }
    if (yards > 0 && yards < 5) {
      yards += applyTraitEffect("Juke", stats.juke + Math.min(0, stats.fatigue), true, modLog);
    }

    return yards;
  }

  // === MAIN PLAY ===
  async function runPlay() {
    const playerName = document.getElementById("playerDropdown").value;
    if (!playerName) return;

    let tackler = null;

    offStarPower = rollOffStarPower(playerName);
    defStarPower = rollDefStarPower();

    const blockResult = runBlockVsRunDef(playerName);
    if (blockResult.defenseWins) {
      autoStuff = tryAutoStuff();
    } else {
      autoRelease = tryAutoRelease(playerName);
    }

    const rbStats = playerTraits[playerName];
    const carryResult = simulateSingleCarry(rbStats);
    const predicted = predictPlayType(state.Down, state.Distance);

    const yardDelta = carryResult.yards;
    const scoringTeam = state.Possession;
    const oldScore = scoringTeam === "Home"
      ? parseInt(state.HomeScore, 10) || 0
      : parseInt(state.AwayScore, 10) || 0;
    // Home drives left ‚û° right (0 -> 100); Away drives right ‚û° left (100 -> 0)
    const newBall = state.Possession === "Home"
      ? Math.min(100, Math.max(0, state.BallOn + yardDelta))
      : Math.max(0, Math.min(100, state.BallOn - yardDelta));
    const touchdown = state.Possession === "Home"
      ? (state.BallOn < 100 && newBall >= 100)
      : (state.BallOn > 0 && newBall <= 0);

    let recordedYards = yardDelta;
    if (touchdown) {
      recordedYards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;
    }
    const timeTaken = Math.round(4 + (Math.abs(recordedYards) / 6) * (60 / rbStats.speed));

    if (!touchdown) {
      if(defStarPower){
        tackler = defStarPowerTackler;
      } else{
        tackler = determineTackler(yardDelta);
      }
    }

    let newDown = state.Down;
    let newDist = state.Distance - yardDelta;

    let result = "Normal";
    let recoveredBy = null;

    if (!touchdown && tackler && tackler !== "NA") {
      const fum = checkForFumble(playerName, tackler);
      if (fum.fumble) {
        result = "Fumble";
        recoveredBy = fum.recoveredBy;
        if (recoveredBy === tackler) {
          updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, "", yardDelta, tackler, result, predicted, timeTaken, recoveredBy);
          await animatePlay('Run');
          const newPossession = state.Possession === "Home" ? "Away" : "Home";
          updateGameState(1, 10, newPossession, newBall, newBall, newBall, playerName, "", yardDelta, tackler, null, predicted, undefined, recoveredBy);
          loadPlayers();
          applyFatigue(playerName, "Run");
          updateFrontendStats(playerName, recordedYards, result, scoringTeam, tackler, recoveredBy);
          console.log(carryResult);
          document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${carryResult.yards} yards</strong><br/><br/>` +
            `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;
          updateStateUI();
          afterPlayComplete();
          return;
        }
      }
    }

    if (touchdown) {
      result = "Touchdown";
      await handleTouchdown(newBall, playerName, "", carryResult, result, predicted, timeTaken);
      recordedYards = carryResult.yards; // handleTouchdown adjusts yards
      await celebrateTouchdown(scoringTeam, oldScore, oldScore + 6);
    } else if (newDist <= 0) {
      result = "First Down";
      newDown = 1;
      const yardsToGoal = state.Possession === "Home" ? 100 - newBall : newBall;
      newDist = yardsToGoal < 10 ? yardsToGoal : 10;
      updateGameState(1, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, "", yardDelta, tackler, result, predicted, timeTaken, recoveredBy);
      await animatePlay('Run');
      playSound("crowdRoar");
    } else {
      newDown++;
      if (newDown > 4) {
        result = "TO on Downs";
        await handleTOonDowns(result, newBall, playerName, "", carryResult, tackler, predicted, timeTaken);
      } else {
        updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, "", yardDelta, tackler, result, predicted, timeTaken, recoveredBy);
        await animatePlay('Run');
      }
    }

    applyFatigue(playerName, "Run");

    updateFrontendStats(playerName, recordedYards, result, scoringTeam, tackler, recoveredBy);
    console.log(carryResult);

    document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${carryResult.yards} yards</strong><br/><br/>` +
      `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;

    updateStateUI();
    //refreshUI();
    afterPlayComplete();
  }

  async function handleTouchdown(newBall, playerName, recName, carryResult, result, predicted, timeTaken, resultArray = {}) {//COMPLETED PASS UPDATES
    // Distance covered to reach the goal line differs by team direction
    carryResult.yards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;

    if (state.Possession === "Home") {
      state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 6;
    } else if (state.Possession === "Away") {
      state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 6;
    }
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, recName, carryResult.yards, null, result, predicted, timeTaken);
    let playType = recName === ''? 'Run' : 'Pass';
    await animatePlay(playType, resultArray);
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    const newBallOn = newPossession === "Home" ? 25 : 75;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, playerName, recName, carryResult.yards, null, null, predicted);
    loadPlayers();
  }

  async function handleTOonDowns(result, newBall, playerName, recName, carryResult, tackler, predicted, timeTaken, resultArray = {}) {//COMPLETED PASS UPDATES
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, recName, carryResult.yards, tackler, result, predicted, timeTaken);

    let playType = recName === ''? 'Run' : 'Pass';
    if(resultArray.sack){
      playType = 'Run';
    }
    await animatePlay(playType, resultArray);
    playSound("crowdRoar");
    await animatePlay(playType, resultArray);
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    updateGameState(1, 10, newPossession, newBall, newBall, newBall, playerName, recName, carryResult.yards, tackler, null, predicted);
    loadPlayers();
  }

  function logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, recName, yards, tackler, result, predicted, qtr, time, recoveredBy) {//MAKE PASS UPDATES
      let playType = 'Run';
      if(recName != ''){
        playType = 'Pass';
      }
      const localPlay = {
        Time: time,
        Down: state.Down,
        Distance: state.Distance,
        QTR: qtr,
        Qtr: qtr,
        DriveStart: Number(driveStart),
        Player: playerName,
        Receiver: recName,
        Yards: yards,
        Result: result || "Normal",
        NewBallOn: ballOn,
        BallOn: previousBallOn,
        Tackler: tackler,
        RecoveredBy: recoveredBy,
        Possession: poss,
        HomeScore: state.HomeScore,
        AwayScore: state.AwayScore,
        PlayType: playType
      };
      playHistory.push(localPlay);

      google.script.run.logPlayHistory({
        gameid: gameId,
        time: time,
        qtr: qtr,
        possession: poss,
        down: state.Down,
        distance: state.Distance,
        ballon: state.BallOn,
        playtype: playType,
        player: playerName,
        receiver: recName,
        yards: yards,
        defensepredicted: predicted,
        predictioncorrect: "",
        tackler: tackler,
        result: result,
        desc: "",
        recoveredby: recoveredBy,
        newdown: down,
        newdist: distance,
        newballon: ballOn,
        drivestart: state.DriveStart,
        homescore: state.HomeScore,
        awayscore: state.AwayScore
      });
    }

  function updateRunningClock(result) {//MAKE PASS UPDATES
    const stopResults = ['Touchdown','Timeout','Field Goal','Kickoff','Punt','Safety','End of Quarter','TO on Downs','Fumble', 'Intercepted', 'Incomplete'];
    if (result) {
      runningClock = !stopResults.includes(result);
    }
  }

  function updateGameState(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, recName, yards, tackler, result, predicted, timeTaken, recoveredBy) {
    let playQuarter = state.Qtr;//COMPLETED PASS UPDATES
    let newTime = state.Time;
    if (typeof timeTaken === 'number') {
      if (runningClock) {
        timeTaken += randomInt(20, 36);
      }
      newTime = state.Time - timeTaken;
    }
    const logTime = Math.max(newTime, 0);
    if (result != null) {
      logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, recName, yards, tackler, result, predicted, playQuarter, logTime, recoveredBy);
    }

    let nextDown = down;
    let nextDistance = distance;
    let nextPoss = poss;
    let nextBallOn = ballOn;
    let nextDriveStart = driveStart;
    let nextPrev = previousBallOn;

    if (typeof timeTaken === 'number' && newTime <= 0) {
      const curQuarter = playQuarter;
      updateRunningClock('End of Quarter');
      if (curQuarter === 2) {
        playQuarter = 3;
        newTime = 900;
        const startTeam = state.StartingPossession || state.Possession;
        nextPoss = startTeam === 'Home' ? 'Away' : 'Home';
        nextBallOn = nextPoss === 'Home' ? 25 : 75;
        nextDown = 1;
        nextDistance = 10;
        nextDriveStart = nextBallOn;
        nextPrev = nextBallOn;
        loadPlayers();
      } else if (curQuarter === 4) {
        if (state.HomeScore !== state.AwayScore) {
          playQuarter = 'FINAL';
          newTime = 0;
        } else {
          playQuarter = 5;
          newTime = 900;
          nextPoss = 'Home';
          nextBallOn = 25;
          nextDown = 1;
          nextDistance = 10;
          nextDriveStart = 25;
          nextPrev = 25;
          loadPlayers();
        }
      } else if (curQuarter === 5) {
        playQuarter = 'FINAL';
        newTime = 0;
      } else {
        playQuarter = curQuarter + 1;
        newTime = 900;
      }
    } else {
      newTime = logTime;
      updateRunningClock(result);
    }

    state.Down = nextDown;
    state.Distance = nextDistance;
    state.BallOn = nextBallOn;
    state.Possession = nextPoss;
    state.Previous = nextPrev;
    state.DriveStart = nextDriveStart;
    state.Time = newTime;
    state.Qtr = playQuarter;
    renderPlayTimeline();

    google.script.run.pushGameState({
      gameId: gameId,
      quarter: state.Qtr,
      time: state.Time,
      down: state.Down,
      distance: state.Distance,
      ballOn: state.BallOn,
      homeScore: state.HomeScore,
      awayScore: state.AwayScore,
      driveStart: state.DriveStart,
      previous: state.Previous,
      possession: state.Possession
    });
  }

  function updateStateUI() {//MAKE PASS UPDATES
    console.log(state);
    const downEl = document.getElementById("downDistance");
    downEl.innerText = formatDownDistance(state.Down, state.Distance, state.BallOn, state.Possession);
    const inRedZone = (state.Possession === "Home" && state.BallOn >= 80) || (state.Possession === "Away" && state.BallOn <= 20);
    downEl.classList.toggle('red-zone', inRedZone);
    const ballEl = document.getElementById("ballOn");
    ballEl.innerText = formatBallOn(state.BallOn);
    ballEl.classList.toggle('red-zone', inRedZone);
    document.getElementById("homeName").innerText = state.Home;
    document.getElementById("awayName").innerText = state.Away;
    document.getElementById("homeRecord").innerText = state.HomeRecord || "";
    document.getElementById("awayRecord").innerText = state.AwayRecord || "";
    if (document.getElementById("homeLogo")) document.getElementById("homeLogo").src = state.HomeLogo || "";
    if (document.getElementById("awayLogo")) document.getElementById("awayLogo").src = state.AwayLogo || "";
    document.getElementById("scoreHome").innerText = state.HomeScore;
    document.getElementById("scoreAway").innerText = state.AwayScore;
    document.getElementById("Quarter").innerText = `${formatQuarter(state.Qtr)}`;
    document.getElementById("Time").innerText = formatClock(state.Time);
    updateTimeoutDots("homeTimeouts", state.HomeTimeouts || 0);
    updateTimeoutDots("awayTimeouts", state.AwayTimeouts || 0);
    document.getElementById("homeFootball").style.visibility = state.Possession === "Home" ? "visible" : "hidden";
    document.getElementById("awayFootball").style.visibility = state.Possession === "Away" ? "visible" : "hidden";
    const homeTab = document.getElementById("boxHomeTab");
    const awayTab = document.getElementById("boxAwayTab");
    if (homeTab) homeTab.innerText = state.Home;
    if (awayTab) awayTab.innerText = state.Away;
    const titles = [
      ["homePassingTitle", `${state.Home} Passing`],
      ["homeRushingTitle", `${state.Home} Rushing`],
      ["homeReceivingTitle", `${state.Home} Receiving`],
      ["homeDefensiveTitle", `${state.Home} Defensive`],
      ["awayPassingTitle", `${state.Away} Passing`],
      ["awayRushingTitle", `${state.Away} Rushing`],
      ["awayReceivingTitle", `${state.Away} Receiving`],
      ["awayDefensiveTitle", `${state.Away} Defensive`],
      ["overviewHomePassingTitle", `${state.Home} Passing`],
      ["overviewHomeRushingTitle", `${state.Home} Rushing`],
      ["overviewHomeReceivingTitle", `${state.Home} Receiving`],
      ["overviewAwayPassingTitle", `${state.Away} Passing`],
      ["overviewAwayRushingTitle", `${state.Away} Rushing`],
      ["overviewAwayReceivingTitle", `${state.Away} Receiving`]
    ];
    titles.forEach(([id, text]) => {
      const el = document.getElementById(id);
      if (el) el.innerText = text;
    });
    highlightTeamRows();
    updateFirstDownLine();
  }

  function highlightTeamRows() {
    document.querySelectorAll('.stats-table tbody').forEach(tb => {
      tb.querySelectorAll('tr').forEach(row => {
        const cell = row.querySelector('td');
        if (cell && cell.textContent.trim().toUpperCase() === 'TEAM') {
          row.classList.add('team-row');
        }
      });
    });
  }

  function updateFirstDownLine() {
    const line = document.getElementById('firstDownLine');
    const field = document.getElementById('field3D');
    if (!line || !field) return;
    const fieldWidth = field.offsetWidth;
    const yardPx = fieldWidth / 120;
    const ball = Number(state.BallOn) || 0;
    const dist = Number(state.Distance) || 0;
    let targetYard = state.Possession === 'Home'
      ? ball + dist
      : ball - dist;
    targetYard = Math.max(0, Math.min(100, targetYard));
    line.style.left = `${(targetYard + 10) * yardPx}px`;
  }

  function celebrateTouchdown(team, oldScore, newScore) {
    return new Promise(resolve => {
      const scoreboard = document.getElementById("scoreboard");
      const banner = document.getElementById("scoreBanner");
      banner.textContent = "TOUCHDOWN!";
      scoreboard.classList.add("scoring");
      banner.classList.add("show");

      setTimeout(() => {
        banner.classList.remove("show");
        const scoreEl = document.getElementById(team === "Home" ? "scoreHome" : "scoreAway");
        let current = oldScore;
        const increment = newScore > oldScore ? 1 : -1;
        const interval = setInterval(() => {
          current += increment;
          scoreEl.innerText = current;
          if (current === newScore) {
            clearInterval(interval);
            scoreboard.classList.remove("scoring");
            resolve();
          }
        }, 100);
      }, 2000);
    });
  }

  function updatePassingStats(qb, yards, completed, intercepted, td, sack) {
    const team = state.Possession;
    let p = passingStats.find(s => s.playername === qb && s.team === team);
    if (!p) {
      p = { playername: qb, team, attempts: 0, completions: 0, yards: 0, tds: 0, ints: 0, sacks: 0, sackYds: 0};
      passingStats.push(p);
    }
    if (sack){
      p.sacks ++;
      p.sackYds += yards;
    } else{
      p.attempts++;
      if (completed) {
        p.completions++;
        p.yards += yards;
        if (td) p.tds++;
      }
      if (intercepted) {
        p.ints++;
      }
    }
  }

  function updateReceivingStats(rec, yards, completed, td, fumble) {
    const team = state.Possession;
    let r = receivingStats.find(s => s.playername === rec && s.team === team);
    if (!r) {
      r = { playername: rec, team, targets: 0, receptions: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
      receivingStats.push(r);
    }
    r.targets++;
    if (completed) {
      r.receptions++;
      r.yards += yards;
      if (td) r.tds++;
      if (yards > r.long) r.long = yards;
    }
    if (fumble) r.fumbles++;
  }

  function updateDefensiveStatsPass(player, opts = {}) {
    if (!player) return;
    const team = state.Possession === 'Home' ? 'Away' : 'Home';
    let d = defensiveStats.find(s => s.playername === player && s.team === team);
    if (!d) {
      d = { playername: player, team, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0, sacks: 0};
      defensiveStats.push(d);
    }
    if (opts.tackle) {
      d.tackles++;
      if ((opts.yards || 0) < 0) d.tfl++;
      if (opts.fumble) {
        d.ff++;
        if (opts.recoveredBy === player) d.fr++;
      }
    }
    if (opts.deflection) {
      d.deflections = (d.deflections || 0) + 1;
    }
    if (opts.interception) {
      d.ints = (d.ints || 0) + 1;
    }
    if (opts.sack){
      d.sacks = (d.sacks || 0) + 1;
    }
  }

  function updateFrontendStats(player, yards, result, team, tackler, recoveredBy) {
    const defTeam = team === "Home" ? "Away" : "Home";
    let p = frontendStats.find(s => s.playername === player && s.team === team);
    if (!p) {
      p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
      frontendStats.push(p);
    }
    p.carries++;
    p.yards += yards;
    if (result == "Touchdown") p.tds++;
    if (result == "Fumble") p.fumbles++;
    if (yards > p.long) p.long = yards;

    if (tackler && tackler !== "NA") {
      let d = defensiveStats.find(s => s.playername === tackler && s.team === defTeam);
      if (!d) {
        d = { playername: tackler, team: defTeam, tackles: 0, tfl: 0, ff: 0, fr: 0, deflections: 0, ints: 0 };
        defensiveStats.push(d);
      }
      d.tackles++;
      if (yards < 0) d.tfl++;
      if (result == "Fumble") {
        d.ff++;
        if (recoveredBy === tackler) d.fr++;
      }
    }

    renderBoxScore();
  }

  function renderBoxScore() {
    renderPassingTable("Home");
    renderPassingTable("Away");
    renderRushingTable("Home");
    renderRushingTable("Away");
    renderReceivingTable("Home");
    renderReceivingTable("Away");
    renderDefensiveTable("Home");
    renderDefensiveTable("Away");
    sortBoxScoreTables();
  }

  function renderPassingTable(team) {
    const body = document.getElementById(team === "Home" ? "homePassingBody" : "awayPassingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = passingStats.filter(p => p.team === team);
    players.forEach(p => {
      const avg = p.completions ? (p.yards / p.completions).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.completions}/${p.attempts}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.ints}</td><td>0</td><td>0.0</td>`;
      body.appendChild(tr);
    });
  }

  function renderRushingTable(team) {
    const body = document.getElementById(team === "Home" ? "homeRushingBody" : "awayRushingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = frontendStats.filter(p => p.team === team).sort((a, b) => b.yards - a.yards);
    let total = { carries: 0, yards: 0, tds: 0, long: 0 };
    players.forEach(p => {
      const avg = p.carries ? (p.yards / p.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.carries}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.long}</td>`;
      body.appendChild(tr);
      total.carries += p.carries;
      total.yards += p.yards;
      total.tds += p.tds;
      if (p.long > total.long) total.long = p.long;
    });
    if (players.length) {
      const avgTeam = total.carries ? (total.yards / total.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>TEAM</td><td>${total.carries}</td><td>${total.yards}</td><td>${avgTeam}</td><td>${total.tds}</td><td>${total.long}</td>`;
      body.appendChild(tr);
    }
  }

  function renderReceivingTable(team) {
    const body = document.getElementById(team === "Home" ? "homeReceivingBody" : "awayReceivingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = receivingStats.filter(p => p.team === team).sort((a, b) => b.yards - a.yards);
    let total = { receptions: 0, yards: 0, tds: 0, long: 0, targets: 0 };
    players.forEach(p => {
      const avg = p.receptions ? (p.yards / p.receptions).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.receptions}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.long}</td><td>${p.targets}</td>`;
      body.appendChild(tr);
      total.receptions += p.receptions;
      total.yards += p.yards;
      total.tds += p.tds;
      total.targets += p.targets;
      if (p.long > total.long) total.long = p.long;
    });
    if (players.length) {
      const avgTeam = total.receptions ? (total.yards / total.receptions).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>TEAM</td><td>${total.receptions}</td><td>${total.yards}</td><td>${avgTeam}</td><td>${total.tds}</td><td>${total.long}</td><td>${total.targets}</td>`;
      body.appendChild(tr);
    }
  }

  function renderDefensiveTable(team) {
    const body = document.getElementById(team === "Home" ? "homeDefensiveBody" : "awayDefensiveBody");
    if (!body) return;
    body.innerHTML = "";
    const players = defensiveStats.filter(p => p.team === team).sort((a, b) => b.tackles - a.tackles);
    players.forEach(p => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.tackles}</td><td>${p.tfl}</td><td>0</td><td>${p.ff}</td><td>${p.fr}</td><td>${p.ints || 0}</td><td>${p.deflections || 0}</td>`;
      body.appendChild(tr);
    });
  }

  function sortBoxScoreTables() {
    document.querySelectorAll('#boxscore .stats-table tbody').forEach(tbody => {
      const table = tbody.closest('table');
      const sortIndex = table.classList.contains('defensive-table') ? 1 : 2;
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const teamRow = rows.find(r => r.firstElementChild && r.firstElementChild.textContent.trim().toUpperCase() === 'TEAM');
      const playerRows = teamRow ? rows.filter(r => r !== teamRow) : rows;
      playerRows.sort((a, b) => {
        const aVal = parseFloat(a.children[sortIndex].textContent) || 0;
        const bVal = parseFloat(b.children[sortIndex].textContent) || 0;
        return bVal - aVal;
      });
      tbody.innerHTML = '';
      playerRows.forEach(r => tbody.appendChild(r));
      if (teamRow) tbody.appendChild(teamRow);
    });
  }

  function applyFatigue(playerName, actionType) {
    const drain = drainSettings[actionType] || 0;
    playerTraits[playerName].fatigue = playerTraits[playerName].fatigue - drain;
  }

  // === FRONTEND LOGIC ENGINE ===
  function simulateSingleCarry(stats) {
    const modLog = [];
    let roll = 0;
    let yards = 0;
    if (autoStuff) {
      // integer in [-2, 2]
      yards = Math.floor(Math.random() * 5) - 2;
      modLog.push('Auto Stuff!');
      if (yards <= 2) yards += applyTraitEffect("Vision", stats.vision + Math.min(0, stats.fatigue), true, modLog);
      if (yards <= 4) yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
    } else{
      roll = getModifiedRoll(stats, modLog);
      roll = maybeBoostRollForAcceleration(roll, stats, modLog);
      yards = getYardageOutcome(roll, stats, modLog);
      if (offStarPower) {
        yards += Math.floor(playerTraits[stats.name].offStars);
        modLog.push(`Yard +`+Math.floor(playerTraits[stats.name].offStars)+` : offStarPower`);
      }
      if (defStarPower) {
        yards += - Math.floor(playerTraits[defStarPowerTackler].defStars);
        modLog.push(`Yard -`+Math.floor(playerTraits[defStarPowerTackler].defStars)+` : defStarPower`);
      }
      yards = maybeAvoidLoss(yards, stats, modLog);
      yards = adjustChunkRunForSpeed(yards, stats, modLog, false);

      if (yards <= 2) yards += applyTraitEffect("Vision", stats.vision + Math.min(0, stats.fatigue), true, modLog);
      if (yards <= 4) yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
      if (yards >= 3 && yards <= 4) yards += applyTraitEffect("Acceleration", stats.acceleration + Math.min(0, stats.fatigue), true, modLog);
      if (yards > 0 && yards < 10) yards += applyTraitEffect("Juke", stats.juke + Math.min(0, stats.fatigue), true, modLog);
    }

    return { name: stats.name, roll, yards, modLog };
  }

  function getModifiedRoll(stats, modLog) {
    // Float base roll from 0 to ~100.000
    let baseRoll = Math.random() * 100; // 0‚Äì100 float

    if (autoRelease) {
      baseRoll += 8;
      modLog.push('Pre +7 Auto Release');
    }

    // Calculate vision mod
    let visionMod = (stats.vision + Math.min(0, stats.fatigue) - 60) * 0.055;
    modLog.push(`Pre ${visionMod > 0 ? "+" : ""}${visionMod.toFixed(1)} Vision`);

    const modified = baseRoll + visionMod;

    // Clamp final result to valid roll range
    return Math.max(0, Math.min(100, modified));
  }

  function maybeBoostRollForAcceleration(roll, stats, modLog) {
    if (roll < 88) { //CHANGE - solid gain or less. No hard code
      const chance = (stats.acceleration + Math.min(0, stats.fatigue) - 60) / 200;
      if (Math.random() < Math.max(0, chance)) {
        const maxBoost = Math.floor((stats.acceleration + Math.min(0, stats.fatigue) - 60) / 4);
        const boost = randomInt(1, Math.min(10, maxBoost));
        modLog.push(`Pre +${boost} Accel (Boost Roll)`);
        return Math.min(99, roll + boost);
      }
    }
    return roll;
  }

  function getYardageOutcome(roll, stats, modLog) {
    if (roll >= 100){
      return getStrictBreakawayYards(stats, modLog);
    }
    for (const r of rollThresholds) {
      if (roll >= r.rollMin && roll < r.rollMax) {
        if (r.label === "RunType_Breakaway") {
          return getStrictBreakawayYards(stats, modLog);
        }
        return randomInt(r.minYards, r.maxYards);
      }
    }
    return 0;
  }

  function getStrictBreakawayYards(stats, modLog) {
    const baseRoll = Math.floor(Math.random() * 100);
    const speedBoost = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) * 0.3);
    const adjustedRoll = Math.min(100, baseRoll + Math.max(0, speedBoost));
    if (speedBoost !== 0) modLog.push(`Pre +${speedBoost} Speed`);

    let cumulative = 0;
    for (const range of breakawaySettings) {
      if (adjustedRoll >= 100){
        return randomInt(81, 100);
      }
      cumulative += range.percentage;
      if (adjustedRoll <= cumulative) {
        return randomInt(range.minYards, range.maxYards);
      }
    }
    return 16;
  }

  function maybeAvoidLoss(yards, stats, modLog) {
    if (yards < 0) {
      const power = stats.size + stats.strength + Math.min(0, stats.fatigue);
      const chanceToAvoid = power / 2.2; //CHANGE - no hard code
      if (Math.random() < chanceToAvoid / 100) {
        const newYards = randomInt(1, 2);
        modLog.push(`Loss Avoided by Power ‚Üí ${newYards} yds`);
        return newYards;
      }
    }
    return yards;
  }

  function adjustChunkRunForSpeed(yards, stats, modLog, yac) {
    if (yac && yards >= 5){
      const bonus = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) / 5); //CHANGE no hard code
      if (bonus !== 0) modLog.push(`Yard ${bonus > 0 ? "+" : ""}${bonus} Speed`);
      return yards + bonus;
    }
    else if (yards >= 10 && yards <= 15) { //CHANGE no hard code
      const bonus = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) / 10); //CHANGE no hard code
      if (bonus !== 0) modLog.push(`Yard ${bonus > 0 ? "+" : ""}${bonus} Speed`);
      return yards + bonus;
    }
    return yards;
  }

  function applyTraitEffect(traitName, traitValue, condition, modLog) {
    if (!condition) return 0;
    const deviation = traitValue - 60;
    const triggerChance = Math.abs(deviation) / 100;
    if (Math.random() < triggerChance) {
      const effect = Math.sign(deviation) * Math.min(2, Math.floor(Math.abs(deviation) / 15));
      if (effect !== 0) {
        modLog.push(`Yard ${effect > 0 ? "+" : ""}${effect} ${traitName}`);
        return effect;
      }
    }
    return 0;
  }

  function average(a, b) {
    return (a + b) / 2;
  }

  function randomInt(min, max) {
    const range = max - min + 1;
    if (range <= 0) throw new Error("Invalid range");

    const maxUint32 = 0xFFFFFFFF;
    const bucketSize = Math.floor(maxUint32 / range);
    const maxAcceptable = bucketSize * range;

    let rand;
    const uint32 = new Uint32Array(1);

    do {
      window.crypto.getRandomValues(uint32);
      rand = uint32[0];
    } while (rand >= maxAcceptable);

    return min + (rand % range);
  }

  function predictPlayType(down, distance) {
    return "Run"; // Stub, can be enhanced with real logic
  }


  //UI Functions ONLY - ANIMATIONS BELOW!
  function show3DDrive(startYard, prevYard, currentYard, playType = 'Run', passResult) {
    passComplete = passResult.completed;
    passIntercepted = passResult.intercepted;
    return new Promise(resolve => {
      const field = document.getElementById("field3D");
      const fieldWidth = field.offsetWidth;
      const yardPx = fieldWidth / 120;
      const fieldHeight = field.offsetHeight;
      const canvas = document.getElementById("arcCanvas");
      canvas.width = fieldWidth;
      canvas.height = fieldHeight;
      let drivePX = (startYard + 10) * yardPx;
      let prevPX = (prevYard + 10) * yardPx;
      let currPX = (currentYard + 10) * yardPx;
      let drive = document.getElementById("drive3D");
      const driveDot = drive.querySelector(".drive-dot");
      // Handle drive line based on direction
      if (state.Possession == "Home") {
        drive.style.left = `${drivePX}px`;
        drive.style.right = `auto`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = 'auto';
        driveDot.style.left = '0';
      } else {
        drivePX = fieldWidth - drivePX;
        prevPX = fieldWidth - prevPX;
        currPX = fieldWidth - currPX;
        drive.style.left = `auto`;
        drive.style.right = `${drivePX}px`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = '0';
        driveDot.style.left = 'auto';
      }

      const lastPlay = document.getElementById("lastPlayMarker");
      const lastDot = lastPlay.querySelector(".last-dot");
      const arrow = lastPlay.querySelector(".drive-arrow");
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.style.opacity = 0; // Hide previous catch point immediately
      // Fade out old marker
      lastPlay.style.opacity = lastDot.style.opacity = arrow.style.opacity = 0;
      setTimeout(() => {
        lastPlay.style.transition = "none";
        lastPlay.style.backgroundColor = playType === 'Pass' ? 'transparent' : 'black';
        lastPlay.style.width = `0px`;
        lastPlay.style.opacity = 1;
        lastDot.style.opacity = 1;
        arrow.style.opacity = 1;
        if(state.Possession == "Home"){
          lastDot.style.left = `0`;
          lastDot.style.right = `auto`;
          lastPlay.style.left = `${prevPX}px`;
          arrow.style.left = `0px`;
          arrow.style.right = `auto`;
        } else{
          lastDot.style.right = `0`;
          lastDot.style.left = `auto`;
          lastPlay.style.right = `${prevPX}px`;
          arrow.style.left = `auto`;
          arrow.style.right = `0px`;
        }

        if (playType === 'Run') {
          lastPlay.style.top = `50%`;
          lastPlay.style.height = `6px`;
          arrow.style.top = `-10px`;
          setTimeout(() => {
            // Animate based on direction of play
            if (state.Possession == "Home") {
              lastPlay.style.transition = "width 1.4s ease, left 1.4s ease";
              arrow.style.transition = "left 1.4s ease";
              lastPlay.style.left = `${prevPX}px`;
              lastPlay.style.right = `auto`;
              lastPlay.style.width = `${currPX - prevPX}px`;
              arrow.style.left = `${(currPX - prevPX) - 10}px`;
              arrow.style.right = `auto`;
              arrow.style.transform = "rotate(0deg)";
            } else {
              lastPlay.style.transition = "width 1.4s ease, right 1.4s ease";
              arrow.style.transition = "right 1.4s ease";
              lastPlay.style.left = `auto`;
              lastPlay.style.right = `${prevPX}px`;
              lastPlay.style.width = `${(currPX - prevPX)}px`;
              arrow.style.left = `auto`;
              arrow.style.right = `${(currPX - prevPX) - 10}px`;
              arrow.style.transform = "rotate(180deg)";
            }
            const playWidth = currPX - prevPX;
            if (playWidth <= 0) {
              // No animation to wait for; resolve manually after short delay
              setTimeout(() => {
                resolve();
              }, 300);
            } else {
              const onEnd = (e) => {
                if (e.propertyName === 'width') {
                  lastPlay.removeEventListener('transitionend', onEnd);
                  resolve();
                }
              };
              lastPlay.addEventListener('transitionend', onEnd);
            }
          }, 50);
        } else {
          lastDot.style.opacity = arrow.style.opacity = 0;
          drawPassArc(prevPX, currPX, passComplete).then(resolve);
        }
      }, 400);
    });
  }
  function drawPassArc(x0, x1, passComplete = true) {
    return new Promise(resolve => {
      const canvas = document.getElementById("arcCanvas");
      const ctx = canvas.getContext("2d");
      const yardPx = canvas.width / 120;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const midX = (x0 + x1) / 2;
      const y = canvas.height * 0.45;
      const peakHeight = Math.min(yardPx * 12, Math.max(yardPx * 5, (x1 - x0) * 0.6));
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.lineCap = "round";
      let offset = 0;
        let startTime = null;
        function animate(time) {
          if (!startTime) startTime = time;
          const elapsed = time - startTime;
        offset -= 2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setLineDash([10, 5]);
        ctx.lineDashOffset = offset;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.quadraticCurveTo(midX, y - peakHeight, x1, y);
        ctx.stroke();
        if (elapsed < 3000) {
          requestAnimationFrame(animate);
        } else {
          showCatchPoint(x1, y, passComplete).then(resolve);
        }
      }
      requestAnimationFrame(animate);
    });
  }
  function showCatchPoint(x, y, complete = true) {
    return new Promise(resolve => {
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.innerText = complete ? "‚û§" : "‚úñ";
      catchPoint.style.left = `${x - 8}px`;
      catchPoint.style.top = `${y - 20}px`;
      catchPoint.style.opacity = 0;
      // Fade in and stay
      setTimeout(() => {
        catchPoint.style.transition = "opacity 0.8s ease";
        catchPoint.style.opacity = 1;
        setTimeout(resolve, 800);
      }, 100);
    });
  }

  function playSound(id) {
    const sound = document.getElementById(id);
    if (sound) {
      sound.currentTime = 0; // rewind
      sound.play();
    }
  }

  // On load
  refreshUI();
</script>