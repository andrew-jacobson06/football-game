<script>
  let state = {};
  let players = [];
  let playerTraits = {};
  let rollThresholds = [];
  let breakawaySettings = [];
  let drainSettings = {};  // Populated from backend on load
  let frontendStats = [];
  let gameId = 1;
  let playHistory = [];
  

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const target = document.getElementById(btn.dataset.tab);
        if (target) target.classList.add('active');
      });
    });
    document.querySelectorAll('.boxscore-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.boxscore-pill').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.boxscore-subtab').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        const target = document.getElementById(btn.dataset.subtab);
        if (target) target.classList.add('active');
      });
    });
    loadGamesList();
  });

  function loadGamesList() {
    google.script.run.withSuccessHandler(renderGameCards).getGamesList();
  }

  function renderGameCards(games) {
    const container = document.getElementById('gameCarousel');
    if (!container) return;
    container.innerHTML = '';
    games.forEach(g => {
      const card = document.createElement('div');
      const id = Number(g.GameId);
      card.className = 'game-card' + (id === gameId ? ' active' : '');
      card.innerHTML = `<div class="teams">${g.Away} @ ${g.Home}</div><div class="score">${g.AwayScore} - ${g.HomeScore}</div>`;
      card.addEventListener('click', () => {
        refreshUI(id);
        document.querySelectorAll('.game-card').forEach(c => c.classList.remove('active'));
        card.classList.add('active');
      });
      container.appendChild(card);
    });
  }

  function toggleMenu() {
    document.getElementById('playerMenu').classList.toggle('open');
  }

  function renderPlayerCards() {
    const menu = document.getElementById('playerMenu');
    if (!menu) return;
    menu.innerHTML = '';
    Object.values(playerTraits).forEach(p => {
      const card = document.createElement('div');
      card.className = 'player-card';
      card.innerHTML = `
            <h4>${p.name}</h4>
            <div>Size: ${p.size}</div>
            <div>Strength: ${p.strength}</div>
            <div>Speed: ${p.speed}</div>
            <div>Stamina: ${p.stamina}</div>
          `;
      menu.appendChild(card);
    });
  }

  // === GAME SETUP ===
  function refreshUI(selectedGameId) {
    state = {};
    players = [];
    playerTraits = {};
    rollThresholds = [];
    breakawaySettings = [];
    drainSettings = {};  // Populated from backend on load
    frontendStats = [];
    playHistory = [];
    if (typeof selectedGameId !== 'undefined') {
      gameId = selectedGameId;
    }
    google.script.run.withSuccessHandler(function (gameState) {
      console.log("✅ Loaded game state");
      if (!gameState) {
        console.error(`❌ No game state returned for game ${gameId}`);
        return;
      }
      state = gameState;
      updateStateUI();

      loadPlayersTraits(function () {
        loadSettings(function () {
          google.script.run
            .withSuccessHandler(async function (data) {
              console.log("✅ Loaded play history", data);
              playHistory = data;
              frontendStats = [];

              playHistory.forEach(play => {
                if (!play.Player || !play.PlayType || play.PlayType !== 'Run') return;

                const player = play.Player;
                const team = play.Possession || '';
                const yards = parseFloat(play.Yards) || 0;
                const td = play.Result === "Touchdown";
                const fumble = play.Result === "Fumble";

                let p = frontendStats.find(s => s.playername === player && s.team === team);
                if (!p) {
                  p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
                  frontendStats.push(p);
                }

                p.carries++;
                p.yards += yards;
                if (td) p.tds++;
                if (fumble) p.fumbles++;
                if (yards > p.long) p.long = yards;
              });

              renderPlayTimeline();

              updateFatigueBasedOnStatsOnInitialLoad();
              renderBoxScore();
              await animatePlay();
            })
            .withFailureHandler(function (error) {
              console.error("❌ Failed to load play history:", error.message);
            })
            .getPlayHistory(gameId);
        });
      });
    }).withFailureHandler(function (error) {
      console.error("❌ Failed to load game state:", error.message);
    }).getGameState(gameId);

  }


  function updateFatigueBasedOnStatsOnInitialLoad() {
    if (playerTraits && drainSettings && drainSettings.Run) {
      for (let i = 0; i < frontendStats.length; i++) {
        const stat = frontendStats[i];
        const pt = playerTraits[stat.playername];
        if (pt) {
          pt.fatigue = pt.stamina - (stat.carries * drainSettings.Run);
        }
      }
    }
  }
  async function animatePlay() { 
    // use current game state to drive the animation in the proper direction
    await show3DDrive(state.DriveStart, state.Previous, state.BallOn, playType = 'run', passComplete = true); //CHANGE - dont hardcode run and pass
  }

  function formatBallOn(yard) {
    yard = parseInt(yard, 10);
    // Convert field position to the perspective of the team with the ball
    const perspectiveYard = state.Possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatBallOnForPoss(yard, possession) {
    yard = parseInt(yard, 10);
    const perspectiveYard = possession === "Home" ? yard : 100 - yard;
    if (perspectiveYard <= 50) return "own " + perspectiveYard;
    return "opp " + (100 - perspectiveYard);
  }

  function formatDownDistance(down, distance) {
    const ord = ["1st", "2nd", "3rd", "4th"];
    const d = ord[down - 1] || down + "th";
    return `${d} & ${distance}`;
  }

  function formatQuarter(qtr) {
    const ord = ["1st", "2nd", "3rd", "4th", "OT"];
    return ord[qtr - 1] || qtr + "th";
  }

  function computeDriveInfo() {
    let plays = 0;
    for (let i = playHistory.length - 1; i >= 0; i--) {
      const play = playHistory[i];
      if (play.Possession !== state.Possession) break;
      plays++;
    }
    const yards = state.Possession === "Home"
      ? state.BallOn - state.DriveStart
      : state.DriveStart - state.BallOn;
    //return { plays, yards: Math.max(0, yards) };
    document.getElementById("driveInfo").innerText = `${plays} plays, ${yards} yards`;
  }

  function updateTimeoutDots(id, count) {
    const container = document.getElementById(id);
    if (!container) return;
    const dots = Array.from(container.children);
    dots.forEach((dot, idx) => {
      dot.classList.toggle('used', idx >= count);
    });
  }

  function buildPlayText(play) {
    let text = `<strong>${play.Player}</strong> runs for ${play.Yards} Yards.`;

    if (play.Result && play.Result !== "Normal") {
      if (play.Result === "Touchdown") {
        text += ` <span style="color:green; font-weight:bold;">${play.Result}!</span>`;
      } else if (play.Result === "TO on Downs") {
        text += ` <span style="color:red; font-weight:bold;">${play.Result}!</span>`;
      } else {
        text += ` <strong>${play.Result}!</strong>`;
      }
    }

    text += ` Tackle made at the ${formatBallOnForPoss(play.NewBallOn, play.Possession)} by ${play.Tackler}.`;

    return text;
  }

  function renderPlayTimeline() {
    const container = document.getElementById("playTimeline");
    if (!container) return;
    container.innerHTML = "";
    playHistory.forEach(play => {
      if (!play.Player || (play.PlayType && play.PlayType !== "Run")) return;
      const time = new Date(play.Timestamp).toLocaleTimeString();
      const downDist = formatDownDistance(play.Down, play.Distance);
      const text = buildPlayText(play);
      const offense = play.Possession || "";
      const score = `${play.homeScore !== undefined ? play.homeScore : state.HomeScore} - ${play.AwayScore !== undefined ? play.AwayScore : state.AwayScore}`;
      const row = document.createElement("tr");
      row.innerHTML = `<td>${time}</td><td><div class="play-down">${downDist}</div><div class="play-text">${text}</div></td><td>${offense}</td><td>${score}</td>`;
      container.appendChild(row);
    });
    computeDriveInfo();
  }

  function loadPlayers() {
    const dropdown = document.getElementById("playerDropdown");
    dropdown.innerHTML = "";

    const teamName = state[state.Possession];

    Object.entries(playerTraits).forEach(([name, traits]) => {
      if (traits.team === teamName) {
        const option = document.createElement("option");
        option.value = name;
        option.text = name;
        dropdown.appendChild(option);
      }
    });
  }

  function loadPlayersTraits(callback) {
    google.script.run.withSuccessHandler(function (playerData) {
      console.log("✅ Loaded player traits");
      const playerMap = {};
      playerData.forEach(player => {
        playerTraits[player.name] = player;
      });
      loadPlayers();
      renderPlayerCards();
      if (callback) callback();
    }).getPlayerTraits();
  }

  function loadSettings(callback) {
    console.log("✅ Loaded drain settings");
    google.script.run.withSuccessHandler(function (data) {
      rollThresholds = data.thresholds;
      breakawaySettings = data.breakaways;
      drainSettings = data.staminaDrains;
      if (callback) callback();
    }).getFrontendSettings();
  }

  // === MAIN PLAY ===
  async function runPlay() {
    const playerName = document.getElementById("playerDropdown").value;
    if (!playerName) return;

    let tackler = "NA";

    const rbStats = playerTraits[playerName];
    const carryResult = simulateSingleCarry(rbStats);
    const predicted = predictPlayType(state.Down, state.Distance);

    const yardDelta = carryResult.yards;
    const scoringTeam = state.Possession;
    const oldScore = scoringTeam === "Home"
      ? parseInt(state.HomeScore, 10) || 0
      : parseInt(state.AwayScore, 10) || 0;
    // Home drives left ➡ right (0 -> 100); Away drives right ➡ left (100 -> 0)
    const newBall = state.Possession === "Home"
      ? Math.min(100, Math.max(0, state.BallOn + yardDelta))
      : Math.max(0, Math.min(100, state.BallOn - yardDelta));
    const touchdown = state.Possession === "Home"
      ? (state.BallOn < 100 && newBall >= 100)
      : (state.BallOn > 0 && newBall <= 0);

    let newDown = state.Down;
    let newDist = state.Distance - yardDelta;

    let result = "Normal";

    let recordedYards = yardDelta;
    if (touchdown) {
      await handleTouchdown(newBall, playerName, carryResult, tackler, predicted);
      recordedYards = carryResult.yards; // handleTouchdown adjusts yards
      await celebrateTouchdown(scoringTeam, oldScore, oldScore + 6);
    } else if (newDist <= 0) {
      result = "First Down";
      newDown = 1;
      newDist = 10;
      updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, yardDelta, tackler, result, predicted);
      await animatePlay();
      playSound("crowdRoar");
    } else {
      newDown++;
      if (newDown > 4) {
        await handleTOonDowns(result, newBall, playerName, carryResult, tackler, predicted);
      } else {
        updateGameState(newDown, newDist, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, yardDelta, tackler, result, predicted);
        await animatePlay();
      }
    }

    applyFatigue(playerName, "Run");

    updateFrontendStats(playerName, recordedYards, touchdown, state.Possession);
    console.log(carryResult);

    document.getElementById("result").innerHTML = `<strong>${rbStats.name}</strong> ran for <strong>${carryResult.yards} yards</strong><br/><br/>` +
      `Modifiers: <ul>${carryResult.modLog.map(m => `<li>${m}</li>`).join('')}</ul>`;

    updateStateUI();
    //refreshUI();
  }

  async function handleTouchdown(newBall, playerName, carryResult, tackler, predicted) {
    const result = "Touchdown";
    // Distance covered to reach the goal line differs by team direction
    carryResult.yards = state.Possession === "Home" ? (100 - state.BallOn) : state.BallOn;
    if (state.Possession === "Home") {
      state.HomeScore = (parseInt(state.HomeScore, 10) || 0) + 6;
    } else if (state.Possession === "Away") {
      state.AwayScore = (parseInt(state.AwayScore, 10) || 0) + 6;
    }
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, carryResult.yards, tackler, result, predicted);

    await animatePlay();
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    const newBallOn = newPossession === "Home" ? 25 : 75;
    updateGameState(1, 10, newPossession, newBallOn, newBallOn, newBallOn, playerName, carryResult.yards, tackler, null, predicted);
    loadPlayers();
  }

  async function handleTOonDowns(result, newBall, playerName, carryResult, tackler, predicted) {
    result = "TO on Downs";
    updateGameState(1, 10, state.Possession, newBall, state.BallOn, state.DriveStart, playerName, carryResult.yards, tackler, result, predicted);

    await animatePlay();
    playSound("crowdRoar");

    const newPossession = state.Possession === "Home" ? "Away" : "Home";
    updateGameState(1, 10, newPossession, newBall, newBall, newBall, playerName, carryResult.yards, tackler, null, predicted);
    loadPlayers();
  }

  function logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, yards, tackler, result, predicted) {
    const timestamp = new Date().toISOString();
    const localPlay = {
      Timestamp: timestamp,
      Down: state.Down,
      Distance: state.Distance,
      Player: playerName,
      Yards: yards,
      Result: result || "Normal",
      NewBallOn: ballOn,
      Tackler: tackler,
      Possession: state.Possession,
      HomeScore: state.HomeScore,
      AwayScore: state.AwayScore,
      PlayType: "Run"
    };
    playHistory.push(localPlay);

    google.script.run.logPlayHistory({
      gameid: gameId,
      timestamp: timestamp, // ✅ passed in from frontend
      possession: state.Possession,
      down: state.Down,
      distance: state.Distance,
      ballon: state.BallOn,
      playtype: "Run",
      player: playerName,
      yards: yards,
      defensepredicted: predicted,
      predictioncorrect: "",
      tackler: tackler,
      result: result,
      desc: "",
      newdown: down,
      newdist: distance,
      newballon: ballOn,
      drivestart: state.DriveStart,
      homescore: state.HomeScore,
      awayscore: state.AwayScore
    });
  }

  function updateGameState(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, yards, tackler, result, predicted) {
    if(result != null){
      logPlayToDB(down, distance, poss, ballOn, previousBallOn, driveStart, playerName, yards, tackler, result, predicted);
    }
    state.Down = down;
    state.Distance = distance;
    state.BallOn = ballOn
    state.Possession = poss;
    state.Previous = previousBallOn;
    state.DriveStart = driveStart;
    renderPlayTimeline();

    google.script.run.pushGameState({
      gameId: gameId,
      quarter: state.Qtr,
      down: state.Down,
      distance: state.Distance,
      ballOn: state.BallOn,
      homeScore: state.HomeScore,
      awayScore: state.AwayScore,
      driveStart: state.DriveStart,
      previous: state.Previous,
      possession: state.Possession
    });
  }

  function updateStateUI() {
    console.log(state);
    document.getElementById("downDistance").innerText = formatDownDistance(state.Down, state.Distance);
    document.getElementById("ballOn").innerText = formatBallOn(state.BallOn);
    document.getElementById("homeName").innerText = state.Home;
    document.getElementById("awayName").innerText = state.Away;
    document.getElementById("homeRecord").innerText = state.HomeRecord || "";
    document.getElementById("awayRecord").innerText = state.AwayRecord || "";
    if (document.getElementById("homeLogo")) document.getElementById("homeLogo").src = state.HomeLogo || "";
    if (document.getElementById("awayLogo")) document.getElementById("awayLogo").src = state.AwayLogo || "";
    document.getElementById("scoreHome").innerText = state.HomeScore;
    document.getElementById("scoreAway").innerText = state.AwayScore;
    document.getElementById("timeQuarter").innerText = `${state.Time} - ${formatQuarter(state.Qtr)}`;
    updateTimeoutDots("homeTimeouts", state.HomeTimeouts || 0);
    updateTimeoutDots("awayTimeouts", state.AwayTimeouts || 0);
    document.getElementById("homeFootball").style.visibility = state.Possession === "Home" ? "visible" : "hidden";
    document.getElementById("awayFootball").style.visibility = state.Possession === "Away" ? "visible" : "hidden";
    const homeTab = document.getElementById("boxHomeTab");
    const awayTab = document.getElementById("boxAwayTab");
    if (homeTab) homeTab.innerText = state.Home;
    if (awayTab) awayTab.innerText = state.Away;
    const titles = [
      ["homePassingTitle", `${state.Home} Passing`],
      ["homeRushingTitle", `${state.Home} Rushing`],
      ["homeReceivingTitle", `${state.Home} Receiving`],
      ["awayPassingTitle", `${state.Away} Passing`],
      ["awayRushingTitle", `${state.Away} Rushing`],
      ["awayReceivingTitle", `${state.Away} Receiving`]
    ];
    titles.forEach(([id, text]) => {
      const el = document.getElementById(id);
      if (el) el.innerText = text;
    });
  }

  function celebrateTouchdown(team, oldScore, newScore) {
    return new Promise(resolve => {
      const scoreboard = document.getElementById("scoreboard");
      const banner = document.getElementById("scoreBanner");
      banner.textContent = "TOUCHDOWN!";
      scoreboard.classList.add("scoring");
      banner.classList.add("show");

      setTimeout(() => {
        banner.classList.remove("show");
        const scoreEl = document.getElementById(team === "Home" ? "scoreHome" : "scoreAway");
        let current = oldScore;
        const increment = newScore > oldScore ? 1 : -1;
        const interval = setInterval(() => {
          current += increment;
          scoreEl.innerText = current;
          if (current === newScore) {
            clearInterval(interval);
            scoreboard.classList.remove("scoring");
            resolve();
          }
        }, 100);
      }, 2000);
    });
  }

  function updateFrontendStats(player, yards, td, team) {
    let p = frontendStats.find(s => s.playername === player && s.team === team);
    if (!p) {
      p = { playername: player, team, carries: 0, yards: 0, tds: 0, fumbles: 0, long: 0 };
      frontendStats.push(p);
    }
    p.carries++;
    p.yards += yards;
    if (td) p.tds++;
    if (yards > p.long) p.long = yards;

    renderBoxScore();
  }

  function renderBoxScore() {
    renderRushingTable("Home");
    renderRushingTable("Away");
  }

  function renderRushingTable(team) {
    const body = document.getElementById(team === "Home" ? "homeRushingBody" : "awayRushingBody");
    if (!body) return;
    body.innerHTML = "";
    const players = frontendStats.filter(p => p.team === team);
    let total = { carries: 0, yards: 0, tds: 0, long: 0 };
    players.forEach(p => {
      const avg = p.carries ? (p.yards / p.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.playername}</td><td>${p.carries}</td><td>${p.yards}</td><td>${avg}</td><td>${p.tds}</td><td>${p.long}</td>`;
      body.appendChild(tr);
      total.carries += p.carries;
      total.yards += p.yards;
      total.tds += p.tds;
      if (p.long > total.long) total.long = p.long;
    });
    if (players.length) {
      const avgTeam = total.carries ? (total.yards / total.carries).toFixed(1) : "0.0";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>TEAM</td><td>${total.carries}</td><td>${total.yards}</td><td>${avgTeam}</td><td>${total.tds}</td><td>${total.long}</td>`;
      body.appendChild(tr);
    }
  }

  function applyFatigue(playerName, actionType) {
    const drain = drainSettings[actionType] || 0;
    playerTraits[playerName].fatigue = playerTraits[playerName].fatigue - drain;
  }

  // === FRONTEND LOGIC ENGINE ===
  function simulateSingleCarry(stats) {
    const modLog = [];
    let roll = getModifiedRoll(stats, modLog);
    roll = maybeBoostRollForAcceleration(roll, stats, modLog);
    let yards = getYardageOutcome(roll, stats, modLog);
    yards = maybeAvoidLoss(yards, stats, modLog);
    yards = adjustChunkRunForSpeed(yards, stats, modLog);

    if (yards <= 2) yards += applyTraitEffect("Vision", stats.vision + Math.min(0, stats.fatigue), true, modLog);
    if (yards <= 4) yards += applyTraitEffect("Power", average(stats.size, stats.strength + Math.min(0, stats.fatigue)), true, modLog);
    if (yards >= 3 && yards <= 4) yards += applyTraitEffect("Acceleration", stats.acceleration + Math.min(0, stats.fatigue), true, modLog);
    if (yards > 0 && yards < 10) yards += applyTraitEffect("Juke", stats.juke + Math.min(0, stats.fatigue), true, modLog);

    return { name: stats.name, roll, yards, modLog };
  }

  function getModifiedRoll(stats, modLog) {
    // Float base roll from 1.000 to ~100.000
    const baseRoll = Math.random() * 99 + 1; // 1–100 float

    // Calculate vision mod
    let visionMod = (stats.vision + Math.min(0, stats.fatigue) - 60) * 0.055;
    modLog.push(`Pre ${visionMod > 0 ? "+" : ""}${visionMod.toFixed(1)} Vision`);

    const modified = baseRoll + visionMod;

    // Clamp final result to valid roll range
    return Math.max(1, Math.min(100, modified));
  }

  function maybeBoostRollForAcceleration(roll, stats, modLog) {
    if (roll < 88) { //CHANGE - solid gain or less. No hard code
      const chance = (stats.acceleration + Math.min(0, stats.fatigue) - 60) / 200;
      if (Math.random() < Math.max(0, chance)) {
        const maxBoost = Math.floor((stats.acceleration + Math.min(0, stats.fatigue) - 60) / 4);
        const boost = randomInt(1, Math.min(10, maxBoost));
        modLog.push(`Pre +${boost} Accel (Boost Roll)`);
        return Math.min(99, roll + boost);
      }
    }
    return roll;
  }

  function getYardageOutcome(roll, stats, modLog) {
    for (const r of rollThresholds) {
      if (roll >= r.rollMin && roll < r.rollMax) {
        if (r.label === "RunType_Breakaway") {
          return getStrictBreakawayYards(stats, modLog);
        }
        return randomInt(r.minYards, r.maxYards);
      }
    }
    return 0;
  }

  function getStrictBreakawayYards(stats, modLog) {
    const baseRoll = Math.floor(Math.random() * 100) + 1;
    const speedBoost = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) * 0.3);
    const adjustedRoll = Math.min(100, baseRoll + Math.max(0, speedBoost));
    if (speedBoost !== 0) modLog.push(`Pre +${speedBoost} Speed`);

    let cumulative = 0;
    for (const range of breakawaySettings) {
      cumulative += range.percentage;
      if (adjustedRoll <= cumulative) {
        return randomInt(range.minYards, range.maxYards);
      }
    }
    return 16;
  }

  function maybeAvoidLoss(yards, stats, modLog) {
    if (yards < 0) {
      const power = stats.size + stats.strength + Math.min(0, stats.fatigue);
      const chanceToAvoid = power / 2.2; //CHANGE - no hard code
      if (Math.random() < chanceToAvoid / 100) {
        const newYards = randomInt(1, 2);
        modLog.push(`Loss Avoided by Power → ${newYards} yds`);
        return newYards;
      }
    }
    return yards;
  }

  function adjustChunkRunForSpeed(yards, stats, modLog) {
    if (yards >= 10 && yards <= 15) { //CHANGE no hard code
      const bonus = Math.floor((stats.speed + Math.min(0, stats.fatigue) - 60) / 10); //CHANGE no hard code
      if (bonus !== 0) modLog.push(`Yard ${bonus > 0 ? "+" : ""}${bonus} Speed`);
      return yards + bonus;
    }
    return yards;
  }

  function applyTraitEffect(traitName, traitValue, condition, modLog) {
    if (!condition) return 0;
    const deviation = traitValue - 60;
    const triggerChance = Math.abs(deviation) / 100;
    if (Math.random() < triggerChance) {
      const effect = Math.sign(deviation) * Math.min(2, Math.floor(Math.abs(deviation) / 15));
      if (effect !== 0) {
        modLog.push(`Yard ${effect > 0 ? "+" : ""}${effect} ${traitName}`);
        return effect;
      }
    }
    return 0;
  }

  function average(a, b) {
    return (a + b) / 2;
  }

  function randomInt(min, max) {
    const range = max - min + 1;
    if (range <= 0) throw new Error("Invalid range");

    const maxUint32 = 0xFFFFFFFF;
    const bucketSize = Math.floor(maxUint32 / range);
    const maxAcceptable = bucketSize * range;

    let rand;
    const uint32 = new Uint32Array(1);

    do {
      window.crypto.getRandomValues(uint32);
      rand = uint32[0];
    } while (rand >= maxAcceptable);

    return min + (rand % range);
  }

  function predictPlayType(down, distance) {
    return "Run"; // Stub, can be enhanced with real logic
  }


  //UI Functions ONLY - ANIMATIONS BELOW!
  function show3DDrive(startYard, prevYard, currentYard, playType = 'run', passComplete = true) {
    return new Promise(resolve => {
      const field = document.getElementById("field3D");
      const fieldWidth = field.offsetWidth;
      const yardPx = fieldWidth / 120;
      const fieldHeight = field.offsetHeight;
      const canvas = document.getElementById("arcCanvas");
      canvas.width = fieldWidth;
      canvas.height = fieldHeight;
      let drivePX = (startYard + 10) * yardPx;
      let prevPX = (prevYard + 10) * yardPx;
      let currPX = (currentYard + 10) * yardPx;
      let drive = document.getElementById("drive3D");
      const driveDot = drive.querySelector(".drive-dot");
      // Handle drive line based on direction
      if (state.Possession == "Home") {
        drive.style.left = `${drivePX}px`;
        drive.style.right = `auto`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = 'auto';
        driveDot.style.left = '0';
      } else {
        drivePX = fieldWidth - drivePX;
        prevPX = fieldWidth - prevPX;
        currPX = fieldWidth - currPX;
        drive.style.left = `auto`;
        drive.style.right = `${drivePX}px`;
        drive.style.width = `${prevPX - drivePX}px`;
        driveDot.style.right = '0';
        driveDot.style.left = 'auto';
      }

      const lastPlay = document.getElementById("lastPlayMarker");
      const lastDot = lastPlay.querySelector(".last-dot");
      const arrow = lastPlay.querySelector(".drive-arrow");
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.style.opacity = 0; // Hide previous catch point immediately
      // Fade out old marker
      lastPlay.style.opacity = lastDot.style.opacity = arrow.style.opacity = 0;
      setTimeout(() => {
        lastPlay.style.transition = "none";
        lastPlay.style.backgroundColor = playType === 'pass' ? 'transparent' : 'black';
        lastPlay.style.width = `0px`;
        lastPlay.style.opacity = 1;
        lastDot.style.opacity = 1;
        arrow.style.opacity = 1;
        if(state.Possession == "Home"){
          lastDot.style.left = `0`;
          lastDot.style.right = `auto`;
          lastPlay.style.left = `${prevPX}px`;
          arrow.style.left = `0px`;
          arrow.style.right = `auto`;
        } else{
          lastDot.style.right = `0`;
          lastDot.style.left = `auto`;
          lastPlay.style.right = `${prevPX}px`;
          arrow.style.left = `auto`;
          arrow.style.right = `0px`;
        }

        if (playType === 'run') {
          lastPlay.style.top = `50%`;
          lastPlay.style.height = `6px`;
          arrow.style.top = `-10px`;
          setTimeout(() => {
            // Animate based on direction of play
            if (state.Possession == "Home") {
              lastPlay.style.transition = "width 1.4s ease, left 1.4s ease";
              arrow.style.transition = "left 1.4s ease";
              lastPlay.style.left = `${prevPX}px`;
              lastPlay.style.right = `auto`;
              lastPlay.style.width = `${currPX - prevPX}px`;
              arrow.style.left = `${(currPX - prevPX) - 10}px`;
              arrow.style.right = `auto`;
              arrow.style.transform = "rotate(0deg)";
            } else {
              lastPlay.style.transition = "width 1.4s ease, right 1.4s ease";
              arrow.style.transition = "right 1.4s ease";
              lastPlay.style.left = `auto`;
              lastPlay.style.right = `${prevPX}px`;
              lastPlay.style.width = `${(currPX - prevPX)}px`;
              arrow.style.left = `auto`;
              arrow.style.right = `${(currPX - prevPX) - 10}px`;
              arrow.style.transform = "rotate(180deg)";
            }
            const playWidth = currPX - prevPX;
            if (playWidth <= 0) {
              // No animation to wait for; resolve manually after short delay
              setTimeout(() => {
                resolve();
              }, 300);
            } else {
              const onEnd = (e) => {
                if (e.propertyName === 'width') {
                  lastPlay.removeEventListener('transitionend', onEnd);
                  resolve();
                }
              };
              lastPlay.addEventListener('transitionend', onEnd);
            }
          }, 50);
        } else {
          lastDot.style.opacity = arrow.style.opacity = 0;
          drawPassArc(prevPX, currPX, passComplete).then(resolve);
        }
      }, 400);
    });
  }
  function drawPassArc(x0, x1, passComplete = true) {
    return new Promise(resolve => {
      const canvas = document.getElementById("arcCanvas");
      const ctx = canvas.getContext("2d");
      const yardPx = canvas.width / 120;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const midX = (x0 + x1) / 2;
      const y = canvas.height * 0.45;
      const peakHeight = Math.min(yardPx * 12, Math.max(yardPx * 5, (x1 - x0) * 0.6));
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.lineCap = "round";
      let offset = 0;
      let startTime = null;
      function animate(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        offset -= 2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setLineDash([10, 5]);
        ctx.lineDashOffset = offset;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.quadraticCurveTo(midX, y - peakHeight, x1, y);
        ctx.stroke();
        if (elapsed < 3000) {
          requestAnimationFrame(animate);
        } else {
          showCatchPoint(x1, y, passComplete).then(resolve);
        }
      }
      requestAnimationFrame(animate);
    });
  }
  function showCatchPoint(x, y, complete = true) {
    return new Promise(resolve => {
      const catchPoint = document.getElementById("catchPoint");
      catchPoint.innerText = complete ? "➤" : "✖";
      catchPoint.style.left = `${x - 8}px`;
      catchPoint.style.top = `${y - 20}px`;
      catchPoint.style.opacity = 0;
      // Fade in and stay
      setTimeout(() => {
        catchPoint.style.transition = "opacity 0.8s ease";
        catchPoint.style.opacity = 1;
        setTimeout(resolve, 800);
      }, 100);
    });
  }

  function playSound(id) {
    const sound = document.getElementById(id);
    if (sound) {
      sound.currentTime = 0; // rewind
      sound.play();
    }
  }

  // On load
  refreshUI();
</script>